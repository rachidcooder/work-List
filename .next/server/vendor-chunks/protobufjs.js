"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/protobufjs";
exports.ids = ["vendor-chunks/protobufjs"];
exports.modules = {

/***/ "(ssr)/../node_modules/protobufjs/ext/descriptor/index.js":
/*!**********************************************************!*\
  !*** ../node_modules/protobufjs/ext/descriptor/index.js ***!
  \**********************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\nvar $protobuf = __webpack_require__(/*! ../.. */ \"(ssr)/../node_modules/protobufjs/index.js\");\nmodule.exports = exports = $protobuf.descriptor = $protobuf.Root.fromJSON(__webpack_require__(/*! ../../google/protobuf/descriptor.json */ \"(ssr)/../node_modules/protobufjs/google/protobuf/descriptor.json\")).lookup(\".google.protobuf\");\nvar Namespace = $protobuf.Namespace, Root = $protobuf.Root, Enum = $protobuf.Enum, Type = $protobuf.Type, Field = $protobuf.Field, MapField = $protobuf.MapField, OneOf = $protobuf.OneOf, Service = $protobuf.Service, Method = $protobuf.Method;\n// --- Root ---\n/**\n * Properties of a FileDescriptorSet message.\n * @interface IFileDescriptorSet\n * @property {IFileDescriptorProto[]} file Files\n */ /**\n * Properties of a FileDescriptorProto message.\n * @interface IFileDescriptorProto\n * @property {string} [name] File name\n * @property {string} [package] Package\n * @property {*} [dependency] Not supported\n * @property {*} [publicDependency] Not supported\n * @property {*} [weakDependency] Not supported\n * @property {IDescriptorProto[]} [messageType] Nested message types\n * @property {IEnumDescriptorProto[]} [enumType] Nested enums\n * @property {IServiceDescriptorProto[]} [service] Nested services\n * @property {IFieldDescriptorProto[]} [extension] Nested extension fields\n * @property {IFileOptions} [options] Options\n * @property {*} [sourceCodeInfo] Not supported\n * @property {string} [syntax=\"proto2\"] Syntax\n */ /**\n * Properties of a FileOptions message.\n * @interface IFileOptions\n * @property {string} [javaPackage]\n * @property {string} [javaOuterClassname]\n * @property {boolean} [javaMultipleFiles]\n * @property {boolean} [javaGenerateEqualsAndHash]\n * @property {boolean} [javaStringCheckUtf8]\n * @property {IFileOptionsOptimizeMode} [optimizeFor=1]\n * @property {string} [goPackage]\n * @property {boolean} [ccGenericServices]\n * @property {boolean} [javaGenericServices]\n * @property {boolean} [pyGenericServices]\n * @property {boolean} [deprecated]\n * @property {boolean} [ccEnableArenas]\n * @property {string} [objcClassPrefix]\n * @property {string} [csharpNamespace]\n */ /**\n * Values of he FileOptions.OptimizeMode enum.\n * @typedef IFileOptionsOptimizeMode\n * @type {number}\n * @property {number} SPEED=1\n * @property {number} CODE_SIZE=2\n * @property {number} LITE_RUNTIME=3\n */ /**\n * Creates a root from a descriptor set.\n * @param {IFileDescriptorSet|Reader|Uint8Array} descriptor Descriptor\n * @returns {Root} Root instance\n */ Root.fromDescriptor = function fromDescriptor(descriptor) {\n    // Decode the descriptor message if specified as a buffer:\n    if (typeof descriptor.length === \"number\") descriptor = exports.FileDescriptorSet.decode(descriptor);\n    var root = new Root();\n    if (descriptor.file) {\n        var fileDescriptor, filePackage;\n        for(var j = 0, i; j < descriptor.file.length; ++j){\n            filePackage = root;\n            if ((fileDescriptor = descriptor.file[j])[\"package\"] && fileDescriptor[\"package\"].length) filePackage = root.define(fileDescriptor[\"package\"]);\n            if (fileDescriptor.name && fileDescriptor.name.length) root.files.push(filePackage.filename = fileDescriptor.name);\n            if (fileDescriptor.messageType) for(i = 0; i < fileDescriptor.messageType.length; ++i)filePackage.add(Type.fromDescriptor(fileDescriptor.messageType[i], fileDescriptor.syntax));\n            if (fileDescriptor.enumType) for(i = 0; i < fileDescriptor.enumType.length; ++i)filePackage.add(Enum.fromDescriptor(fileDescriptor.enumType[i]));\n            if (fileDescriptor.extension) for(i = 0; i < fileDescriptor.extension.length; ++i)filePackage.add(Field.fromDescriptor(fileDescriptor.extension[i]));\n            if (fileDescriptor.service) for(i = 0; i < fileDescriptor.service.length; ++i)filePackage.add(Service.fromDescriptor(fileDescriptor.service[i]));\n            var opts = fromDescriptorOptions(fileDescriptor.options, exports.FileOptions);\n            if (opts) {\n                var ks = Object.keys(opts);\n                for(i = 0; i < ks.length; ++i)filePackage.setOption(ks[i], opts[ks[i]]);\n            }\n        }\n    }\n    return root;\n};\n/**\n * Converts a root to a descriptor set.\n * @returns {Message<IFileDescriptorSet>} Descriptor\n * @param {string} [syntax=\"proto2\"] Syntax\n */ Root.prototype.toDescriptor = function toDescriptor(syntax) {\n    var set = exports.FileDescriptorSet.create();\n    Root_toDescriptorRecursive(this, set.file, syntax);\n    return set;\n};\n// Traverses a namespace and assembles the descriptor set\nfunction Root_toDescriptorRecursive(ns, files, syntax) {\n    // Create a new file\n    var file = exports.FileDescriptorProto.create({\n        name: ns.filename || (ns.fullName.substring(1).replace(/\\./g, \"_\") || \"root\") + \".proto\"\n    });\n    if (syntax) file.syntax = syntax;\n    if (!(ns instanceof Root)) file[\"package\"] = ns.fullName.substring(1);\n    // Add nested types\n    for(var i = 0, nested; i < ns.nestedArray.length; ++i)if ((nested = ns._nestedArray[i]) instanceof Type) file.messageType.push(nested.toDescriptor(syntax));\n    else if (nested instanceof Enum) file.enumType.push(nested.toDescriptor());\n    else if (nested instanceof Field) file.extension.push(nested.toDescriptor(syntax));\n    else if (nested instanceof Service) file.service.push(nested.toDescriptor());\n    else if (nested instanceof /* plain */ Namespace) Root_toDescriptorRecursive(nested, files, syntax); // requires new file\n    // Keep package-level options\n    file.options = toDescriptorOptions(ns.options, exports.FileOptions);\n    // And keep the file only if there is at least one nested object\n    if (file.messageType.length + file.enumType.length + file.extension.length + file.service.length) files.push(file);\n}\n// --- Type ---\n/**\n * Properties of a DescriptorProto message.\n * @interface IDescriptorProto\n * @property {string} [name] Message type name\n * @property {IFieldDescriptorProto[]} [field] Fields\n * @property {IFieldDescriptorProto[]} [extension] Extension fields\n * @property {IDescriptorProto[]} [nestedType] Nested message types\n * @property {IEnumDescriptorProto[]} [enumType] Nested enums\n * @property {IDescriptorProtoExtensionRange[]} [extensionRange] Extension ranges\n * @property {IOneofDescriptorProto[]} [oneofDecl] Oneofs\n * @property {IMessageOptions} [options] Not supported\n * @property {IDescriptorProtoReservedRange[]} [reservedRange] Reserved ranges\n * @property {string[]} [reservedName] Reserved names\n */ /**\n * Properties of a MessageOptions message.\n * @interface IMessageOptions\n * @property {boolean} [mapEntry=false] Whether this message is a map entry\n */ /**\n * Properties of an ExtensionRange message.\n * @interface IDescriptorProtoExtensionRange\n * @property {number} [start] Start field id\n * @property {number} [end] End field id\n */ /**\n * Properties of a ReservedRange message.\n * @interface IDescriptorProtoReservedRange\n * @property {number} [start] Start field id\n * @property {number} [end] End field id\n */ var unnamedMessageIndex = 0;\n/**\n * Creates a type from a descriptor.\n * @param {IDescriptorProto|Reader|Uint8Array} descriptor Descriptor\n * @param {string} [syntax=\"proto2\"] Syntax\n * @returns {Type} Type instance\n */ Type.fromDescriptor = function fromDescriptor(descriptor, syntax) {\n    // Decode the descriptor message if specified as a buffer:\n    if (typeof descriptor.length === \"number\") descriptor = exports.DescriptorProto.decode(descriptor);\n    // Create the message type\n    var type = new Type(descriptor.name.length ? descriptor.name : \"Type\" + unnamedMessageIndex++, fromDescriptorOptions(descriptor.options, exports.MessageOptions)), i;\n    /* Oneofs */ if (descriptor.oneofDecl) for(i = 0; i < descriptor.oneofDecl.length; ++i)type.add(OneOf.fromDescriptor(descriptor.oneofDecl[i]));\n    /* Fields */ if (descriptor.field) for(i = 0; i < descriptor.field.length; ++i){\n        var field = Field.fromDescriptor(descriptor.field[i], syntax);\n        type.add(field);\n        if (descriptor.field[i].hasOwnProperty(\"oneofIndex\")) type.oneofsArray[descriptor.field[i].oneofIndex].add(field);\n    }\n    /* Extension fields */ if (descriptor.extension) for(i = 0; i < descriptor.extension.length; ++i)type.add(Field.fromDescriptor(descriptor.extension[i], syntax));\n    /* Nested types */ if (descriptor.nestedType) for(i = 0; i < descriptor.nestedType.length; ++i){\n        type.add(Type.fromDescriptor(descriptor.nestedType[i], syntax));\n        if (descriptor.nestedType[i].options && descriptor.nestedType[i].options.mapEntry) type.setOption(\"map_entry\", true);\n    }\n    /* Nested enums */ if (descriptor.enumType) for(i = 0; i < descriptor.enumType.length; ++i)type.add(Enum.fromDescriptor(descriptor.enumType[i]));\n    /* Extension ranges */ if (descriptor.extensionRange && descriptor.extensionRange.length) {\n        type.extensions = [];\n        for(i = 0; i < descriptor.extensionRange.length; ++i)type.extensions.push([\n            descriptor.extensionRange[i].start,\n            descriptor.extensionRange[i].end\n        ]);\n    }\n    /* Reserved... */ if (descriptor.reservedRange && descriptor.reservedRange.length || descriptor.reservedName && descriptor.reservedName.length) {\n        type.reserved = [];\n        /* Ranges */ if (descriptor.reservedRange) for(i = 0; i < descriptor.reservedRange.length; ++i)type.reserved.push([\n            descriptor.reservedRange[i].start,\n            descriptor.reservedRange[i].end\n        ]);\n        /* Names */ if (descriptor.reservedName) for(i = 0; i < descriptor.reservedName.length; ++i)type.reserved.push(descriptor.reservedName[i]);\n    }\n    return type;\n};\n/**\n * Converts a type to a descriptor.\n * @returns {Message<IDescriptorProto>} Descriptor\n * @param {string} [syntax=\"proto2\"] Syntax\n */ Type.prototype.toDescriptor = function toDescriptor(syntax) {\n    var descriptor = exports.DescriptorProto.create({\n        name: this.name\n    }), i;\n    /* Fields */ for(i = 0; i < this.fieldsArray.length; ++i){\n        var fieldDescriptor;\n        descriptor.field.push(fieldDescriptor = this._fieldsArray[i].toDescriptor(syntax));\n        if (this._fieldsArray[i] instanceof MapField) {\n            var keyType = toDescriptorType(this._fieldsArray[i].keyType, this._fieldsArray[i].resolvedKeyType), valueType = toDescriptorType(this._fieldsArray[i].type, this._fieldsArray[i].resolvedType), valueTypeName = valueType === /* type */ 11 || valueType === /* enum */ 14 ? this._fieldsArray[i].resolvedType && shortname(this.parent, this._fieldsArray[i].resolvedType) || this._fieldsArray[i].type : undefined;\n            descriptor.nestedType.push(exports.DescriptorProto.create({\n                name: fieldDescriptor.typeName,\n                field: [\n                    exports.FieldDescriptorProto.create({\n                        name: \"key\",\n                        number: 1,\n                        label: 1,\n                        type: keyType\n                    }),\n                    exports.FieldDescriptorProto.create({\n                        name: \"value\",\n                        number: 2,\n                        label: 1,\n                        type: valueType,\n                        typeName: valueTypeName\n                    })\n                ],\n                options: exports.MessageOptions.create({\n                    mapEntry: true\n                })\n            }));\n        }\n    }\n    /* Oneofs */ for(i = 0; i < this.oneofsArray.length; ++i)descriptor.oneofDecl.push(this._oneofsArray[i].toDescriptor());\n    /* Nested... */ for(i = 0; i < this.nestedArray.length; ++i){\n        /* Extension fields */ if (this._nestedArray[i] instanceof Field) descriptor.field.push(this._nestedArray[i].toDescriptor(syntax));\n        else if (this._nestedArray[i] instanceof Type) descriptor.nestedType.push(this._nestedArray[i].toDescriptor(syntax));\n        else if (this._nestedArray[i] instanceof Enum) descriptor.enumType.push(this._nestedArray[i].toDescriptor());\n    // plain nested namespaces become packages instead in Root#toDescriptor\n    }\n    /* Extension ranges */ if (this.extensions) for(i = 0; i < this.extensions.length; ++i)descriptor.extensionRange.push(exports.DescriptorProto.ExtensionRange.create({\n        start: this.extensions[i][0],\n        end: this.extensions[i][1]\n    }));\n    /* Reserved... */ if (this.reserved) for(i = 0; i < this.reserved.length; ++i)/* Names */ if (typeof this.reserved[i] === \"string\") descriptor.reservedName.push(this.reserved[i]);\n    else descriptor.reservedRange.push(exports.DescriptorProto.ReservedRange.create({\n        start: this.reserved[i][0],\n        end: this.reserved[i][1]\n    }));\n    descriptor.options = toDescriptorOptions(this.options, exports.MessageOptions);\n    return descriptor;\n};\n// --- Field ---\n/**\n * Properties of a FieldDescriptorProto message.\n * @interface IFieldDescriptorProto\n * @property {string} [name] Field name\n * @property {number} [number] Field id\n * @property {IFieldDescriptorProtoLabel} [label] Field rule\n * @property {IFieldDescriptorProtoType} [type] Field basic type\n * @property {string} [typeName] Field type name\n * @property {string} [extendee] Extended type name\n * @property {string} [defaultValue] Literal default value\n * @property {number} [oneofIndex] Oneof index if part of a oneof\n * @property {*} [jsonName] Not supported\n * @property {IFieldOptions} [options] Field options\n */ /**\n * Values of the FieldDescriptorProto.Label enum.\n * @typedef IFieldDescriptorProtoLabel\n * @type {number}\n * @property {number} LABEL_OPTIONAL=1\n * @property {number} LABEL_REQUIRED=2\n * @property {number} LABEL_REPEATED=3\n */ /**\n * Values of the FieldDescriptorProto.Type enum.\n * @typedef IFieldDescriptorProtoType\n * @type {number}\n * @property {number} TYPE_DOUBLE=1\n * @property {number} TYPE_FLOAT=2\n * @property {number} TYPE_INT64=3\n * @property {number} TYPE_UINT64=4\n * @property {number} TYPE_INT32=5\n * @property {number} TYPE_FIXED64=6\n * @property {number} TYPE_FIXED32=7\n * @property {number} TYPE_BOOL=8\n * @property {number} TYPE_STRING=9\n * @property {number} TYPE_GROUP=10\n * @property {number} TYPE_MESSAGE=11\n * @property {number} TYPE_BYTES=12\n * @property {number} TYPE_UINT32=13\n * @property {number} TYPE_ENUM=14\n * @property {number} TYPE_SFIXED32=15\n * @property {number} TYPE_SFIXED64=16\n * @property {number} TYPE_SINT32=17\n * @property {number} TYPE_SINT64=18\n */ /**\n * Properties of a FieldOptions message.\n * @interface IFieldOptions\n * @property {boolean} [packed] Whether packed or not (defaults to `false` for proto2 and `true` for proto3)\n * @property {IFieldOptionsJSType} [jstype] JavaScript value type (not used by protobuf.js)\n */ /**\n * Values of the FieldOptions.JSType enum.\n * @typedef IFieldOptionsJSType\n * @type {number}\n * @property {number} JS_NORMAL=0\n * @property {number} JS_STRING=1\n * @property {number} JS_NUMBER=2\n */ // copied here from parse.js\nvar numberRe = /^(?![eE])[0-9]*(?:\\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/;\n/**\n * Creates a field from a descriptor.\n * @param {IFieldDescriptorProto|Reader|Uint8Array} descriptor Descriptor\n * @param {string} [syntax=\"proto2\"] Syntax\n * @returns {Field} Field instance\n */ Field.fromDescriptor = function fromDescriptor(descriptor, syntax) {\n    // Decode the descriptor message if specified as a buffer:\n    if (typeof descriptor.length === \"number\") descriptor = exports.DescriptorProto.decode(descriptor);\n    if (typeof descriptor.number !== \"number\") throw Error(\"missing field id\");\n    // Rewire field type\n    var fieldType;\n    if (descriptor.typeName && descriptor.typeName.length) fieldType = descriptor.typeName;\n    else fieldType = fromDescriptorType(descriptor.type);\n    // Rewire field rule\n    var fieldRule;\n    switch(descriptor.label){\n        // 0 is reserved for errors\n        case 1:\n            fieldRule = undefined;\n            break;\n        case 2:\n            fieldRule = \"required\";\n            break;\n        case 3:\n            fieldRule = \"repeated\";\n            break;\n        default:\n            throw Error(\"illegal label: \" + descriptor.label);\n    }\n    var extendee = descriptor.extendee;\n    if (descriptor.extendee !== undefined) {\n        extendee = extendee.length ? extendee : undefined;\n    }\n    var field = new Field(descriptor.name.length ? descriptor.name : \"field\" + descriptor.number, descriptor.number, fieldType, fieldRule, extendee);\n    field.options = fromDescriptorOptions(descriptor.options, exports.FieldOptions);\n    if (descriptor.defaultValue && descriptor.defaultValue.length) {\n        var defaultValue = descriptor.defaultValue;\n        switch(defaultValue){\n            case \"true\":\n            case \"TRUE\":\n                defaultValue = true;\n                break;\n            case \"false\":\n            case \"FALSE\":\n                defaultValue = false;\n                break;\n            default:\n                var match = numberRe.exec(defaultValue);\n                if (match) defaultValue = parseInt(defaultValue); // eslint-disable-line radix\n                break;\n        }\n        field.setOption(\"default\", defaultValue);\n    }\n    if (packableDescriptorType(descriptor.type)) {\n        if (syntax === \"proto3\") {\n            if (descriptor.options && !descriptor.options.packed) field.setOption(\"packed\", false);\n        } else if (!(descriptor.options && descriptor.options.packed)) field.setOption(\"packed\", false);\n    }\n    return field;\n};\n/**\n * Converts a field to a descriptor.\n * @returns {Message<IFieldDescriptorProto>} Descriptor\n * @param {string} [syntax=\"proto2\"] Syntax\n */ Field.prototype.toDescriptor = function toDescriptor(syntax) {\n    var descriptor = exports.FieldDescriptorProto.create({\n        name: this.name,\n        number: this.id\n    });\n    if (this.map) {\n        descriptor.type = 11; // message\n        descriptor.typeName = $protobuf.util.ucFirst(this.name); // fieldName -> FieldNameEntry (built in Type#toDescriptor)\n        descriptor.label = 3; // repeated\n    } else {\n        // Rewire field type\n        switch(descriptor.type = toDescriptorType(this.type, this.resolve().resolvedType)){\n            case 10:\n            case 11:\n            case 14:\n                descriptor.typeName = this.resolvedType ? shortname(this.parent, this.resolvedType) : this.type;\n                break;\n        }\n        // Rewire field rule\n        switch(this.rule){\n            case \"repeated\":\n                descriptor.label = 3;\n                break;\n            case \"required\":\n                descriptor.label = 2;\n                break;\n            default:\n                descriptor.label = 1;\n                break;\n        }\n    }\n    // Handle extension field\n    descriptor.extendee = this.extensionField ? this.extensionField.parent.fullName : this.extend;\n    // Handle part of oneof\n    if (this.partOf) {\n        if ((descriptor.oneofIndex = this.parent.oneofsArray.indexOf(this.partOf)) < 0) throw Error(\"missing oneof\");\n    }\n    if (this.options) {\n        descriptor.options = toDescriptorOptions(this.options, exports.FieldOptions);\n        if (this.options[\"default\"] != null) descriptor.defaultValue = String(this.options[\"default\"]);\n    }\n    if (syntax === \"proto3\") {\n        if (!this.packed) (descriptor.options || (descriptor.options = exports.FieldOptions.create())).packed = false;\n    } else if (this.packed) (descriptor.options || (descriptor.options = exports.FieldOptions.create())).packed = true;\n    return descriptor;\n};\n// --- Enum ---\n/**\n * Properties of an EnumDescriptorProto message.\n * @interface IEnumDescriptorProto\n * @property {string} [name] Enum name\n * @property {IEnumValueDescriptorProto[]} [value] Enum values\n * @property {IEnumOptions} [options] Enum options\n */ /**\n * Properties of an EnumValueDescriptorProto message.\n * @interface IEnumValueDescriptorProto\n * @property {string} [name] Name\n * @property {number} [number] Value\n * @property {*} [options] Not supported\n */ /**\n * Properties of an EnumOptions message.\n * @interface IEnumOptions\n * @property {boolean} [allowAlias] Whether aliases are allowed\n * @property {boolean} [deprecated]\n */ var unnamedEnumIndex = 0;\n/**\n * Creates an enum from a descriptor.\n * @param {IEnumDescriptorProto|Reader|Uint8Array} descriptor Descriptor\n * @returns {Enum} Enum instance\n */ Enum.fromDescriptor = function fromDescriptor(descriptor) {\n    // Decode the descriptor message if specified as a buffer:\n    if (typeof descriptor.length === \"number\") descriptor = exports.EnumDescriptorProto.decode(descriptor);\n    // Construct values object\n    var values = {};\n    if (descriptor.value) for(var i = 0; i < descriptor.value.length; ++i){\n        var name = descriptor.value[i].name, value = descriptor.value[i].number || 0;\n        values[name && name.length ? name : \"NAME\" + value] = value;\n    }\n    return new Enum(descriptor.name && descriptor.name.length ? descriptor.name : \"Enum\" + unnamedEnumIndex++, values, fromDescriptorOptions(descriptor.options, exports.EnumOptions));\n};\n/**\n * Converts an enum to a descriptor.\n * @returns {Message<IEnumDescriptorProto>} Descriptor\n */ Enum.prototype.toDescriptor = function toDescriptor() {\n    // Values\n    var values = [];\n    for(var i = 0, ks = Object.keys(this.values); i < ks.length; ++i)values.push(exports.EnumValueDescriptorProto.create({\n        name: ks[i],\n        number: this.values[ks[i]]\n    }));\n    return exports.EnumDescriptorProto.create({\n        name: this.name,\n        value: values,\n        options: toDescriptorOptions(this.options, exports.EnumOptions)\n    });\n};\n// --- OneOf ---\n/**\n * Properties of a OneofDescriptorProto message.\n * @interface IOneofDescriptorProto\n * @property {string} [name] Oneof name\n * @property {*} [options] Not supported\n */ var unnamedOneofIndex = 0;\n/**\n * Creates a oneof from a descriptor.\n * @param {IOneofDescriptorProto|Reader|Uint8Array} descriptor Descriptor\n * @returns {OneOf} OneOf instance\n */ OneOf.fromDescriptor = function fromDescriptor(descriptor) {\n    // Decode the descriptor message if specified as a buffer:\n    if (typeof descriptor.length === \"number\") descriptor = exports.OneofDescriptorProto.decode(descriptor);\n    return new OneOf(// unnamedOneOfIndex is global, not per type, because we have no ref to a type here\n    descriptor.name && descriptor.name.length ? descriptor.name : \"oneof\" + unnamedOneofIndex++);\n};\n/**\n * Converts a oneof to a descriptor.\n * @returns {Message<IOneofDescriptorProto>} Descriptor\n */ OneOf.prototype.toDescriptor = function toDescriptor() {\n    return exports.OneofDescriptorProto.create({\n        name: this.name\n    });\n};\n// --- Service ---\n/**\n * Properties of a ServiceDescriptorProto message.\n * @interface IServiceDescriptorProto\n * @property {string} [name] Service name\n * @property {IMethodDescriptorProto[]} [method] Methods\n * @property {IServiceOptions} [options] Options\n */ /**\n * Properties of a ServiceOptions message.\n * @interface IServiceOptions\n * @property {boolean} [deprecated]\n */ var unnamedServiceIndex = 0;\n/**\n * Creates a service from a descriptor.\n * @param {IServiceDescriptorProto|Reader|Uint8Array} descriptor Descriptor\n * @returns {Service} Service instance\n */ Service.fromDescriptor = function fromDescriptor(descriptor) {\n    // Decode the descriptor message if specified as a buffer:\n    if (typeof descriptor.length === \"number\") descriptor = exports.ServiceDescriptorProto.decode(descriptor);\n    var service = new Service(descriptor.name && descriptor.name.length ? descriptor.name : \"Service\" + unnamedServiceIndex++, fromDescriptorOptions(descriptor.options, exports.ServiceOptions));\n    if (descriptor.method) for(var i = 0; i < descriptor.method.length; ++i)service.add(Method.fromDescriptor(descriptor.method[i]));\n    return service;\n};\n/**\n * Converts a service to a descriptor.\n * @returns {Message<IServiceDescriptorProto>} Descriptor\n */ Service.prototype.toDescriptor = function toDescriptor() {\n    // Methods\n    var methods = [];\n    for(var i = 0; i < this.methodsArray.length; ++i)methods.push(this._methodsArray[i].toDescriptor());\n    return exports.ServiceDescriptorProto.create({\n        name: this.name,\n        method: methods,\n        options: toDescriptorOptions(this.options, exports.ServiceOptions)\n    });\n};\n// --- Method ---\n/**\n * Properties of a MethodDescriptorProto message.\n * @interface IMethodDescriptorProto\n * @property {string} [name] Method name\n * @property {string} [inputType] Request type name\n * @property {string} [outputType] Response type name\n * @property {IMethodOptions} [options] Not supported\n * @property {boolean} [clientStreaming=false] Whether requests are streamed\n * @property {boolean} [serverStreaming=false] Whether responses are streamed\n */ /**\n * Properties of a MethodOptions message.\n * @interface IMethodOptions\n * @property {boolean} [deprecated]\n */ var unnamedMethodIndex = 0;\n/**\n * Creates a method from a descriptor.\n * @param {IMethodDescriptorProto|Reader|Uint8Array} descriptor Descriptor\n * @returns {Method} Reflected method instance\n */ Method.fromDescriptor = function fromDescriptor(descriptor) {\n    // Decode the descriptor message if specified as a buffer:\n    if (typeof descriptor.length === \"number\") descriptor = exports.MethodDescriptorProto.decode(descriptor);\n    return new Method(// unnamedMethodIndex is global, not per service, because we have no ref to a service here\n    descriptor.name && descriptor.name.length ? descriptor.name : \"Method\" + unnamedMethodIndex++, \"rpc\", descriptor.inputType, descriptor.outputType, Boolean(descriptor.clientStreaming), Boolean(descriptor.serverStreaming), fromDescriptorOptions(descriptor.options, exports.MethodOptions));\n};\n/**\n * Converts a method to a descriptor.\n * @returns {Message<IMethodDescriptorProto>} Descriptor\n */ Method.prototype.toDescriptor = function toDescriptor() {\n    return exports.MethodDescriptorProto.create({\n        name: this.name,\n        inputType: this.resolvedRequestType ? this.resolvedRequestType.fullName : this.requestType,\n        outputType: this.resolvedResponseType ? this.resolvedResponseType.fullName : this.responseType,\n        clientStreaming: this.requestStream,\n        serverStreaming: this.responseStream,\n        options: toDescriptorOptions(this.options, exports.MethodOptions)\n    });\n};\n// --- utility ---\n// Converts a descriptor type to a protobuf.js basic type\nfunction fromDescriptorType(type) {\n    switch(type){\n        // 0 is reserved for errors\n        case 1:\n            return \"double\";\n        case 2:\n            return \"float\";\n        case 3:\n            return \"int64\";\n        case 4:\n            return \"uint64\";\n        case 5:\n            return \"int32\";\n        case 6:\n            return \"fixed64\";\n        case 7:\n            return \"fixed32\";\n        case 8:\n            return \"bool\";\n        case 9:\n            return \"string\";\n        case 12:\n            return \"bytes\";\n        case 13:\n            return \"uint32\";\n        case 15:\n            return \"sfixed32\";\n        case 16:\n            return \"sfixed64\";\n        case 17:\n            return \"sint32\";\n        case 18:\n            return \"sint64\";\n    }\n    throw Error(\"illegal type: \" + type);\n}\n// Tests if a descriptor type is packable\nfunction packableDescriptorType(type) {\n    switch(type){\n        case 1:\n        case 2:\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 13:\n        case 14:\n        case 15:\n        case 16:\n        case 17:\n        case 18:\n            return true;\n    }\n    return false;\n}\n// Converts a protobuf.js basic type to a descriptor type\nfunction toDescriptorType(type, resolvedType) {\n    switch(type){\n        // 0 is reserved for errors\n        case \"double\":\n            return 1;\n        case \"float\":\n            return 2;\n        case \"int64\":\n            return 3;\n        case \"uint64\":\n            return 4;\n        case \"int32\":\n            return 5;\n        case \"fixed64\":\n            return 6;\n        case \"fixed32\":\n            return 7;\n        case \"bool\":\n            return 8;\n        case \"string\":\n            return 9;\n        case \"bytes\":\n            return 12;\n        case \"uint32\":\n            return 13;\n        case \"sfixed32\":\n            return 15;\n        case \"sfixed64\":\n            return 16;\n        case \"sint32\":\n            return 17;\n        case \"sint64\":\n            return 18;\n    }\n    if (resolvedType instanceof Enum) return 14;\n    if (resolvedType instanceof Type) return resolvedType.group ? 10 : 11;\n    throw Error(\"illegal type: \" + type);\n}\n// Converts descriptor options to an options object\nfunction fromDescriptorOptions(options, type) {\n    if (!options) return undefined;\n    var out = [];\n    for(var i = 0, field, key, val; i < type.fieldsArray.length; ++i)if ((key = (field = type._fieldsArray[i]).name) !== \"uninterpretedOption\") {\n        if (options.hasOwnProperty(key)) {\n            val = options[key];\n            if (field.resolvedType instanceof Enum && typeof val === \"number\" && field.resolvedType.valuesById[val] !== undefined) val = field.resolvedType.valuesById[val];\n            out.push(underScore(key), val);\n        }\n    }\n    return out.length ? $protobuf.util.toObject(out) : undefined;\n}\n// Converts an options object to descriptor options\nfunction toDescriptorOptions(options, type) {\n    if (!options) return undefined;\n    var out = [];\n    for(var i = 0, ks = Object.keys(options), key, val; i < ks.length; ++i){\n        val = options[key = ks[i]];\n        if (key === \"default\") continue;\n        var field = type.fields[key];\n        if (!field && !(field = type.fields[key = $protobuf.util.camelCase(key)])) continue;\n        out.push(key, val);\n    }\n    return out.length ? type.fromObject($protobuf.util.toObject(out)) : undefined;\n}\n// Calculates the shortest relative path from `from` to `to`.\nfunction shortname(from, to) {\n    var fromPath = from.fullName.split(\".\"), toPath = to.fullName.split(\".\"), i = 0, j = 0, k = toPath.length - 1;\n    if (!(from instanceof Root) && to instanceof Namespace) while(i < fromPath.length && j < k && fromPath[i] === toPath[j]){\n        var other = to.lookup(fromPath[i++], true);\n        if (other !== null && other !== to) break;\n        ++j;\n    }\n    else for(; i < fromPath.length && j < k && fromPath[i] === toPath[j]; ++i, ++j);\n    return toPath.slice(j).join(\".\");\n}\n// copied here from cli/targets/proto.js\nfunction underScore(str) {\n    return str.substring(0, 1) + str.substring(1).replace(/([A-Z])(?=[a-z]|$)/g, function($0, $1) {\n        return \"_\" + $1.toLowerCase();\n    });\n} // --- exports ---\n /**\n * Reflected file descriptor set.\n * @name FileDescriptorSet\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */  /**\n * Reflected file descriptor proto.\n * @name FileDescriptorProto\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */  /**\n * Reflected descriptor proto.\n * @name DescriptorProto\n * @type {Type}\n * @property {Type} ExtensionRange\n * @property {Type} ReservedRange\n * @const\n * @tstype $protobuf.Type & {\n *     ExtensionRange: $protobuf.Type,\n *     ReservedRange: $protobuf.Type\n * }\n */  /**\n * Reflected field descriptor proto.\n * @name FieldDescriptorProto\n * @type {Type}\n * @property {Enum} Label\n * @property {Enum} Type\n * @const\n * @tstype $protobuf.Type & {\n *     Label: $protobuf.Enum,\n *     Type: $protobuf.Enum\n * }\n */  /**\n * Reflected oneof descriptor proto.\n * @name OneofDescriptorProto\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */  /**\n * Reflected enum descriptor proto.\n * @name EnumDescriptorProto\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */  /**\n * Reflected service descriptor proto.\n * @name ServiceDescriptorProto\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */  /**\n * Reflected enum value descriptor proto.\n * @name EnumValueDescriptorProto\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */  /**\n * Reflected method descriptor proto.\n * @name MethodDescriptorProto\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */  /**\n * Reflected file options.\n * @name FileOptions\n * @type {Type}\n * @property {Enum} OptimizeMode\n * @const\n * @tstype $protobuf.Type & {\n *     OptimizeMode: $protobuf.Enum\n * }\n */  /**\n * Reflected message options.\n * @name MessageOptions\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */  /**\n * Reflected field options.\n * @name FieldOptions\n * @type {Type}\n * @property {Enum} CType\n * @property {Enum} JSType\n * @const\n * @tstype $protobuf.Type & {\n *     CType: $protobuf.Enum,\n *     JSType: $protobuf.Enum\n * }\n */  /**\n * Reflected oneof options.\n * @name OneofOptions\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */  /**\n * Reflected enum options.\n * @name EnumOptions\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */  /**\n * Reflected enum value options.\n * @name EnumValueOptions\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */  /**\n * Reflected service options.\n * @name ServiceOptions\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */  /**\n * Reflected method options.\n * @name MethodOptions\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */  /**\n * Reflected uninterpretet option.\n * @name UninterpretedOption\n * @type {Type}\n * @property {Type} NamePart\n * @const\n * @tstype $protobuf.Type & {\n *     NamePart: $protobuf.Type\n * }\n */  /**\n * Reflected source code info.\n * @name SourceCodeInfo\n * @type {Type}\n * @property {Type} Location\n * @const\n * @tstype $protobuf.Type & {\n *     Location: $protobuf.Type\n * }\n */  /**\n * Reflected generated code info.\n * @name GeneratedCodeInfo\n * @type {Type}\n * @property {Type} Annotation\n * @const\n * @tstype $protobuf.Type & {\n *     Annotation: $protobuf.Type\n * }\n */ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvZXh0L2Rlc2NyaXB0b3IvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxZQUFZQyxtQkFBT0EsQ0FBQyx3REFBTztBQUMvQkMsT0FBT0MsT0FBTyxHQUFHQSxVQUFVSCxVQUFVSSxVQUFVLEdBQUdKLFVBQVVLLElBQUksQ0FBQ0MsUUFBUSxDQUFDTCxtQkFBT0EsQ0FBQywrR0FBdUMsR0FBR00sTUFBTSxDQUFDO0FBRW5JLElBQUlDLFlBQVlSLFVBQVVRLFNBQVMsRUFDL0JILE9BQVlMLFVBQVVLLElBQUksRUFDMUJJLE9BQVlULFVBQVVTLElBQUksRUFDMUJDLE9BQVlWLFVBQVVVLElBQUksRUFDMUJDLFFBQVlYLFVBQVVXLEtBQUssRUFDM0JDLFdBQVlaLFVBQVVZLFFBQVEsRUFDOUJDLFFBQVliLFVBQVVhLEtBQUssRUFDM0JDLFVBQVlkLFVBQVVjLE9BQU8sRUFDN0JDLFNBQVlmLFVBQVVlLE1BQU07QUFFaEMsZUFBZTtBQUVmOzs7O0NBSUMsR0FFRDs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FpQkMsR0FFRDs7Ozs7OztDQU9DLEdBRUQ7Ozs7Q0FJQyxHQUNEVixLQUFLVyxjQUFjLEdBQUcsU0FBU0EsZUFBZVosVUFBVTtJQUVwRCwwREFBMEQ7SUFDMUQsSUFBSSxPQUFPQSxXQUFXYSxNQUFNLEtBQUssVUFDN0JiLGFBQWFELFFBQVFlLGlCQUFpQixDQUFDQyxNQUFNLENBQUNmO0lBRWxELElBQUlnQixPQUFPLElBQUlmO0lBRWYsSUFBSUQsV0FBV2lCLElBQUksRUFBRTtRQUNqQixJQUFJQyxnQkFDQUM7UUFDSixJQUFLLElBQUlDLElBQUksR0FBR0MsR0FBR0QsSUFBSXBCLFdBQVdpQixJQUFJLENBQUNKLE1BQU0sRUFBRSxFQUFFTyxFQUFHO1lBQ2hERCxjQUFjSDtZQUNkLElBQUksQ0FBQ0UsaUJBQWlCbEIsV0FBV2lCLElBQUksQ0FBQ0cs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YyxHQUFHO0lBQ25CLE9BQU9BLElBQUluSCxTQUFTLENBQUMsR0FBRSxLQUNoQm1ILElBQUluSCxTQUFTLENBQUMsR0FDVEMsT0FBTyxDQUFDLHVCQUF1QixTQUFTbUgsRUFBRSxFQUFFQyxFQUFFO1FBQUksT0FBTyxNQUFNQSxHQUFHQyxXQUFXO0lBQUk7QUFDakcsRUFFQSxrQkFBa0I7Q0FFbEI7Ozs7OztDQU1DLElBRUQ7Ozs7OztDQU1DLElBRUQ7Ozs7Ozs7Ozs7O0NBV0MsSUFFRDs7Ozs7Ozs7Ozs7Q0FXQyxJQUVEOzs7Ozs7Q0FNQyxJQUVEOzs7Ozs7Q0FNQyxJQUVEOzs7Ozs7Q0FNQyxJQUVEOzs7Ozs7Q0FNQyxJQUVEOzs7Ozs7Q0FNQyxJQUVEOzs7Ozs7Ozs7Q0FTQyxJQUVEOzs7Ozs7Q0FNQyxJQUVEOzs7Ozs7Ozs7OztDQVdDLElBRUQ7Ozs7OztDQU1DLElBRUQ7Ozs7OztDQU1DLElBRUQ7Ozs7OztDQU1DLElBRUQ7Ozs7OztDQU1DLElBRUQ7Ozs7OztDQU1DLElBRUQ7Ozs7Ozs7OztDQVNDLElBRUQ7Ozs7Ozs7OztDQVNDLElBRUQ7Ozs7Ozs7OztDQVNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL2V4dC9kZXNjcmlwdG9yL2luZGV4LmpzP2E3YTgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgJHByb3RvYnVmID0gcmVxdWlyZShcIi4uLy4uXCIpO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gJHByb3RvYnVmLmRlc2NyaXB0b3IgPSAkcHJvdG9idWYuUm9vdC5mcm9tSlNPTihyZXF1aXJlKFwiLi4vLi4vZ29vZ2xlL3Byb3RvYnVmL2Rlc2NyaXB0b3IuanNvblwiKSkubG9va3VwKFwiLmdvb2dsZS5wcm90b2J1ZlwiKTtcblxudmFyIE5hbWVzcGFjZSA9ICRwcm90b2J1Zi5OYW1lc3BhY2UsXG4gICAgUm9vdCAgICAgID0gJHByb3RvYnVmLlJvb3QsXG4gICAgRW51bSAgICAgID0gJHByb3RvYnVmLkVudW0sXG4gICAgVHlwZSAgICAgID0gJHByb3RvYnVmLlR5cGUsXG4gICAgRmllbGQgICAgID0gJHByb3RvYnVmLkZpZWxkLFxuICAgIE1hcEZpZWxkICA9ICRwcm90b2J1Zi5NYXBGaWVsZCxcbiAgICBPbmVPZiAgICAgPSAkcHJvdG9idWYuT25lT2YsXG4gICAgU2VydmljZSAgID0gJHByb3RvYnVmLlNlcnZpY2UsXG4gICAgTWV0aG9kICAgID0gJHByb3RvYnVmLk1ldGhvZDtcblxuLy8gLS0tIFJvb3QgLS0tXG5cbi8qKlxuICogUHJvcGVydGllcyBvZiBhIEZpbGVEZXNjcmlwdG9yU2V0IG1lc3NhZ2UuXG4gKiBAaW50ZXJmYWNlIElGaWxlRGVzY3JpcHRvclNldFxuICogQHByb3BlcnR5IHtJRmlsZURlc2NyaXB0b3JQcm90b1tdfSBmaWxlIEZpbGVzXG4gKi9cblxuLyoqXG4gKiBQcm9wZXJ0aWVzIG9mIGEgRmlsZURlc2NyaXB0b3JQcm90byBtZXNzYWdlLlxuICogQGludGVyZmFjZSBJRmlsZURlc2NyaXB0b3JQcm90b1xuICogQHByb3BlcnR5IHtzdHJpbmd9IFtuYW1lXSBGaWxlIG5hbWVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbcGFja2FnZV0gUGFja2FnZVxuICogQHByb3BlcnR5IHsqfSBbZGVwZW5kZW5jeV0gTm90IHN1cHBvcnRlZFxuICogQHByb3BlcnR5IHsqfSBbcHVibGljRGVwZW5kZW5jeV0gTm90IHN1cHBvcnRlZFxuICogQHByb3BlcnR5IHsqfSBbd2Vha0RlcGVuZGVuY3ldIE5vdCBzdXBwb3J0ZWRcbiAqIEBwcm9wZXJ0eSB7SURlc2NyaXB0b3JQcm90b1tdfSBbbWVzc2FnZVR5cGVdIE5lc3RlZCBtZXNzYWdlIHR5cGVzXG4gKiBAcHJvcGVydHkge0lFbnVtRGVzY3JpcHRvclByb3RvW119IFtlbnVtVHlwZV0gTmVzdGVkIGVudW1zXG4gKiBAcHJvcGVydHkge0lTZXJ2aWNlRGVzY3JpcHRvclByb3RvW119IFtzZXJ2aWNlXSBOZXN0ZWQgc2VydmljZXNcbiAqIEBwcm9wZXJ0eSB7SUZpZWxkRGVzY3JpcHRvclByb3RvW119IFtleHRlbnNpb25dIE5lc3RlZCBleHRlbnNpb24gZmllbGRzXG4gKiBAcHJvcGVydHkge0lGaWxlT3B0aW9uc30gW29wdGlvbnNdIE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7Kn0gW3NvdXJjZUNvZGVJbmZvXSBOb3Qgc3VwcG9ydGVkXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3N5bnRheD1cInByb3RvMlwiXSBTeW50YXhcbiAqL1xuXG4vKipcbiAqIFByb3BlcnRpZXMgb2YgYSBGaWxlT3B0aW9ucyBtZXNzYWdlLlxuICogQGludGVyZmFjZSBJRmlsZU9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbamF2YVBhY2thZ2VdXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2phdmFPdXRlckNsYXNzbmFtZV1cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2phdmFNdWx0aXBsZUZpbGVzXVxuICogQHByb3BlcnR5IHtib29sZWFufSBbamF2YUdlbmVyYXRlRXF1YWxzQW5kSGFzaF1cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2phdmFTdHJpbmdDaGVja1V0ZjhdXG4gKiBAcHJvcGVydHkge0lGaWxlT3B0aW9uc09wdGltaXplTW9kZX0gW29wdGltaXplRm9yPTFdXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2dvUGFja2FnZV1cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2NjR2VuZXJpY1NlcnZpY2VzXVxuICogQHByb3BlcnR5IHtib29sZWFufSBbamF2YUdlbmVyaWNTZXJ2aWNlc11cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3B5R2VuZXJpY1NlcnZpY2VzXVxuICogQHByb3BlcnR5IHtib29sZWFufSBbZGVwcmVjYXRlZF1cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2NjRW5hYmxlQXJlbmFzXVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtvYmpjQ2xhc3NQcmVmaXhdXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2NzaGFycE5hbWVzcGFjZV1cbiAqL1xuXG4vKipcbiAqIFZhbHVlcyBvZiBoZSBGaWxlT3B0aW9ucy5PcHRpbWl6ZU1vZGUgZW51bS5cbiAqIEB0eXBlZGVmIElGaWxlT3B0aW9uc09wdGltaXplTW9kZVxuICogQHR5cGUge251bWJlcn1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBTUEVFRD0xXG4gKiBAcHJvcGVydHkge251bWJlcn0gQ09ERV9TSVpFPTJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBMSVRFX1JVTlRJTUU9M1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIHJvb3QgZnJvbSBhIGRlc2NyaXB0b3Igc2V0LlxuICogQHBhcmFtIHtJRmlsZURlc2NyaXB0b3JTZXR8UmVhZGVyfFVpbnQ4QXJyYXl9IGRlc2NyaXB0b3IgRGVzY3JpcHRvclxuICogQHJldHVybnMge1Jvb3R9IFJvb3QgaW5zdGFuY2VcbiAqL1xuUm9vdC5mcm9tRGVzY3JpcHRvciA9IGZ1bmN0aW9uIGZyb21EZXNjcmlwdG9yKGRlc2NyaXB0b3IpIHtcblxuICAgIC8vIERlY29kZSB0aGUgZGVzY3JpcHRvciBtZXNzYWdlIGlmIHNwZWNpZmllZCBhcyBhIGJ1ZmZlcjpcbiAgICBpZiAodHlwZW9mIGRlc2NyaXB0b3IubGVuZ3RoID09PSBcIm51bWJlclwiKVxuICAgICAgICBkZXNjcmlwdG9yID0gZXhwb3J0cy5GaWxlRGVzY3JpcHRvclNldC5kZWNvZGUoZGVzY3JpcHRvcik7XG5cbiAgICB2YXIgcm9vdCA9IG5ldyBSb290KCk7XG5cbiAgICBpZiAoZGVzY3JpcHRvci5maWxlKSB7XG4gICAgICAgIHZhciBmaWxlRGVzY3JpcHRvcixcbiAgICAgICAgICAgIGZpbGVQYWNrYWdlO1xuICAgICAgICBmb3IgKHZhciBqID0gMCwgaTsgaiA8IGRlc2NyaXB0b3IuZmlsZS5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgZmlsZVBhY2thZ2UgPSByb290O1xuICAgICAgICAgICAgaWYgKChmaWxlRGVzY3JpcHRvciA9IGRlc2NyaXB0b3IuZmlsZVtqXSlbXCJwYWNrYWdlXCJdICYmIGZpbGVEZXNjcmlwdG9yW1wicGFja2FnZVwiXS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgZmlsZVBhY2thZ2UgPSByb290LmRlZmluZShmaWxlRGVzY3JpcHRvcltcInBhY2thZ2VcIl0pO1xuICAgICAgICAgICAgaWYgKGZpbGVEZXNjcmlwdG9yLm5hbWUgJiYgZmlsZURlc2NyaXB0b3IubmFtZS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcm9vdC5maWxlcy5wdXNoKGZpbGVQYWNrYWdlLmZpbGVuYW1lID0gZmlsZURlc2NyaXB0b3IubmFtZSk7XG4gICAgICAgICAgICBpZiAoZmlsZURlc2NyaXB0b3IubWVzc2FnZVR5cGUpXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGZpbGVEZXNjcmlwdG9yLm1lc3NhZ2VUeXBlLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBmaWxlUGFja2FnZS5hZGQoVHlwZS5mcm9tRGVzY3JpcHRvcihmaWxlRGVzY3JpcHRvci5tZXNzYWdlVHlwZVtpXSwgZmlsZURlc2NyaXB0b3Iuc3ludGF4KSk7XG4gICAgICAgICAgICBpZiAoZmlsZURlc2NyaXB0b3IuZW51bVR5cGUpXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGZpbGVEZXNjcmlwdG9yLmVudW1UeXBlLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBmaWxlUGFja2FnZS5hZGQoRW51bS5mcm9tRGVzY3JpcHRvcihmaWxlRGVzY3JpcHRvci5lbnVtVHlwZVtpXSkpO1xuICAgICAgICAgICAgaWYgKGZpbGVEZXNjcmlwdG9yLmV4dGVuc2lvbilcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZmlsZURlc2NyaXB0b3IuZXh0ZW5zaW9uLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBmaWxlUGFja2FnZS5hZGQoRmllbGQuZnJvbURlc2NyaXB0b3IoZmlsZURlc2NyaXB0b3IuZXh0ZW5zaW9uW2ldKSk7XG4gICAgICAgICAgICBpZiAoZmlsZURlc2NyaXB0b3Iuc2VydmljZSlcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZmlsZURlc2NyaXB0b3Iuc2VydmljZS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgZmlsZVBhY2thZ2UuYWRkKFNlcnZpY2UuZnJvbURlc2NyaXB0b3IoZmlsZURlc2NyaXB0b3Iuc2VydmljZVtpXSkpO1xuICAgICAgICAgICAgdmFyIG9wdHMgPSBmcm9tRGVzY3JpcHRvck9wdGlvbnMoZmlsZURlc2NyaXB0b3Iub3B0aW9ucywgZXhwb3J0cy5GaWxlT3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAob3B0cykge1xuICAgICAgICAgICAgICAgIHZhciBrcyA9IE9iamVjdC5rZXlzKG9wdHMpO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBrcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgZmlsZVBhY2thZ2Uuc2V0T3B0aW9uKGtzW2ldLCBvcHRzW2tzW2ldXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcm9vdDtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSByb290IHRvIGEgZGVzY3JpcHRvciBzZXQuXG4gKiBAcmV0dXJucyB7TWVzc2FnZTxJRmlsZURlc2NyaXB0b3JTZXQ+fSBEZXNjcmlwdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N5bnRheD1cInByb3RvMlwiXSBTeW50YXhcbiAqL1xuUm9vdC5wcm90b3R5cGUudG9EZXNjcmlwdG9yID0gZnVuY3Rpb24gdG9EZXNjcmlwdG9yKHN5bnRheCkge1xuICAgIHZhciBzZXQgPSBleHBvcnRzLkZpbGVEZXNjcmlwdG9yU2V0LmNyZWF0ZSgpO1xuICAgIFJvb3RfdG9EZXNjcmlwdG9yUmVjdXJzaXZlKHRoaXMsIHNldC5maWxlLCBzeW50YXgpO1xuICAgIHJldHVybiBzZXQ7XG59O1xuXG4vLyBUcmF2ZXJzZXMgYSBuYW1lc3BhY2UgYW5kIGFzc2VtYmxlcyB0aGUgZGVzY3JpcHRvciBzZXRcbmZ1bmN0aW9uIFJvb3RfdG9EZXNjcmlwdG9yUmVjdXJzaXZlKG5zLCBmaWxlcywgc3ludGF4KSB7XG5cbiAgICAvLyBDcmVhdGUgYSBuZXcgZmlsZVxuICAgIHZhciBmaWxlID0gZXhwb3J0cy5GaWxlRGVzY3JpcHRvclByb3RvLmNyZWF0ZSh7IG5hbWU6IG5zLmZpbGVuYW1lIHx8IChucy5mdWxsTmFtZS5zdWJzdHJpbmcoMSkucmVwbGFjZSgvXFwuL2csIFwiX1wiKSB8fCBcInJvb3RcIikgKyBcIi5wcm90b1wiIH0pO1xuICAgIGlmIChzeW50YXgpXG4gICAgICAgIGZpbGUuc3ludGF4ID0gc3ludGF4O1xuICAgIGlmICghKG5zIGluc3RhbmNlb2YgUm9vdCkpXG4gICAgICAgIGZpbGVbXCJwYWNrYWdlXCJdID0gbnMuZnVsbE5hbWUuc3Vic3RyaW5nKDEpO1xuXG4gICAgLy8gQWRkIG5lc3RlZCB0eXBlc1xuICAgIGZvciAodmFyIGkgPSAwLCBuZXN0ZWQ7IGkgPCBucy5uZXN0ZWRBcnJheS5sZW5ndGg7ICsraSlcbiAgICAgICAgaWYgKChuZXN0ZWQgPSBucy5fbmVzdGVkQXJyYXlbaV0pIGluc3RhbmNlb2YgVHlwZSlcbiAgICAgICAgICAgIGZpbGUubWVzc2FnZVR5cGUucHVzaChuZXN0ZWQudG9EZXNjcmlwdG9yKHN5bnRheCkpO1xuICAgICAgICBlbHNlIGlmIChuZXN0ZWQgaW5zdGFuY2VvZiBFbnVtKVxuICAgICAgICAgICAgZmlsZS5lbnVtVHlwZS5wdXNoKG5lc3RlZC50b0Rlc2NyaXB0b3IoKSk7XG4gICAgICAgIGVsc2UgaWYgKG5lc3RlZCBpbnN0YW5jZW9mIEZpZWxkKVxuICAgICAgICAgICAgZmlsZS5leHRlbnNpb24ucHVzaChuZXN0ZWQudG9EZXNjcmlwdG9yKHN5bnRheCkpO1xuICAgICAgICBlbHNlIGlmIChuZXN0ZWQgaW5zdGFuY2VvZiBTZXJ2aWNlKVxuICAgICAgICAgICAgZmlsZS5zZXJ2aWNlLnB1c2gobmVzdGVkLnRvRGVzY3JpcHRvcigpKTtcbiAgICAgICAgZWxzZSBpZiAobmVzdGVkIGluc3RhbmNlb2YgLyogcGxhaW4gKi8gTmFtZXNwYWNlKVxuICAgICAgICAgICAgUm9vdF90b0Rlc2NyaXB0b3JSZWN1cnNpdmUobmVzdGVkLCBmaWxlcywgc3ludGF4KTsgLy8gcmVxdWlyZXMgbmV3IGZpbGVcblxuICAgIC8vIEtlZXAgcGFja2FnZS1sZXZlbCBvcHRpb25zXG4gICAgZmlsZS5vcHRpb25zID0gdG9EZXNjcmlwdG9yT3B0aW9ucyhucy5vcHRpb25zLCBleHBvcnRzLkZpbGVPcHRpb25zKTtcblxuICAgIC8vIEFuZCBrZWVwIHRoZSBmaWxlIG9ubHkgaWYgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIG5lc3RlZCBvYmplY3RcbiAgICBpZiAoZmlsZS5tZXNzYWdlVHlwZS5sZW5ndGggKyBmaWxlLmVudW1UeXBlLmxlbmd0aCArIGZpbGUuZXh0ZW5zaW9uLmxlbmd0aCArIGZpbGUuc2VydmljZS5sZW5ndGgpXG4gICAgICAgIGZpbGVzLnB1c2goZmlsZSk7XG59XG5cbi8vIC0tLSBUeXBlIC0tLVxuXG4vKipcbiAqIFByb3BlcnRpZXMgb2YgYSBEZXNjcmlwdG9yUHJvdG8gbWVzc2FnZS5cbiAqIEBpbnRlcmZhY2UgSURlc2NyaXB0b3JQcm90b1xuICogQHByb3BlcnR5IHtzdHJpbmd9IFtuYW1lXSBNZXNzYWdlIHR5cGUgbmFtZVxuICogQHByb3BlcnR5IHtJRmllbGREZXNjcmlwdG9yUHJvdG9bXX0gW2ZpZWxkXSBGaWVsZHNcbiAqIEBwcm9wZXJ0eSB7SUZpZWxkRGVzY3JpcHRvclByb3RvW119IFtleHRlbnNpb25dIEV4dGVuc2lvbiBmaWVsZHNcbiAqIEBwcm9wZXJ0eSB7SURlc2NyaXB0b3JQcm90b1tdfSBbbmVzdGVkVHlwZV0gTmVzdGVkIG1lc3NhZ2UgdHlwZXNcbiAqIEBwcm9wZXJ0eSB7SUVudW1EZXNjcmlwdG9yUHJvdG9bXX0gW2VudW1UeXBlXSBOZXN0ZWQgZW51bXNcbiAqIEBwcm9wZXJ0eSB7SURlc2NyaXB0b3JQcm90b0V4dGVuc2lvblJhbmdlW119IFtleHRlbnNpb25SYW5nZV0gRXh0ZW5zaW9uIHJhbmdlc1xuICogQHByb3BlcnR5IHtJT25lb2ZEZXNjcmlwdG9yUHJvdG9bXX0gW29uZW9mRGVjbF0gT25lb2ZzXG4gKiBAcHJvcGVydHkge0lNZXNzYWdlT3B0aW9uc30gW29wdGlvbnNdIE5vdCBzdXBwb3J0ZWRcbiAqIEBwcm9wZXJ0eSB7SURlc2NyaXB0b3JQcm90b1Jlc2VydmVkUmFuZ2VbXX0gW3Jlc2VydmVkUmFuZ2VdIFJlc2VydmVkIHJhbmdlc1xuICogQHByb3BlcnR5IHtzdHJpbmdbXX0gW3Jlc2VydmVkTmFtZV0gUmVzZXJ2ZWQgbmFtZXNcbiAqL1xuXG4vKipcbiAqIFByb3BlcnRpZXMgb2YgYSBNZXNzYWdlT3B0aW9ucyBtZXNzYWdlLlxuICogQGludGVyZmFjZSBJTWVzc2FnZU9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW21hcEVudHJ5PWZhbHNlXSBXaGV0aGVyIHRoaXMgbWVzc2FnZSBpcyBhIG1hcCBlbnRyeVxuICovXG5cbi8qKlxuICogUHJvcGVydGllcyBvZiBhbiBFeHRlbnNpb25SYW5nZSBtZXNzYWdlLlxuICogQGludGVyZmFjZSBJRGVzY3JpcHRvclByb3RvRXh0ZW5zaW9uUmFuZ2VcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbc3RhcnRdIFN0YXJ0IGZpZWxkIGlkXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2VuZF0gRW5kIGZpZWxkIGlkXG4gKi9cblxuLyoqXG4gKiBQcm9wZXJ0aWVzIG9mIGEgUmVzZXJ2ZWRSYW5nZSBtZXNzYWdlLlxuICogQGludGVyZmFjZSBJRGVzY3JpcHRvclByb3RvUmVzZXJ2ZWRSYW5nZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtzdGFydF0gU3RhcnQgZmllbGQgaWRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZW5kXSBFbmQgZmllbGQgaWRcbiAqL1xuXG52YXIgdW5uYW1lZE1lc3NhZ2VJbmRleCA9IDA7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHR5cGUgZnJvbSBhIGRlc2NyaXB0b3IuXG4gKiBAcGFyYW0ge0lEZXNjcmlwdG9yUHJvdG98UmVhZGVyfFVpbnQ4QXJyYXl9IGRlc2NyaXB0b3IgRGVzY3JpcHRvclxuICogQHBhcmFtIHtzdHJpbmd9IFtzeW50YXg9XCJwcm90bzJcIl0gU3ludGF4XG4gKiBAcmV0dXJucyB7VHlwZX0gVHlwZSBpbnN0YW5jZVxuICovXG5UeXBlLmZyb21EZXNjcmlwdG9yID0gZnVuY3Rpb24gZnJvbURlc2NyaXB0b3IoZGVzY3JpcHRvciwgc3ludGF4KSB7XG5cbiAgICAvLyBEZWNvZGUgdGhlIGRlc2NyaXB0b3IgbWVzc2FnZSBpZiBzcGVjaWZpZWQgYXMgYSBidWZmZXI6XG4gICAgaWYgKHR5cGVvZiBkZXNjcmlwdG9yLmxlbmd0aCA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgZGVzY3JpcHRvciA9IGV4cG9ydHMuRGVzY3JpcHRvclByb3RvLmRlY29kZShkZXNjcmlwdG9yKTtcblxuICAgIC8vIENyZWF0ZSB0aGUgbWVzc2FnZSB0eXBlXG4gICAgdmFyIHR5cGUgPSBuZXcgVHlwZShkZXNjcmlwdG9yLm5hbWUubGVuZ3RoID8gZGVzY3JpcHRvci5uYW1lIDogXCJUeXBlXCIgKyB1bm5hbWVkTWVzc2FnZUluZGV4KyssIGZyb21EZXNjcmlwdG9yT3B0aW9ucyhkZXNjcmlwdG9yLm9wdGlvbnMsIGV4cG9ydHMuTWVzc2FnZU9wdGlvbnMpKSxcbiAgICAgICAgaTtcblxuICAgIC8qIE9uZW9mcyAqLyBpZiAoZGVzY3JpcHRvci5vbmVvZkRlY2wpXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBkZXNjcmlwdG9yLm9uZW9mRGVjbC5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIHR5cGUuYWRkKE9uZU9mLmZyb21EZXNjcmlwdG9yKGRlc2NyaXB0b3Iub25lb2ZEZWNsW2ldKSk7XG4gICAgLyogRmllbGRzICovIGlmIChkZXNjcmlwdG9yLmZpZWxkKVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZGVzY3JpcHRvci5maWVsZC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGZpZWxkID0gRmllbGQuZnJvbURlc2NyaXB0b3IoZGVzY3JpcHRvci5maWVsZFtpXSwgc3ludGF4KTtcbiAgICAgICAgICAgIHR5cGUuYWRkKGZpZWxkKTtcbiAgICAgICAgICAgIGlmIChkZXNjcmlwdG9yLmZpZWxkW2ldLmhhc093blByb3BlcnR5KFwib25lb2ZJbmRleFwiKSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgICAgICAgICAgICAgICB0eXBlLm9uZW9mc0FycmF5W2Rlc2NyaXB0b3IuZmllbGRbaV0ub25lb2ZJbmRleF0uYWRkKGZpZWxkKTtcbiAgICAgICAgfVxuICAgIC8qIEV4dGVuc2lvbiBmaWVsZHMgKi8gaWYgKGRlc2NyaXB0b3IuZXh0ZW5zaW9uKVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZGVzY3JpcHRvci5leHRlbnNpb24ubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICB0eXBlLmFkZChGaWVsZC5mcm9tRGVzY3JpcHRvcihkZXNjcmlwdG9yLmV4dGVuc2lvbltpXSwgc3ludGF4KSk7XG4gICAgLyogTmVzdGVkIHR5cGVzICovIGlmIChkZXNjcmlwdG9yLm5lc3RlZFR5cGUpXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBkZXNjcmlwdG9yLm5lc3RlZFR5cGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHR5cGUuYWRkKFR5cGUuZnJvbURlc2NyaXB0b3IoZGVzY3JpcHRvci5uZXN0ZWRUeXBlW2ldLCBzeW50YXgpKTtcbiAgICAgICAgICAgIGlmIChkZXNjcmlwdG9yLm5lc3RlZFR5cGVbaV0ub3B0aW9ucyAmJiBkZXNjcmlwdG9yLm5lc3RlZFR5cGVbaV0ub3B0aW9ucy5tYXBFbnRyeSlcbiAgICAgICAgICAgICAgICB0eXBlLnNldE9wdGlvbihcIm1hcF9lbnRyeVwiLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIC8qIE5lc3RlZCBlbnVtcyAqLyBpZiAoZGVzY3JpcHRvci5lbnVtVHlwZSlcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGRlc2NyaXB0b3IuZW51bVR5cGUubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICB0eXBlLmFkZChFbnVtLmZyb21EZXNjcmlwdG9yKGRlc2NyaXB0b3IuZW51bVR5cGVbaV0pKTtcbiAgICAvKiBFeHRlbnNpb24gcmFuZ2VzICovIGlmIChkZXNjcmlwdG9yLmV4dGVuc2lvblJhbmdlICYmIGRlc2NyaXB0b3IuZXh0ZW5zaW9uUmFuZ2UubGVuZ3RoKSB7XG4gICAgICAgIHR5cGUuZXh0ZW5zaW9ucyA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZGVzY3JpcHRvci5leHRlbnNpb25SYW5nZS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIHR5cGUuZXh0ZW5zaW9ucy5wdXNoKFsgZGVzY3JpcHRvci5leHRlbnNpb25SYW5nZVtpXS5zdGFydCwgZGVzY3JpcHRvci5leHRlbnNpb25SYW5nZVtpXS5lbmQgXSk7XG4gICAgfVxuICAgIC8qIFJlc2VydmVkLi4uICovIGlmIChkZXNjcmlwdG9yLnJlc2VydmVkUmFuZ2UgJiYgZGVzY3JpcHRvci5yZXNlcnZlZFJhbmdlLmxlbmd0aCB8fCBkZXNjcmlwdG9yLnJlc2VydmVkTmFtZSAmJiBkZXNjcmlwdG9yLnJlc2VydmVkTmFtZS5sZW5ndGgpIHtcbiAgICAgICAgdHlwZS5yZXNlcnZlZCA9IFtdO1xuICAgICAgICAvKiBSYW5nZXMgKi8gaWYgKGRlc2NyaXB0b3IucmVzZXJ2ZWRSYW5nZSlcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBkZXNjcmlwdG9yLnJlc2VydmVkUmFuZ2UubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgdHlwZS5yZXNlcnZlZC5wdXNoKFsgZGVzY3JpcHRvci5yZXNlcnZlZFJhbmdlW2ldLnN0YXJ0LCBkZXNjcmlwdG9yLnJlc2VydmVkUmFuZ2VbaV0uZW5kIF0pO1xuICAgICAgICAvKiBOYW1lcyAqLyBpZiAoZGVzY3JpcHRvci5yZXNlcnZlZE5hbWUpXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZGVzY3JpcHRvci5yZXNlcnZlZE5hbWUubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgdHlwZS5yZXNlcnZlZC5wdXNoKGRlc2NyaXB0b3IucmVzZXJ2ZWROYW1lW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHlwZTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSB0eXBlIHRvIGEgZGVzY3JpcHRvci5cbiAqIEByZXR1cm5zIHtNZXNzYWdlPElEZXNjcmlwdG9yUHJvdG8+fSBEZXNjcmlwdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N5bnRheD1cInByb3RvMlwiXSBTeW50YXhcbiAqL1xuVHlwZS5wcm90b3R5cGUudG9EZXNjcmlwdG9yID0gZnVuY3Rpb24gdG9EZXNjcmlwdG9yKHN5bnRheCkge1xuICAgIHZhciBkZXNjcmlwdG9yID0gZXhwb3J0cy5EZXNjcmlwdG9yUHJvdG8uY3JlYXRlKHsgbmFtZTogdGhpcy5uYW1lIH0pLFxuICAgICAgICBpO1xuXG4gICAgLyogRmllbGRzICovIGZvciAoaSA9IDA7IGkgPCB0aGlzLmZpZWxkc0FycmF5Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBmaWVsZERlc2NyaXB0b3I7XG4gICAgICAgIGRlc2NyaXB0b3IuZmllbGQucHVzaChmaWVsZERlc2NyaXB0b3IgPSB0aGlzLl9maWVsZHNBcnJheVtpXS50b0Rlc2NyaXB0b3Ioc3ludGF4KSk7XG4gICAgICAgIGlmICh0aGlzLl9maWVsZHNBcnJheVtpXSBpbnN0YW5jZW9mIE1hcEZpZWxkKSB7IC8vIG1hcCBmaWVsZHMgYXJlIHJlcGVhdGVkIEZpZWxkTmFtZUVudHJ5XG4gICAgICAgICAgICB2YXIga2V5VHlwZSA9IHRvRGVzY3JpcHRvclR5cGUodGhpcy5fZmllbGRzQXJyYXlbaV0ua2V5VHlwZSwgdGhpcy5fZmllbGRzQXJyYXlbaV0ucmVzb2x2ZWRLZXlUeXBlKSxcbiAgICAgICAgICAgICAgICB2YWx1ZVR5cGUgPSB0b0Rlc2NyaXB0b3JUeXBlKHRoaXMuX2ZpZWxkc0FycmF5W2ldLnR5cGUsIHRoaXMuX2ZpZWxkc0FycmF5W2ldLnJlc29sdmVkVHlwZSksXG4gICAgICAgICAgICAgICAgdmFsdWVUeXBlTmFtZSA9IHZhbHVlVHlwZSA9PT0gLyogdHlwZSAqLyAxMSB8fCB2YWx1ZVR5cGUgPT09IC8qIGVudW0gKi8gMTRcbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLl9maWVsZHNBcnJheVtpXS5yZXNvbHZlZFR5cGUgJiYgc2hvcnRuYW1lKHRoaXMucGFyZW50LCB0aGlzLl9maWVsZHNBcnJheVtpXS5yZXNvbHZlZFR5cGUpIHx8IHRoaXMuX2ZpZWxkc0FycmF5W2ldLnR5cGVcbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBkZXNjcmlwdG9yLm5lc3RlZFR5cGUucHVzaChleHBvcnRzLkRlc2NyaXB0b3JQcm90by5jcmVhdGUoe1xuICAgICAgICAgICAgICAgIG5hbWU6IGZpZWxkRGVzY3JpcHRvci50eXBlTmFtZSxcbiAgICAgICAgICAgICAgICBmaWVsZDogW1xuICAgICAgICAgICAgICAgICAgICBleHBvcnRzLkZpZWxkRGVzY3JpcHRvclByb3RvLmNyZWF0ZSh7IG5hbWU6IFwia2V5XCIsIG51bWJlcjogMSwgbGFiZWw6IDEsIHR5cGU6IGtleVR5cGUgfSksIC8vIGNhbid0IHJlZmVyZW5jZSBhIHR5cGUgb3IgZW51bVxuICAgICAgICAgICAgICAgICAgICBleHBvcnRzLkZpZWxkRGVzY3JpcHRvclByb3RvLmNyZWF0ZSh7IG5hbWU6IFwidmFsdWVcIiwgbnVtYmVyOiAyLCBsYWJlbDogMSwgdHlwZTogdmFsdWVUeXBlLCB0eXBlTmFtZTogdmFsdWVUeXBlTmFtZSB9KVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgb3B0aW9uczogZXhwb3J0cy5NZXNzYWdlT3B0aW9ucy5jcmVhdGUoeyBtYXBFbnRyeTogdHJ1ZSB9KVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qIE9uZW9mcyAqLyBmb3IgKGkgPSAwOyBpIDwgdGhpcy5vbmVvZnNBcnJheS5sZW5ndGg7ICsraSlcbiAgICAgICAgZGVzY3JpcHRvci5vbmVvZkRlY2wucHVzaCh0aGlzLl9vbmVvZnNBcnJheVtpXS50b0Rlc2NyaXB0b3IoKSk7XG4gICAgLyogTmVzdGVkLi4uICovIGZvciAoaSA9IDA7IGkgPCB0aGlzLm5lc3RlZEFycmF5Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIC8qIEV4dGVuc2lvbiBmaWVsZHMgKi8gaWYgKHRoaXMuX25lc3RlZEFycmF5W2ldIGluc3RhbmNlb2YgRmllbGQpXG4gICAgICAgICAgICBkZXNjcmlwdG9yLmZpZWxkLnB1c2godGhpcy5fbmVzdGVkQXJyYXlbaV0udG9EZXNjcmlwdG9yKHN5bnRheCkpO1xuICAgICAgICAvKiBUeXBlcyAqLyBlbHNlIGlmICh0aGlzLl9uZXN0ZWRBcnJheVtpXSBpbnN0YW5jZW9mIFR5cGUpXG4gICAgICAgICAgICBkZXNjcmlwdG9yLm5lc3RlZFR5cGUucHVzaCh0aGlzLl9uZXN0ZWRBcnJheVtpXS50b0Rlc2NyaXB0b3Ioc3ludGF4KSk7XG4gICAgICAgIC8qIEVudW1zICovIGVsc2UgaWYgKHRoaXMuX25lc3RlZEFycmF5W2ldIGluc3RhbmNlb2YgRW51bSlcbiAgICAgICAgICAgIGRlc2NyaXB0b3IuZW51bVR5cGUucHVzaCh0aGlzLl9uZXN0ZWRBcnJheVtpXS50b0Rlc2NyaXB0b3IoKSk7XG4gICAgICAgIC8vIHBsYWluIG5lc3RlZCBuYW1lc3BhY2VzIGJlY29tZSBwYWNrYWdlcyBpbnN0ZWFkIGluIFJvb3QjdG9EZXNjcmlwdG9yXG4gICAgfVxuICAgIC8qIEV4dGVuc2lvbiByYW5nZXMgKi8gaWYgKHRoaXMuZXh0ZW5zaW9ucylcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuZXh0ZW5zaW9ucy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIGRlc2NyaXB0b3IuZXh0ZW5zaW9uUmFuZ2UucHVzaChleHBvcnRzLkRlc2NyaXB0b3JQcm90by5FeHRlbnNpb25SYW5nZS5jcmVhdGUoeyBzdGFydDogdGhpcy5leHRlbnNpb25zW2ldWzBdLCBlbmQ6IHRoaXMuZXh0ZW5zaW9uc1tpXVsxXSB9KSk7XG4gICAgLyogUmVzZXJ2ZWQuLi4gKi8gaWYgKHRoaXMucmVzZXJ2ZWQpXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnJlc2VydmVkLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgLyogTmFtZXMgKi8gaWYgKHR5cGVvZiB0aGlzLnJlc2VydmVkW2ldID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgIGRlc2NyaXB0b3IucmVzZXJ2ZWROYW1lLnB1c2godGhpcy5yZXNlcnZlZFtpXSk7XG4gICAgICAgICAgICAvKiBSYW5nZXMgKi8gZWxzZVxuICAgICAgICAgICAgICAgIGRlc2NyaXB0b3IucmVzZXJ2ZWRSYW5nZS5wdXNoKGV4cG9ydHMuRGVzY3JpcHRvclByb3RvLlJlc2VydmVkUmFuZ2UuY3JlYXRlKHsgc3RhcnQ6IHRoaXMucmVzZXJ2ZWRbaV1bMF0sIGVuZDogdGhpcy5yZXNlcnZlZFtpXVsxXSB9KSk7XG5cbiAgICBkZXNjcmlwdG9yLm9wdGlvbnMgPSB0b0Rlc2NyaXB0b3JPcHRpb25zKHRoaXMub3B0aW9ucywgZXhwb3J0cy5NZXNzYWdlT3B0aW9ucyk7XG5cbiAgICByZXR1cm4gZGVzY3JpcHRvcjtcbn07XG5cbi8vIC0tLSBGaWVsZCAtLS1cblxuLyoqXG4gKiBQcm9wZXJ0aWVzIG9mIGEgRmllbGREZXNjcmlwdG9yUHJvdG8gbWVzc2FnZS5cbiAqIEBpbnRlcmZhY2UgSUZpZWxkRGVzY3JpcHRvclByb3RvXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW25hbWVdIEZpZWxkIG5hbWVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbnVtYmVyXSBGaWVsZCBpZFxuICogQHByb3BlcnR5IHtJRmllbGREZXNjcmlwdG9yUHJvdG9MYWJlbH0gW2xhYmVsXSBGaWVsZCBydWxlXG4gKiBAcHJvcGVydHkge0lGaWVsZERlc2NyaXB0b3JQcm90b1R5cGV9IFt0eXBlXSBGaWVsZCBiYXNpYyB0eXBlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3R5cGVOYW1lXSBGaWVsZCB0eXBlIG5hbWVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZXh0ZW5kZWVdIEV4dGVuZGVkIHR5cGUgbmFtZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtkZWZhdWx0VmFsdWVdIExpdGVyYWwgZGVmYXVsdCB2YWx1ZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtvbmVvZkluZGV4XSBPbmVvZiBpbmRleCBpZiBwYXJ0IG9mIGEgb25lb2ZcbiAqIEBwcm9wZXJ0eSB7Kn0gW2pzb25OYW1lXSBOb3Qgc3VwcG9ydGVkXG4gKiBAcHJvcGVydHkge0lGaWVsZE9wdGlvbnN9IFtvcHRpb25zXSBGaWVsZCBvcHRpb25zXG4gKi9cblxuLyoqXG4gKiBWYWx1ZXMgb2YgdGhlIEZpZWxkRGVzY3JpcHRvclByb3RvLkxhYmVsIGVudW0uXG4gKiBAdHlwZWRlZiBJRmllbGREZXNjcmlwdG9yUHJvdG9MYWJlbFxuICogQHR5cGUge251bWJlcn1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBMQUJFTF9PUFRJT05BTD0xXG4gKiBAcHJvcGVydHkge251bWJlcn0gTEFCRUxfUkVRVUlSRUQ9MlxuICogQHByb3BlcnR5IHtudW1iZXJ9IExBQkVMX1JFUEVBVEVEPTNcbiAqL1xuXG4vKipcbiAqIFZhbHVlcyBvZiB0aGUgRmllbGREZXNjcmlwdG9yUHJvdG8uVHlwZSBlbnVtLlxuICogQHR5cGVkZWYgSUZpZWxkRGVzY3JpcHRvclByb3RvVHlwZVxuICogQHR5cGUge251bWJlcn1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBUWVBFX0RPVUJMRT0xXG4gKiBAcHJvcGVydHkge251bWJlcn0gVFlQRV9GTE9BVD0yXG4gKiBAcHJvcGVydHkge251bWJlcn0gVFlQRV9JTlQ2ND0zXG4gKiBAcHJvcGVydHkge251bWJlcn0gVFlQRV9VSU5UNjQ9NFxuICogQHByb3BlcnR5IHtudW1iZXJ9IFRZUEVfSU5UMzI9NVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFRZUEVfRklYRUQ2ND02XG4gKiBAcHJvcGVydHkge251bWJlcn0gVFlQRV9GSVhFRDMyPTdcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBUWVBFX0JPT0w9OFxuICogQHByb3BlcnR5IHtudW1iZXJ9IFRZUEVfU1RSSU5HPTlcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBUWVBFX0dST1VQPTEwXG4gKiBAcHJvcGVydHkge251bWJlcn0gVFlQRV9NRVNTQUdFPTExXG4gKiBAcHJvcGVydHkge251bWJlcn0gVFlQRV9CWVRFUz0xMlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFRZUEVfVUlOVDMyPTEzXG4gKiBAcHJvcGVydHkge251bWJlcn0gVFlQRV9FTlVNPTE0XG4gKiBAcHJvcGVydHkge251bWJlcn0gVFlQRV9TRklYRUQzMj0xNVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFRZUEVfU0ZJWEVENjQ9MTZcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBUWVBFX1NJTlQzMj0xN1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFRZUEVfU0lOVDY0PTE4XG4gKi9cblxuLyoqXG4gKiBQcm9wZXJ0aWVzIG9mIGEgRmllbGRPcHRpb25zIG1lc3NhZ2UuXG4gKiBAaW50ZXJmYWNlIElGaWVsZE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3BhY2tlZF0gV2hldGhlciBwYWNrZWQgb3Igbm90IChkZWZhdWx0cyB0byBgZmFsc2VgIGZvciBwcm90bzIgYW5kIGB0cnVlYCBmb3IgcHJvdG8zKVxuICogQHByb3BlcnR5IHtJRmllbGRPcHRpb25zSlNUeXBlfSBbanN0eXBlXSBKYXZhU2NyaXB0IHZhbHVlIHR5cGUgKG5vdCB1c2VkIGJ5IHByb3RvYnVmLmpzKVxuICovXG5cbi8qKlxuICogVmFsdWVzIG9mIHRoZSBGaWVsZE9wdGlvbnMuSlNUeXBlIGVudW0uXG4gKiBAdHlwZWRlZiBJRmllbGRPcHRpb25zSlNUeXBlXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQHByb3BlcnR5IHtudW1iZXJ9IEpTX05PUk1BTD0wXG4gKiBAcHJvcGVydHkge251bWJlcn0gSlNfU1RSSU5HPTFcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBKU19OVU1CRVI9MlxuICovXG5cbi8vIGNvcGllZCBoZXJlIGZyb20gcGFyc2UuanNcbnZhciBudW1iZXJSZSA9IC9eKD8hW2VFXSlbMC05XSooPzpcXC5bMC05XSopPyg/OltlRV1bKy1dP1swLTldKyk/JC87XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZpZWxkIGZyb20gYSBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtJRmllbGREZXNjcmlwdG9yUHJvdG98UmVhZGVyfFVpbnQ4QXJyYXl9IGRlc2NyaXB0b3IgRGVzY3JpcHRvclxuICogQHBhcmFtIHtzdHJpbmd9IFtzeW50YXg9XCJwcm90bzJcIl0gU3ludGF4XG4gKiBAcmV0dXJucyB7RmllbGR9IEZpZWxkIGluc3RhbmNlXG4gKi9cbkZpZWxkLmZyb21EZXNjcmlwdG9yID0gZnVuY3Rpb24gZnJvbURlc2NyaXB0b3IoZGVzY3JpcHRvciwgc3ludGF4KSB7XG5cbiAgICAvLyBEZWNvZGUgdGhlIGRlc2NyaXB0b3IgbWVzc2FnZSBpZiBzcGVjaWZpZWQgYXMgYSBidWZmZXI6XG4gICAgaWYgKHR5cGVvZiBkZXNjcmlwdG9yLmxlbmd0aCA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgZGVzY3JpcHRvciA9IGV4cG9ydHMuRGVzY3JpcHRvclByb3RvLmRlY29kZShkZXNjcmlwdG9yKTtcblxuICAgIGlmICh0eXBlb2YgZGVzY3JpcHRvci5udW1iZXIgIT09IFwibnVtYmVyXCIpXG4gICAgICAgIHRocm93IEVycm9yKFwibWlzc2luZyBmaWVsZCBpZFwiKTtcblxuICAgIC8vIFJld2lyZSBmaWVsZCB0eXBlXG4gICAgdmFyIGZpZWxkVHlwZTtcbiAgICBpZiAoZGVzY3JpcHRvci50eXBlTmFtZSAmJiBkZXNjcmlwdG9yLnR5cGVOYW1lLmxlbmd0aClcbiAgICAgICAgZmllbGRUeXBlID0gZGVzY3JpcHRvci50eXBlTmFtZTtcbiAgICBlbHNlXG4gICAgICAgIGZpZWxkVHlwZSA9IGZyb21EZXNjcmlwdG9yVHlwZShkZXNjcmlwdG9yLnR5cGUpO1xuXG4gICAgLy8gUmV3aXJlIGZpZWxkIHJ1bGVcbiAgICB2YXIgZmllbGRSdWxlO1xuICAgIHN3aXRjaCAoZGVzY3JpcHRvci5sYWJlbCkge1xuICAgICAgICAvLyAwIGlzIHJlc2VydmVkIGZvciBlcnJvcnNcbiAgICAgICAgY2FzZSAxOiBmaWVsZFJ1bGUgPSB1bmRlZmluZWQ7IGJyZWFrO1xuICAgICAgICBjYXNlIDI6IGZpZWxkUnVsZSA9IFwicmVxdWlyZWRcIjsgYnJlYWs7XG4gICAgICAgIGNhc2UgMzogZmllbGRSdWxlID0gXCJyZXBlYXRlZFwiOyBicmVhaztcbiAgICAgICAgZGVmYXVsdDogdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIGxhYmVsOiBcIiArIGRlc2NyaXB0b3IubGFiZWwpO1xuICAgIH1cblxuXHR2YXIgZXh0ZW5kZWUgPSBkZXNjcmlwdG9yLmV4dGVuZGVlO1xuXHRpZiAoZGVzY3JpcHRvci5leHRlbmRlZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0ZXh0ZW5kZWUgPSBleHRlbmRlZS5sZW5ndGggPyBleHRlbmRlZSA6IHVuZGVmaW5lZDtcblx0fVxuICAgIHZhciBmaWVsZCA9IG5ldyBGaWVsZChcbiAgICAgICAgZGVzY3JpcHRvci5uYW1lLmxlbmd0aCA/IGRlc2NyaXB0b3IubmFtZSA6IFwiZmllbGRcIiArIGRlc2NyaXB0b3IubnVtYmVyLFxuICAgICAgICBkZXNjcmlwdG9yLm51bWJlcixcbiAgICAgICAgZmllbGRUeXBlLFxuICAgICAgICBmaWVsZFJ1bGUsXG4gICAgICAgIGV4dGVuZGVlXG4gICAgKTtcblxuICAgIGZpZWxkLm9wdGlvbnMgPSBmcm9tRGVzY3JpcHRvck9wdGlvbnMoZGVzY3JpcHRvci5vcHRpb25zLCBleHBvcnRzLkZpZWxkT3B0aW9ucyk7XG5cbiAgICBpZiAoZGVzY3JpcHRvci5kZWZhdWx0VmFsdWUgJiYgZGVzY3JpcHRvci5kZWZhdWx0VmFsdWUubGVuZ3RoKSB7XG4gICAgICAgIHZhciBkZWZhdWx0VmFsdWUgPSBkZXNjcmlwdG9yLmRlZmF1bHRWYWx1ZTtcbiAgICAgICAgc3dpdGNoIChkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ0cnVlXCI6IGNhc2UgXCJUUlVFXCI6XG4gICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJmYWxzZVwiOiBjYXNlIFwiRkFMU0VcIjpcbiAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gbnVtYmVyUmUuZXhlYyhkZWZhdWx0VmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaClcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlID0gcGFyc2VJbnQoZGVmYXVsdFZhbHVlKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSByYWRpeFxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGZpZWxkLnNldE9wdGlvbihcImRlZmF1bHRcIiwgZGVmYXVsdFZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAocGFja2FibGVEZXNjcmlwdG9yVHlwZShkZXNjcmlwdG9yLnR5cGUpKSB7XG4gICAgICAgIGlmIChzeW50YXggPT09IFwicHJvdG8zXCIpIHsgLy8gZGVmYXVsdHMgdG8gcGFja2VkPXRydWUgKGludGVybmFsIHByZXNldCBpcyBwYWNrZWQ9dHJ1ZSlcbiAgICAgICAgICAgIGlmIChkZXNjcmlwdG9yLm9wdGlvbnMgJiYgIWRlc2NyaXB0b3Iub3B0aW9ucy5wYWNrZWQpXG4gICAgICAgICAgICAgICAgZmllbGQuc2V0T3B0aW9uKFwicGFja2VkXCIsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIGlmICghKGRlc2NyaXB0b3Iub3B0aW9ucyAmJiBkZXNjcmlwdG9yLm9wdGlvbnMucGFja2VkKSkgLy8gZGVmYXVsdHMgdG8gcGFja2VkPWZhbHNlXG4gICAgICAgICAgICBmaWVsZC5zZXRPcHRpb24oXCJwYWNrZWRcIiwgZmFsc2UpO1xuICAgIH1cblxuICAgIHJldHVybiBmaWVsZDtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBmaWVsZCB0byBhIGRlc2NyaXB0b3IuXG4gKiBAcmV0dXJucyB7TWVzc2FnZTxJRmllbGREZXNjcmlwdG9yUHJvdG8+fSBEZXNjcmlwdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N5bnRheD1cInByb3RvMlwiXSBTeW50YXhcbiAqL1xuRmllbGQucHJvdG90eXBlLnRvRGVzY3JpcHRvciA9IGZ1bmN0aW9uIHRvRGVzY3JpcHRvcihzeW50YXgpIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IGV4cG9ydHMuRmllbGREZXNjcmlwdG9yUHJvdG8uY3JlYXRlKHsgbmFtZTogdGhpcy5uYW1lLCBudW1iZXI6IHRoaXMuaWQgfSk7XG5cbiAgICBpZiAodGhpcy5tYXApIHtcblxuICAgICAgICBkZXNjcmlwdG9yLnR5cGUgPSAxMTsgLy8gbWVzc2FnZVxuICAgICAgICBkZXNjcmlwdG9yLnR5cGVOYW1lID0gJHByb3RvYnVmLnV0aWwudWNGaXJzdCh0aGlzLm5hbWUpOyAvLyBmaWVsZE5hbWUgLT4gRmllbGROYW1lRW50cnkgKGJ1aWx0IGluIFR5cGUjdG9EZXNjcmlwdG9yKVxuICAgICAgICBkZXNjcmlwdG9yLmxhYmVsID0gMzsgLy8gcmVwZWF0ZWRcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gUmV3aXJlIGZpZWxkIHR5cGVcbiAgICAgICAgc3dpdGNoIChkZXNjcmlwdG9yLnR5cGUgPSB0b0Rlc2NyaXB0b3JUeXBlKHRoaXMudHlwZSwgdGhpcy5yZXNvbHZlKCkucmVzb2x2ZWRUeXBlKSkge1xuICAgICAgICAgICAgY2FzZSAxMDogLy8gZ3JvdXBcbiAgICAgICAgICAgIGNhc2UgMTE6IC8vIHR5cGVcbiAgICAgICAgICAgIGNhc2UgMTQ6IC8vIGVudW1cbiAgICAgICAgICAgICAgICBkZXNjcmlwdG9yLnR5cGVOYW1lID0gdGhpcy5yZXNvbHZlZFR5cGUgPyBzaG9ydG5hbWUodGhpcy5wYXJlbnQsIHRoaXMucmVzb2x2ZWRUeXBlKSA6IHRoaXMudHlwZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJld2lyZSBmaWVsZCBydWxlXG4gICAgICAgIHN3aXRjaCAodGhpcy5ydWxlKSB7XG4gICAgICAgICAgICBjYXNlIFwicmVwZWF0ZWRcIjogZGVzY3JpcHRvci5sYWJlbCA9IDM7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInJlcXVpcmVkXCI6IGRlc2NyaXB0b3IubGFiZWwgPSAyOyBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6IGRlc2NyaXB0b3IubGFiZWwgPSAxOyBicmVhaztcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIGV4dGVuc2lvbiBmaWVsZFxuICAgIGRlc2NyaXB0b3IuZXh0ZW5kZWUgPSB0aGlzLmV4dGVuc2lvbkZpZWxkID8gdGhpcy5leHRlbnNpb25GaWVsZC5wYXJlbnQuZnVsbE5hbWUgOiB0aGlzLmV4dGVuZDtcblxuICAgIC8vIEhhbmRsZSBwYXJ0IG9mIG9uZW9mXG4gICAgaWYgKHRoaXMucGFydE9mKVxuICAgICAgICBpZiAoKGRlc2NyaXB0b3Iub25lb2ZJbmRleCA9IHRoaXMucGFyZW50Lm9uZW9mc0FycmF5LmluZGV4T2YodGhpcy5wYXJ0T2YpKSA8IDApXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIm1pc3Npbmcgb25lb2ZcIik7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zKSB7XG4gICAgICAgIGRlc2NyaXB0b3Iub3B0aW9ucyA9IHRvRGVzY3JpcHRvck9wdGlvbnModGhpcy5vcHRpb25zLCBleHBvcnRzLkZpZWxkT3B0aW9ucyk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnNbXCJkZWZhdWx0XCJdICE9IG51bGwpXG4gICAgICAgICAgICBkZXNjcmlwdG9yLmRlZmF1bHRWYWx1ZSA9IFN0cmluZyh0aGlzLm9wdGlvbnNbXCJkZWZhdWx0XCJdKTtcbiAgICB9XG5cbiAgICBpZiAoc3ludGF4ID09PSBcInByb3RvM1wiKSB7IC8vIGRlZmF1bHRzIHRvIHBhY2tlZD10cnVlXG4gICAgICAgIGlmICghdGhpcy5wYWNrZWQpXG4gICAgICAgICAgICAoZGVzY3JpcHRvci5vcHRpb25zIHx8IChkZXNjcmlwdG9yLm9wdGlvbnMgPSBleHBvcnRzLkZpZWxkT3B0aW9ucy5jcmVhdGUoKSkpLnBhY2tlZCA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAodGhpcy5wYWNrZWQpIC8vIGRlZmF1bHRzIHRvIHBhY2tlZD1mYWxzZVxuICAgICAgICAoZGVzY3JpcHRvci5vcHRpb25zIHx8IChkZXNjcmlwdG9yLm9wdGlvbnMgPSBleHBvcnRzLkZpZWxkT3B0aW9ucy5jcmVhdGUoKSkpLnBhY2tlZCA9IHRydWU7XG5cbiAgICByZXR1cm4gZGVzY3JpcHRvcjtcbn07XG5cbi8vIC0tLSBFbnVtIC0tLVxuXG4vKipcbiAqIFByb3BlcnRpZXMgb2YgYW4gRW51bURlc2NyaXB0b3JQcm90byBtZXNzYWdlLlxuICogQGludGVyZmFjZSBJRW51bURlc2NyaXB0b3JQcm90b1xuICogQHByb3BlcnR5IHtzdHJpbmd9IFtuYW1lXSBFbnVtIG5hbWVcbiAqIEBwcm9wZXJ0eSB7SUVudW1WYWx1ZURlc2NyaXB0b3JQcm90b1tdfSBbdmFsdWVdIEVudW0gdmFsdWVzXG4gKiBAcHJvcGVydHkge0lFbnVtT3B0aW9uc30gW29wdGlvbnNdIEVudW0gb3B0aW9uc1xuICovXG5cbi8qKlxuICogUHJvcGVydGllcyBvZiBhbiBFbnVtVmFsdWVEZXNjcmlwdG9yUHJvdG8gbWVzc2FnZS5cbiAqIEBpbnRlcmZhY2UgSUVudW1WYWx1ZURlc2NyaXB0b3JQcm90b1xuICogQHByb3BlcnR5IHtzdHJpbmd9IFtuYW1lXSBOYW1lXG4gKiBAcHJvcGVydHkge251bWJlcn0gW251bWJlcl0gVmFsdWVcbiAqIEBwcm9wZXJ0eSB7Kn0gW29wdGlvbnNdIE5vdCBzdXBwb3J0ZWRcbiAqL1xuXG4vKipcbiAqIFByb3BlcnRpZXMgb2YgYW4gRW51bU9wdGlvbnMgbWVzc2FnZS5cbiAqIEBpbnRlcmZhY2UgSUVudW1PcHRpb25zXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFthbGxvd0FsaWFzXSBXaGV0aGVyIGFsaWFzZXMgYXJlIGFsbG93ZWRcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2RlcHJlY2F0ZWRdXG4gKi9cblxudmFyIHVubmFtZWRFbnVtSW5kZXggPSAwO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gZW51bSBmcm9tIGEgZGVzY3JpcHRvci5cbiAqIEBwYXJhbSB7SUVudW1EZXNjcmlwdG9yUHJvdG98UmVhZGVyfFVpbnQ4QXJyYXl9IGRlc2NyaXB0b3IgRGVzY3JpcHRvclxuICogQHJldHVybnMge0VudW19IEVudW0gaW5zdGFuY2VcbiAqL1xuRW51bS5mcm9tRGVzY3JpcHRvciA9IGZ1bmN0aW9uIGZyb21EZXNjcmlwdG9yKGRlc2NyaXB0b3IpIHtcblxuICAgIC8vIERlY29kZSB0aGUgZGVzY3JpcHRvciBtZXNzYWdlIGlmIHNwZWNpZmllZCBhcyBhIGJ1ZmZlcjpcbiAgICBpZiAodHlwZW9mIGRlc2NyaXB0b3IubGVuZ3RoID09PSBcIm51bWJlclwiKVxuICAgICAgICBkZXNjcmlwdG9yID0gZXhwb3J0cy5FbnVtRGVzY3JpcHRvclByb3RvLmRlY29kZShkZXNjcmlwdG9yKTtcblxuICAgIC8vIENvbnN0cnVjdCB2YWx1ZXMgb2JqZWN0XG4gICAgdmFyIHZhbHVlcyA9IHt9O1xuICAgIGlmIChkZXNjcmlwdG9yLnZhbHVlKVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlc2NyaXB0b3IudmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBuYW1lICA9IGRlc2NyaXB0b3IudmFsdWVbaV0ubmFtZSxcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGRlc2NyaXB0b3IudmFsdWVbaV0ubnVtYmVyIHx8IDA7XG4gICAgICAgICAgICB2YWx1ZXNbbmFtZSAmJiBuYW1lLmxlbmd0aCA/IG5hbWUgOiBcIk5BTUVcIiArIHZhbHVlXSA9IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICByZXR1cm4gbmV3IEVudW0oXG4gICAgICAgIGRlc2NyaXB0b3IubmFtZSAmJiBkZXNjcmlwdG9yLm5hbWUubGVuZ3RoID8gZGVzY3JpcHRvci5uYW1lIDogXCJFbnVtXCIgKyB1bm5hbWVkRW51bUluZGV4KyssXG4gICAgICAgIHZhbHVlcyxcbiAgICAgICAgZnJvbURlc2NyaXB0b3JPcHRpb25zKGRlc2NyaXB0b3Iub3B0aW9ucywgZXhwb3J0cy5FbnVtT3B0aW9ucylcbiAgICApO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBlbnVtIHRvIGEgZGVzY3JpcHRvci5cbiAqIEByZXR1cm5zIHtNZXNzYWdlPElFbnVtRGVzY3JpcHRvclByb3RvPn0gRGVzY3JpcHRvclxuICovXG5FbnVtLnByb3RvdHlwZS50b0Rlc2NyaXB0b3IgPSBmdW5jdGlvbiB0b0Rlc2NyaXB0b3IoKSB7XG5cbiAgICAvLyBWYWx1ZXNcbiAgICB2YXIgdmFsdWVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGtzID0gT2JqZWN0LmtleXModGhpcy52YWx1ZXMpOyBpIDwga3MubGVuZ3RoOyArK2kpXG4gICAgICAgIHZhbHVlcy5wdXNoKGV4cG9ydHMuRW51bVZhbHVlRGVzY3JpcHRvclByb3RvLmNyZWF0ZSh7IG5hbWU6IGtzW2ldLCBudW1iZXI6IHRoaXMudmFsdWVzW2tzW2ldXSB9KSk7XG5cbiAgICByZXR1cm4gZXhwb3J0cy5FbnVtRGVzY3JpcHRvclByb3RvLmNyZWF0ZSh7XG4gICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgdmFsdWU6IHZhbHVlcyxcbiAgICAgICAgb3B0aW9uczogdG9EZXNjcmlwdG9yT3B0aW9ucyh0aGlzLm9wdGlvbnMsIGV4cG9ydHMuRW51bU9wdGlvbnMpXG4gICAgfSk7XG59O1xuXG4vLyAtLS0gT25lT2YgLS0tXG5cbi8qKlxuICogUHJvcGVydGllcyBvZiBhIE9uZW9mRGVzY3JpcHRvclByb3RvIG1lc3NhZ2UuXG4gKiBAaW50ZXJmYWNlIElPbmVvZkRlc2NyaXB0b3JQcm90b1xuICogQHByb3BlcnR5IHtzdHJpbmd9IFtuYW1lXSBPbmVvZiBuYW1lXG4gKiBAcHJvcGVydHkgeyp9IFtvcHRpb25zXSBOb3Qgc3VwcG9ydGVkXG4gKi9cblxudmFyIHVubmFtZWRPbmVvZkluZGV4ID0gMDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgb25lb2YgZnJvbSBhIGRlc2NyaXB0b3IuXG4gKiBAcGFyYW0ge0lPbmVvZkRlc2NyaXB0b3JQcm90b3xSZWFkZXJ8VWludDhBcnJheX0gZGVzY3JpcHRvciBEZXNjcmlwdG9yXG4gKiBAcmV0dXJucyB7T25lT2Z9IE9uZU9mIGluc3RhbmNlXG4gKi9cbk9uZU9mLmZyb21EZXNjcmlwdG9yID0gZnVuY3Rpb24gZnJvbURlc2NyaXB0b3IoZGVzY3JpcHRvcikge1xuXG4gICAgLy8gRGVjb2RlIHRoZSBkZXNjcmlwdG9yIG1lc3NhZ2UgaWYgc3BlY2lmaWVkIGFzIGEgYnVmZmVyOlxuICAgIGlmICh0eXBlb2YgZGVzY3JpcHRvci5sZW5ndGggPT09IFwibnVtYmVyXCIpXG4gICAgICAgIGRlc2NyaXB0b3IgPSBleHBvcnRzLk9uZW9mRGVzY3JpcHRvclByb3RvLmRlY29kZShkZXNjcmlwdG9yKTtcblxuICAgIHJldHVybiBuZXcgT25lT2YoXG4gICAgICAgIC8vIHVubmFtZWRPbmVPZkluZGV4IGlzIGdsb2JhbCwgbm90IHBlciB0eXBlLCBiZWNhdXNlIHdlIGhhdmUgbm8gcmVmIHRvIGEgdHlwZSBoZXJlXG4gICAgICAgIGRlc2NyaXB0b3IubmFtZSAmJiBkZXNjcmlwdG9yLm5hbWUubGVuZ3RoID8gZGVzY3JpcHRvci5uYW1lIDogXCJvbmVvZlwiICsgdW5uYW1lZE9uZW9mSW5kZXgrK1xuICAgICAgICAvLyBmcm9tRGVzY3JpcHRvck9wdGlvbnMoZGVzY3JpcHRvci5vcHRpb25zLCBleHBvcnRzLk9uZW9mT3B0aW9ucykgLSBvbmx5IHVuaW50ZXJwcmV0ZWRfb3B0aW9uXG4gICAgKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBvbmVvZiB0byBhIGRlc2NyaXB0b3IuXG4gKiBAcmV0dXJucyB7TWVzc2FnZTxJT25lb2ZEZXNjcmlwdG9yUHJvdG8+fSBEZXNjcmlwdG9yXG4gKi9cbk9uZU9mLnByb3RvdHlwZS50b0Rlc2NyaXB0b3IgPSBmdW5jdGlvbiB0b0Rlc2NyaXB0b3IoKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuT25lb2ZEZXNjcmlwdG9yUHJvdG8uY3JlYXRlKHtcbiAgICAgICAgbmFtZTogdGhpcy5uYW1lXG4gICAgICAgIC8vIG9wdGlvbnM6IHRvRGVzY3JpcHRvck9wdGlvbnModGhpcy5vcHRpb25zLCBleHBvcnRzLk9uZW9mT3B0aW9ucykgLSBvbmx5IHVuaW50ZXJwcmV0ZWRfb3B0aW9uXG4gICAgfSk7XG59O1xuXG4vLyAtLS0gU2VydmljZSAtLS1cblxuLyoqXG4gKiBQcm9wZXJ0aWVzIG9mIGEgU2VydmljZURlc2NyaXB0b3JQcm90byBtZXNzYWdlLlxuICogQGludGVyZmFjZSBJU2VydmljZURlc2NyaXB0b3JQcm90b1xuICogQHByb3BlcnR5IHtzdHJpbmd9IFtuYW1lXSBTZXJ2aWNlIG5hbWVcbiAqIEBwcm9wZXJ0eSB7SU1ldGhvZERlc2NyaXB0b3JQcm90b1tdfSBbbWV0aG9kXSBNZXRob2RzXG4gKiBAcHJvcGVydHkge0lTZXJ2aWNlT3B0aW9uc30gW29wdGlvbnNdIE9wdGlvbnNcbiAqL1xuXG4vKipcbiAqIFByb3BlcnRpZXMgb2YgYSBTZXJ2aWNlT3B0aW9ucyBtZXNzYWdlLlxuICogQGludGVyZmFjZSBJU2VydmljZU9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2RlcHJlY2F0ZWRdXG4gKi9cblxudmFyIHVubmFtZWRTZXJ2aWNlSW5kZXggPSAwO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzZXJ2aWNlIGZyb20gYSBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtJU2VydmljZURlc2NyaXB0b3JQcm90b3xSZWFkZXJ8VWludDhBcnJheX0gZGVzY3JpcHRvciBEZXNjcmlwdG9yXG4gKiBAcmV0dXJucyB7U2VydmljZX0gU2VydmljZSBpbnN0YW5jZVxuICovXG5TZXJ2aWNlLmZyb21EZXNjcmlwdG9yID0gZnVuY3Rpb24gZnJvbURlc2NyaXB0b3IoZGVzY3JpcHRvcikge1xuXG4gICAgLy8gRGVjb2RlIHRoZSBkZXNjcmlwdG9yIG1lc3NhZ2UgaWYgc3BlY2lmaWVkIGFzIGEgYnVmZmVyOlxuICAgIGlmICh0eXBlb2YgZGVzY3JpcHRvci5sZW5ndGggPT09IFwibnVtYmVyXCIpXG4gICAgICAgIGRlc2NyaXB0b3IgPSBleHBvcnRzLlNlcnZpY2VEZXNjcmlwdG9yUHJvdG8uZGVjb2RlKGRlc2NyaXB0b3IpO1xuXG4gICAgdmFyIHNlcnZpY2UgPSBuZXcgU2VydmljZShkZXNjcmlwdG9yLm5hbWUgJiYgZGVzY3JpcHRvci5uYW1lLmxlbmd0aCA/IGRlc2NyaXB0b3IubmFtZSA6IFwiU2VydmljZVwiICsgdW5uYW1lZFNlcnZpY2VJbmRleCsrLCBmcm9tRGVzY3JpcHRvck9wdGlvbnMoZGVzY3JpcHRvci5vcHRpb25zLCBleHBvcnRzLlNlcnZpY2VPcHRpb25zKSk7XG4gICAgaWYgKGRlc2NyaXB0b3IubWV0aG9kKVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlc2NyaXB0b3IubWV0aG9kLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgc2VydmljZS5hZGQoTWV0aG9kLmZyb21EZXNjcmlwdG9yKGRlc2NyaXB0b3IubWV0aG9kW2ldKSk7XG5cbiAgICByZXR1cm4gc2VydmljZTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBzZXJ2aWNlIHRvIGEgZGVzY3JpcHRvci5cbiAqIEByZXR1cm5zIHtNZXNzYWdlPElTZXJ2aWNlRGVzY3JpcHRvclByb3RvPn0gRGVzY3JpcHRvclxuICovXG5TZXJ2aWNlLnByb3RvdHlwZS50b0Rlc2NyaXB0b3IgPSBmdW5jdGlvbiB0b0Rlc2NyaXB0b3IoKSB7XG5cbiAgICAvLyBNZXRob2RzXG4gICAgdmFyIG1ldGhvZHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubWV0aG9kc0FycmF5Lmxlbmd0aDsgKytpKVxuICAgICAgICBtZXRob2RzLnB1c2godGhpcy5fbWV0aG9kc0FycmF5W2ldLnRvRGVzY3JpcHRvcigpKTtcblxuICAgIHJldHVybiBleHBvcnRzLlNlcnZpY2VEZXNjcmlwdG9yUHJvdG8uY3JlYXRlKHtcbiAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICBtZXRob2Q6IG1ldGhvZHMsXG4gICAgICAgIG9wdGlvbnM6IHRvRGVzY3JpcHRvck9wdGlvbnModGhpcy5vcHRpb25zLCBleHBvcnRzLlNlcnZpY2VPcHRpb25zKVxuICAgIH0pO1xufTtcblxuLy8gLS0tIE1ldGhvZCAtLS1cblxuLyoqXG4gKiBQcm9wZXJ0aWVzIG9mIGEgTWV0aG9kRGVzY3JpcHRvclByb3RvIG1lc3NhZ2UuXG4gKiBAaW50ZXJmYWNlIElNZXRob2REZXNjcmlwdG9yUHJvdG9cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbmFtZV0gTWV0aG9kIG5hbWVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbaW5wdXRUeXBlXSBSZXF1ZXN0IHR5cGUgbmFtZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtvdXRwdXRUeXBlXSBSZXNwb25zZSB0eXBlIG5hbWVcbiAqIEBwcm9wZXJ0eSB7SU1ldGhvZE9wdGlvbnN9IFtvcHRpb25zXSBOb3Qgc3VwcG9ydGVkXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtjbGllbnRTdHJlYW1pbmc9ZmFsc2VdIFdoZXRoZXIgcmVxdWVzdHMgYXJlIHN0cmVhbWVkXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtzZXJ2ZXJTdHJlYW1pbmc9ZmFsc2VdIFdoZXRoZXIgcmVzcG9uc2VzIGFyZSBzdHJlYW1lZFxuICovXG5cbi8qKlxuICogUHJvcGVydGllcyBvZiBhIE1ldGhvZE9wdGlvbnMgbWVzc2FnZS5cbiAqIEBpbnRlcmZhY2UgSU1ldGhvZE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2RlcHJlY2F0ZWRdXG4gKi9cblxudmFyIHVubmFtZWRNZXRob2RJbmRleCA9IDA7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1ldGhvZCBmcm9tIGEgZGVzY3JpcHRvci5cbiAqIEBwYXJhbSB7SU1ldGhvZERlc2NyaXB0b3JQcm90b3xSZWFkZXJ8VWludDhBcnJheX0gZGVzY3JpcHRvciBEZXNjcmlwdG9yXG4gKiBAcmV0dXJucyB7TWV0aG9kfSBSZWZsZWN0ZWQgbWV0aG9kIGluc3RhbmNlXG4gKi9cbk1ldGhvZC5mcm9tRGVzY3JpcHRvciA9IGZ1bmN0aW9uIGZyb21EZXNjcmlwdG9yKGRlc2NyaXB0b3IpIHtcblxuICAgIC8vIERlY29kZSB0aGUgZGVzY3JpcHRvciBtZXNzYWdlIGlmIHNwZWNpZmllZCBhcyBhIGJ1ZmZlcjpcbiAgICBpZiAodHlwZW9mIGRlc2NyaXB0b3IubGVuZ3RoID09PSBcIm51bWJlclwiKVxuICAgICAgICBkZXNjcmlwdG9yID0gZXhwb3J0cy5NZXRob2REZXNjcmlwdG9yUHJvdG8uZGVjb2RlKGRlc2NyaXB0b3IpO1xuXG4gICAgcmV0dXJuIG5ldyBNZXRob2QoXG4gICAgICAgIC8vIHVubmFtZWRNZXRob2RJbmRleCBpcyBnbG9iYWwsIG5vdCBwZXIgc2VydmljZSwgYmVjYXVzZSB3ZSBoYXZlIG5vIHJlZiB0byBhIHNlcnZpY2UgaGVyZVxuICAgICAgICBkZXNjcmlwdG9yLm5hbWUgJiYgZGVzY3JpcHRvci5uYW1lLmxlbmd0aCA/IGRlc2NyaXB0b3IubmFtZSA6IFwiTWV0aG9kXCIgKyB1bm5hbWVkTWV0aG9kSW5kZXgrKyxcbiAgICAgICAgXCJycGNcIixcbiAgICAgICAgZGVzY3JpcHRvci5pbnB1dFR5cGUsXG4gICAgICAgIGRlc2NyaXB0b3Iub3V0cHV0VHlwZSxcbiAgICAgICAgQm9vbGVhbihkZXNjcmlwdG9yLmNsaWVudFN0cmVhbWluZyksXG4gICAgICAgIEJvb2xlYW4oZGVzY3JpcHRvci5zZXJ2ZXJTdHJlYW1pbmcpLFxuICAgICAgICBmcm9tRGVzY3JpcHRvck9wdGlvbnMoZGVzY3JpcHRvci5vcHRpb25zLCBleHBvcnRzLk1ldGhvZE9wdGlvbnMpXG4gICAgKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBtZXRob2QgdG8gYSBkZXNjcmlwdG9yLlxuICogQHJldHVybnMge01lc3NhZ2U8SU1ldGhvZERlc2NyaXB0b3JQcm90bz59IERlc2NyaXB0b3JcbiAqL1xuTWV0aG9kLnByb3RvdHlwZS50b0Rlc2NyaXB0b3IgPSBmdW5jdGlvbiB0b0Rlc2NyaXB0b3IoKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuTWV0aG9kRGVzY3JpcHRvclByb3RvLmNyZWF0ZSh7XG4gICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgaW5wdXRUeXBlOiB0aGlzLnJlc29sdmVkUmVxdWVzdFR5cGUgPyB0aGlzLnJlc29sdmVkUmVxdWVzdFR5cGUuZnVsbE5hbWUgOiB0aGlzLnJlcXVlc3RUeXBlLFxuICAgICAgICBvdXRwdXRUeXBlOiB0aGlzLnJlc29sdmVkUmVzcG9uc2VUeXBlID8gdGhpcy5yZXNvbHZlZFJlc3BvbnNlVHlwZS5mdWxsTmFtZSA6IHRoaXMucmVzcG9uc2VUeXBlLFxuICAgICAgICBjbGllbnRTdHJlYW1pbmc6IHRoaXMucmVxdWVzdFN0cmVhbSxcbiAgICAgICAgc2VydmVyU3RyZWFtaW5nOiB0aGlzLnJlc3BvbnNlU3RyZWFtLFxuICAgICAgICBvcHRpb25zOiB0b0Rlc2NyaXB0b3JPcHRpb25zKHRoaXMub3B0aW9ucywgZXhwb3J0cy5NZXRob2RPcHRpb25zKVxuICAgIH0pO1xufTtcblxuLy8gLS0tIHV0aWxpdHkgLS0tXG5cbi8vIENvbnZlcnRzIGEgZGVzY3JpcHRvciB0eXBlIHRvIGEgcHJvdG9idWYuanMgYmFzaWMgdHlwZVxuZnVuY3Rpb24gZnJvbURlc2NyaXB0b3JUeXBlKHR5cGUpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgLy8gMCBpcyByZXNlcnZlZCBmb3IgZXJyb3JzXG4gICAgICAgIGNhc2UgMTogcmV0dXJuIFwiZG91YmxlXCI7XG4gICAgICAgIGNhc2UgMjogcmV0dXJuIFwiZmxvYXRcIjtcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gXCJpbnQ2NFwiO1xuICAgICAgICBjYXNlIDQ6IHJldHVybiBcInVpbnQ2NFwiO1xuICAgICAgICBjYXNlIDU6IHJldHVybiBcImludDMyXCI7XG4gICAgICAgIGNhc2UgNjogcmV0dXJuIFwiZml4ZWQ2NFwiO1xuICAgICAgICBjYXNlIDc6IHJldHVybiBcImZpeGVkMzJcIjtcbiAgICAgICAgY2FzZSA4OiByZXR1cm4gXCJib29sXCI7XG4gICAgICAgIGNhc2UgOTogcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgICAgIGNhc2UgMTI6IHJldHVybiBcImJ5dGVzXCI7XG4gICAgICAgIGNhc2UgMTM6IHJldHVybiBcInVpbnQzMlwiO1xuICAgICAgICBjYXNlIDE1OiByZXR1cm4gXCJzZml4ZWQzMlwiO1xuICAgICAgICBjYXNlIDE2OiByZXR1cm4gXCJzZml4ZWQ2NFwiO1xuICAgICAgICBjYXNlIDE3OiByZXR1cm4gXCJzaW50MzJcIjtcbiAgICAgICAgY2FzZSAxODogcmV0dXJuIFwic2ludDY0XCI7XG4gICAgfVxuICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCB0eXBlOiBcIiArIHR5cGUpO1xufVxuXG4vLyBUZXN0cyBpZiBhIGRlc2NyaXB0b3IgdHlwZSBpcyBwYWNrYWJsZVxuZnVuY3Rpb24gcGFja2FibGVEZXNjcmlwdG9yVHlwZSh0eXBlKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgMTogLy8gZG91YmxlXG4gICAgICAgIGNhc2UgMjogLy8gZmxvYXRcbiAgICAgICAgY2FzZSAzOiAvLyBpbnQ2NFxuICAgICAgICBjYXNlIDQ6IC8vIHVpbnQ2NFxuICAgICAgICBjYXNlIDU6IC8vIGludDMyXG4gICAgICAgIGNhc2UgNjogLy8gZml4ZWQ2NFxuICAgICAgICBjYXNlIDc6IC8vIGZpeGVkMzJcbiAgICAgICAgY2FzZSA4OiAvLyBib29sXG4gICAgICAgIGNhc2UgMTM6IC8vIHVpbnQzMlxuICAgICAgICBjYXNlIDE0OiAvLyBlbnVtICghKVxuICAgICAgICBjYXNlIDE1OiAvLyBzZml4ZWQzMlxuICAgICAgICBjYXNlIDE2OiAvLyBzZml4ZWQ2NFxuICAgICAgICBjYXNlIDE3OiAvLyBzaW50MzJcbiAgICAgICAgY2FzZSAxODogLy8gc2ludDY0XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBDb252ZXJ0cyBhIHByb3RvYnVmLmpzIGJhc2ljIHR5cGUgdG8gYSBkZXNjcmlwdG9yIHR5cGVcbmZ1bmN0aW9uIHRvRGVzY3JpcHRvclR5cGUodHlwZSwgcmVzb2x2ZWRUeXBlKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIC8vIDAgaXMgcmVzZXJ2ZWQgZm9yIGVycm9yc1xuICAgICAgICBjYXNlIFwiZG91YmxlXCI6IHJldHVybiAxO1xuICAgICAgICBjYXNlIFwiZmxvYXRcIjogcmV0dXJuIDI7XG4gICAgICAgIGNhc2UgXCJpbnQ2NFwiOiByZXR1cm4gMztcbiAgICAgICAgY2FzZSBcInVpbnQ2NFwiOiByZXR1cm4gNDtcbiAgICAgICAgY2FzZSBcImludDMyXCI6IHJldHVybiA1O1xuICAgICAgICBjYXNlIFwiZml4ZWQ2NFwiOiByZXR1cm4gNjtcbiAgICAgICAgY2FzZSBcImZpeGVkMzJcIjogcmV0dXJuIDc7XG4gICAgICAgIGNhc2UgXCJib29sXCI6IHJldHVybiA4O1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6IHJldHVybiA5O1xuICAgICAgICBjYXNlIFwiYnl0ZXNcIjogcmV0dXJuIDEyO1xuICAgICAgICBjYXNlIFwidWludDMyXCI6IHJldHVybiAxMztcbiAgICAgICAgY2FzZSBcInNmaXhlZDMyXCI6IHJldHVybiAxNTtcbiAgICAgICAgY2FzZSBcInNmaXhlZDY0XCI6IHJldHVybiAxNjtcbiAgICAgICAgY2FzZSBcInNpbnQzMlwiOiByZXR1cm4gMTc7XG4gICAgICAgIGNhc2UgXCJzaW50NjRcIjogcmV0dXJuIDE4O1xuICAgIH1cbiAgICBpZiAocmVzb2x2ZWRUeXBlIGluc3RhbmNlb2YgRW51bSlcbiAgICAgICAgcmV0dXJuIDE0O1xuICAgIGlmIChyZXNvbHZlZFR5cGUgaW5zdGFuY2VvZiBUeXBlKVxuICAgICAgICByZXR1cm4gcmVzb2x2ZWRUeXBlLmdyb3VwID8gMTAgOiAxMTtcbiAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgdHlwZTogXCIgKyB0eXBlKTtcbn1cblxuLy8gQ29udmVydHMgZGVzY3JpcHRvciBvcHRpb25zIHRvIGFuIG9wdGlvbnMgb2JqZWN0XG5mdW5jdGlvbiBmcm9tRGVzY3JpcHRvck9wdGlvbnMob3B0aW9ucywgdHlwZSkge1xuICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB2YXIgb3V0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGZpZWxkLCBrZXksIHZhbDsgaSA8IHR5cGUuZmllbGRzQXJyYXkubGVuZ3RoOyArK2kpXG4gICAgICAgIGlmICgoa2V5ID0gKGZpZWxkID0gdHlwZS5fZmllbGRzQXJyYXlbaV0pLm5hbWUpICE9PSBcInVuaW50ZXJwcmV0ZWRPcHRpb25cIilcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KGtleSkpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgICAgICAgICAgICAgICB2YWwgPSBvcHRpb25zW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkLnJlc29sdmVkVHlwZSBpbnN0YW5jZW9mIEVudW0gJiYgdHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIiAmJiBmaWVsZC5yZXNvbHZlZFR5cGUudmFsdWVzQnlJZFt2YWxdICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IGZpZWxkLnJlc29sdmVkVHlwZS52YWx1ZXNCeUlkW3ZhbF07XG4gICAgICAgICAgICAgICAgb3V0LnB1c2godW5kZXJTY29yZShrZXkpLCB2YWwpO1xuICAgICAgICAgICAgfVxuICAgIHJldHVybiBvdXQubGVuZ3RoID8gJHByb3RvYnVmLnV0aWwudG9PYmplY3Qob3V0KSA6IHVuZGVmaW5lZDtcbn1cblxuLy8gQ29udmVydHMgYW4gb3B0aW9ucyBvYmplY3QgdG8gZGVzY3JpcHRvciBvcHRpb25zXG5mdW5jdGlvbiB0b0Rlc2NyaXB0b3JPcHRpb25zKG9wdGlvbnMsIHR5cGUpIHtcbiAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgdmFyIG91dCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBrcyA9IE9iamVjdC5rZXlzKG9wdGlvbnMpLCBrZXksIHZhbDsgaSA8IGtzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhbCA9IG9wdGlvbnNba2V5ID0ga3NbaV1dO1xuICAgICAgICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIilcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB2YXIgZmllbGQgPSB0eXBlLmZpZWxkc1trZXldO1xuICAgICAgICBpZiAoIWZpZWxkICYmICEoZmllbGQgPSB0eXBlLmZpZWxkc1trZXkgPSAkcHJvdG9idWYudXRpbC5jYW1lbENhc2Uoa2V5KV0pKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIG91dC5wdXNoKGtleSwgdmFsKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dC5sZW5ndGggPyB0eXBlLmZyb21PYmplY3QoJHByb3RvYnVmLnV0aWwudG9PYmplY3Qob3V0KSkgOiB1bmRlZmluZWQ7XG59XG5cbi8vIENhbGN1bGF0ZXMgdGhlIHNob3J0ZXN0IHJlbGF0aXZlIHBhdGggZnJvbSBgZnJvbWAgdG8gYHRvYC5cbmZ1bmN0aW9uIHNob3J0bmFtZShmcm9tLCB0bykge1xuICAgIHZhciBmcm9tUGF0aCA9IGZyb20uZnVsbE5hbWUuc3BsaXQoXCIuXCIpLFxuICAgICAgICB0b1BhdGggPSB0by5mdWxsTmFtZS5zcGxpdChcIi5cIiksXG4gICAgICAgIGkgPSAwLFxuICAgICAgICBqID0gMCxcbiAgICAgICAgayA9IHRvUGF0aC5sZW5ndGggLSAxO1xuICAgIGlmICghKGZyb20gaW5zdGFuY2VvZiBSb290KSAmJiB0byBpbnN0YW5jZW9mIE5hbWVzcGFjZSlcbiAgICAgICAgd2hpbGUgKGkgPCBmcm9tUGF0aC5sZW5ndGggJiYgaiA8IGsgJiYgZnJvbVBhdGhbaV0gPT09IHRvUGF0aFtqXSkge1xuICAgICAgICAgICAgdmFyIG90aGVyID0gdG8ubG9va3VwKGZyb21QYXRoW2krK10sIHRydWUpO1xuICAgICAgICAgICAgaWYgKG90aGVyICE9PSBudWxsICYmIG90aGVyICE9PSB0bylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICsrajtcbiAgICAgICAgfVxuICAgIGVsc2VcbiAgICAgICAgZm9yICg7IGkgPCBmcm9tUGF0aC5sZW5ndGggJiYgaiA8IGsgJiYgZnJvbVBhdGhbaV0gPT09IHRvUGF0aFtqXTsgKytpLCArK2opO1xuICAgIHJldHVybiB0b1BhdGguc2xpY2Uoaikuam9pbihcIi5cIik7XG59XG5cbi8vIGNvcGllZCBoZXJlIGZyb20gY2xpL3RhcmdldHMvcHJvdG8uanNcbmZ1bmN0aW9uIHVuZGVyU2NvcmUoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5zdWJzdHJpbmcoMCwxKVxuICAgICAgICAgKyBzdHIuc3Vic3RyaW5nKDEpXG4gICAgICAgICAgICAgICAucmVwbGFjZSgvKFtBLVpdKSg/PVthLXpdfCQpL2csIGZ1bmN0aW9uKCQwLCAkMSkgeyByZXR1cm4gXCJfXCIgKyAkMS50b0xvd2VyQ2FzZSgpOyB9KTtcbn1cblxuLy8gLS0tIGV4cG9ydHMgLS0tXG5cbi8qKlxuICogUmVmbGVjdGVkIGZpbGUgZGVzY3JpcHRvciBzZXQuXG4gKiBAbmFtZSBGaWxlRGVzY3JpcHRvclNldFxuICogQHR5cGUge1R5cGV9XG4gKiBAY29uc3RcbiAqIEB0c3R5cGUgJHByb3RvYnVmLlR5cGVcbiAqL1xuXG4vKipcbiAqIFJlZmxlY3RlZCBmaWxlIGRlc2NyaXB0b3IgcHJvdG8uXG4gKiBAbmFtZSBGaWxlRGVzY3JpcHRvclByb3RvXG4gKiBAdHlwZSB7VHlwZX1cbiAqIEBjb25zdFxuICogQHRzdHlwZSAkcHJvdG9idWYuVHlwZVxuICovXG5cbi8qKlxuICogUmVmbGVjdGVkIGRlc2NyaXB0b3IgcHJvdG8uXG4gKiBAbmFtZSBEZXNjcmlwdG9yUHJvdG9cbiAqIEB0eXBlIHtUeXBlfVxuICogQHByb3BlcnR5IHtUeXBlfSBFeHRlbnNpb25SYW5nZVxuICogQHByb3BlcnR5IHtUeXBlfSBSZXNlcnZlZFJhbmdlXG4gKiBAY29uc3RcbiAqIEB0c3R5cGUgJHByb3RvYnVmLlR5cGUgJiB7XG4gKiAgICAgRXh0ZW5zaW9uUmFuZ2U6ICRwcm90b2J1Zi5UeXBlLFxuICogICAgIFJlc2VydmVkUmFuZ2U6ICRwcm90b2J1Zi5UeXBlXG4gKiB9XG4gKi9cblxuLyoqXG4gKiBSZWZsZWN0ZWQgZmllbGQgZGVzY3JpcHRvciBwcm90by5cbiAqIEBuYW1lIEZpZWxkRGVzY3JpcHRvclByb3RvXG4gKiBAdHlwZSB7VHlwZX1cbiAqIEBwcm9wZXJ0eSB7RW51bX0gTGFiZWxcbiAqIEBwcm9wZXJ0eSB7RW51bX0gVHlwZVxuICogQGNvbnN0XG4gKiBAdHN0eXBlICRwcm90b2J1Zi5UeXBlICYge1xuICogICAgIExhYmVsOiAkcHJvdG9idWYuRW51bSxcbiAqICAgICBUeXBlOiAkcHJvdG9idWYuRW51bVxuICogfVxuICovXG5cbi8qKlxuICogUmVmbGVjdGVkIG9uZW9mIGRlc2NyaXB0b3IgcHJvdG8uXG4gKiBAbmFtZSBPbmVvZkRlc2NyaXB0b3JQcm90b1xuICogQHR5cGUge1R5cGV9XG4gKiBAY29uc3RcbiAqIEB0c3R5cGUgJHByb3RvYnVmLlR5cGVcbiAqL1xuXG4vKipcbiAqIFJlZmxlY3RlZCBlbnVtIGRlc2NyaXB0b3IgcHJvdG8uXG4gKiBAbmFtZSBFbnVtRGVzY3JpcHRvclByb3RvXG4gKiBAdHlwZSB7VHlwZX1cbiAqIEBjb25zdFxuICogQHRzdHlwZSAkcHJvdG9idWYuVHlwZVxuICovXG5cbi8qKlxuICogUmVmbGVjdGVkIHNlcnZpY2UgZGVzY3JpcHRvciBwcm90by5cbiAqIEBuYW1lIFNlcnZpY2VEZXNjcmlwdG9yUHJvdG9cbiAqIEB0eXBlIHtUeXBlfVxuICogQGNvbnN0XG4gKiBAdHN0eXBlICRwcm90b2J1Zi5UeXBlXG4gKi9cblxuLyoqXG4gKiBSZWZsZWN0ZWQgZW51bSB2YWx1ZSBkZXNjcmlwdG9yIHByb3RvLlxuICogQG5hbWUgRW51bVZhbHVlRGVzY3JpcHRvclByb3RvXG4gKiBAdHlwZSB7VHlwZX1cbiAqIEBjb25zdFxuICogQHRzdHlwZSAkcHJvdG9idWYuVHlwZVxuICovXG5cbi8qKlxuICogUmVmbGVjdGVkIG1ldGhvZCBkZXNjcmlwdG9yIHByb3RvLlxuICogQG5hbWUgTWV0aG9kRGVzY3JpcHRvclByb3RvXG4gKiBAdHlwZSB7VHlwZX1cbiAqIEBjb25zdFxuICogQHRzdHlwZSAkcHJvdG9idWYuVHlwZVxuICovXG5cbi8qKlxuICogUmVmbGVjdGVkIGZpbGUgb3B0aW9ucy5cbiAqIEBuYW1lIEZpbGVPcHRpb25zXG4gKiBAdHlwZSB7VHlwZX1cbiAqIEBwcm9wZXJ0eSB7RW51bX0gT3B0aW1pemVNb2RlXG4gKiBAY29uc3RcbiAqIEB0c3R5cGUgJHByb3RvYnVmLlR5cGUgJiB7XG4gKiAgICAgT3B0aW1pemVNb2RlOiAkcHJvdG9idWYuRW51bVxuICogfVxuICovXG5cbi8qKlxuICogUmVmbGVjdGVkIG1lc3NhZ2Ugb3B0aW9ucy5cbiAqIEBuYW1lIE1lc3NhZ2VPcHRpb25zXG4gKiBAdHlwZSB7VHlwZX1cbiAqIEBjb25zdFxuICogQHRzdHlwZSAkcHJvdG9idWYuVHlwZVxuICovXG5cbi8qKlxuICogUmVmbGVjdGVkIGZpZWxkIG9wdGlvbnMuXG4gKiBAbmFtZSBGaWVsZE9wdGlvbnNcbiAqIEB0eXBlIHtUeXBlfVxuICogQHByb3BlcnR5IHtFbnVtfSBDVHlwZVxuICogQHByb3BlcnR5IHtFbnVtfSBKU1R5cGVcbiAqIEBjb25zdFxuICogQHRzdHlwZSAkcHJvdG9idWYuVHlwZSAmIHtcbiAqICAgICBDVHlwZTogJHByb3RvYnVmLkVudW0sXG4gKiAgICAgSlNUeXBlOiAkcHJvdG9idWYuRW51bVxuICogfVxuICovXG5cbi8qKlxuICogUmVmbGVjdGVkIG9uZW9mIG9wdGlvbnMuXG4gKiBAbmFtZSBPbmVvZk9wdGlvbnNcbiAqIEB0eXBlIHtUeXBlfVxuICogQGNvbnN0XG4gKiBAdHN0eXBlICRwcm90b2J1Zi5UeXBlXG4gKi9cblxuLyoqXG4gKiBSZWZsZWN0ZWQgZW51bSBvcHRpb25zLlxuICogQG5hbWUgRW51bU9wdGlvbnNcbiAqIEB0eXBlIHtUeXBlfVxuICogQGNvbnN0XG4gKiBAdHN0eXBlICRwcm90b2J1Zi5UeXBlXG4gKi9cblxuLyoqXG4gKiBSZWZsZWN0ZWQgZW51bSB2YWx1ZSBvcHRpb25zLlxuICogQG5hbWUgRW51bVZhbHVlT3B0aW9uc1xuICogQHR5cGUge1R5cGV9XG4gKiBAY29uc3RcbiAqIEB0c3R5cGUgJHByb3RvYnVmLlR5cGVcbiAqL1xuXG4vKipcbiAqIFJlZmxlY3RlZCBzZXJ2aWNlIG9wdGlvbnMuXG4gKiBAbmFtZSBTZXJ2aWNlT3B0aW9uc1xuICogQHR5cGUge1R5cGV9XG4gKiBAY29uc3RcbiAqIEB0c3R5cGUgJHByb3RvYnVmLlR5cGVcbiAqL1xuXG4vKipcbiAqIFJlZmxlY3RlZCBtZXRob2Qgb3B0aW9ucy5cbiAqIEBuYW1lIE1ldGhvZE9wdGlvbnNcbiAqIEB0eXBlIHtUeXBlfVxuICogQGNvbnN0XG4gKiBAdHN0eXBlICRwcm90b2J1Zi5UeXBlXG4gKi9cblxuLyoqXG4gKiBSZWZsZWN0ZWQgdW5pbnRlcnByZXRldCBvcHRpb24uXG4gKiBAbmFtZSBVbmludGVycHJldGVkT3B0aW9uXG4gKiBAdHlwZSB7VHlwZX1cbiAqIEBwcm9wZXJ0eSB7VHlwZX0gTmFtZVBhcnRcbiAqIEBjb25zdFxuICogQHRzdHlwZSAkcHJvdG9idWYuVHlwZSAmIHtcbiAqICAgICBOYW1lUGFydDogJHByb3RvYnVmLlR5cGVcbiAqIH1cbiAqL1xuXG4vKipcbiAqIFJlZmxlY3RlZCBzb3VyY2UgY29kZSBpbmZvLlxuICogQG5hbWUgU291cmNlQ29kZUluZm9cbiAqIEB0eXBlIHtUeXBlfVxuICogQHByb3BlcnR5IHtUeXBlfSBMb2NhdGlvblxuICogQGNvbnN0XG4gKiBAdHN0eXBlICRwcm90b2J1Zi5UeXBlICYge1xuICogICAgIExvY2F0aW9uOiAkcHJvdG9idWYuVHlwZVxuICogfVxuICovXG5cbi8qKlxuICogUmVmbGVjdGVkIGdlbmVyYXRlZCBjb2RlIGluZm8uXG4gKiBAbmFtZSBHZW5lcmF0ZWRDb2RlSW5mb1xuICogQHR5cGUge1R5cGV9XG4gKiBAcHJvcGVydHkge1R5cGV9IEFubm90YXRpb25cbiAqIEBjb25zdFxuICogQHRzdHlwZSAkcHJvdG9idWYuVHlwZSAmIHtcbiAqICAgICBBbm5vdGF0aW9uOiAkcHJvdG9idWYuVHlwZVxuICogfVxuICovXG4iXSwibmFtZXMiOlsiJHByb3RvYnVmIiwicmVxdWlyZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJkZXNjcmlwdG9yIiwiUm9vdCIsImZyb21KU09OIiwibG9va3VwIiwiTmFtZXNwYWNlIiwiRW51bSIsIlR5cGUiLCJGaWVsZCIsIk1hcEZpZWxkIiwiT25lT2YiLCJTZXJ2aWNlIiwiTWV0aG9kIiwiZnJvbURlc2NyaXB0b3IiLCJsZW5ndGgiLCJGaWxlRGVzY3JpcHRvclNldCIsImRlY29kZSIsInJvb3QiLCJmaWxlIiwiZmlsZURlc2NyaXB0b3IiLCJmaWxlUGFja2FnZSIsImoiLCJpIiwiZGVmaW5lIiwibmFtZSIsImZpbGVzIiwicHVzaCIsImZpbGVuYW1lIiwibWVzc2FnZVR5cGUiLCJhZGQiLCJzeW50YXgiLCJlbnVtVHlwZSIsImV4dGVuc2lvbiIsInNlcnZpY2UiLCJvcHRzIiwiZnJvbURlc2NyaXB0b3JPcHRpb25zIiwib3B0aW9ucyIsIkZpbGVPcHRpb25zIiwia3MiLCJPYmplY3QiLCJrZXlzIiwic2V0T3B0aW9uIiwicHJvdG90eXBlIiwidG9EZXNjcmlwdG9yIiwic2V0IiwiY3JlYXRlIiwiUm9vdF90b0Rlc2NyaXB0b3JSZWN1cnNpdmUiLCJucyIsIkZpbGVEZXNjcmlwdG9yUHJvdG8iLCJmdWxsTmFtZSIsInN1YnN0cmluZyIsInJlcGxhY2UiLCJuZXN0ZWQiLCJuZXN0ZWRBcnJheSIsIl9uZXN0ZWRBcnJheSIsInRvRGVzY3JpcHRvck9wdGlvbnMiLCJ1bm5hbWVkTWVzc2FnZUluZGV4IiwiRGVzY3JpcHRvclByb3RvIiwidHlwZSIsIk1lc3NhZ2VPcHRpb25zIiwib25lb2ZEZWNsIiwiZmllbGQiLCJoYXNPd25Qcm9wZXJ0eSIsIm9uZW9mc0FycmF5Iiwib25lb2ZJbmRleCIsIm5lc3RlZFR5cGUiLCJtYXBFbnRyeSIsImV4dGVuc2lvblJhbmdlIiwiZXh0ZW5zaW9ucyIsInN0YXJ0IiwiZW5kIiwicmVzZXJ2ZWRSYW5nZSIsInJlc2VydmVkTmFtZSIsInJlc2VydmVkIiwiZmllbGRzQXJyYXkiLCJmaWVsZERlc2NyaXB0b3IiLCJfZmllbGRzQXJyYXkiLCJrZXlUeXBlIiwidG9EZXNjcmlwdG9yVHlwZSIsInJlc29sdmVkS2V5VHlwZSIsInZhbHVlVHlwZSIsInJlc29sdmVkVHlwZSIsInZhbHVlVHlwZU5hbWUiLCJzaG9ydG5hbWUiLCJwYXJlbnQiLCJ1bmRlZmluZWQiLCJ0eXBlTmFtZSIsIkZpZWxkRGVzY3JpcHRvclByb3RvIiwibnVtYmVyIiwibGFiZWwiLCJfb25lb2ZzQXJyYXkiLCJFeHRlbnNpb25SYW5nZSIsIlJlc2VydmVkUmFuZ2UiLCJudW1iZXJSZSIsIkVycm9yIiwiZmllbGRUeXBlIiwiZnJvbURlc2NyaXB0b3JUeXBlIiwiZmllbGRSdWxlIiwiZXh0ZW5kZWUiLCJGaWVsZE9wdGlvbnMiLCJkZWZhdWx0VmFsdWUiLCJtYXRjaCIsImV4ZWMiLCJwYXJzZUludCIsInBhY2thYmxlRGVzY3JpcHRvclR5cGUiLCJwYWNrZWQiLCJpZCIsIm1hcCIsInV0aWwiLCJ1Y0ZpcnN0IiwicmVzb2x2ZSIsInJ1bGUiLCJleHRlbnNpb25GaWVsZCIsImV4dGVuZCIsInBhcnRPZiIsImluZGV4T2YiLCJTdHJpbmciLCJ1bm5hbWVkRW51bUluZGV4IiwiRW51bURlc2NyaXB0b3JQcm90byIsInZhbHVlcyIsInZhbHVlIiwiRW51bU9wdGlvbnMiLCJFbnVtVmFsdWVEZXNjcmlwdG9yUHJvdG8iLCJ1bm5hbWVkT25lb2ZJbmRleCIsIk9uZW9mRGVzY3JpcHRvclByb3RvIiwidW5uYW1lZFNlcnZpY2VJbmRleCIsIlNlcnZpY2VEZXNjcmlwdG9yUHJvdG8iLCJTZXJ2aWNlT3B0aW9ucyIsIm1ldGhvZCIsIm1ldGhvZHMiLCJtZXRob2RzQXJyYXkiLCJfbWV0aG9kc0FycmF5IiwidW5uYW1lZE1ldGhvZEluZGV4IiwiTWV0aG9kRGVzY3JpcHRvclByb3RvIiwiaW5wdXRUeXBlIiwib3V0cHV0VHlwZSIsIkJvb2xlYW4iLCJjbGllbnRTdHJlYW1pbmciLCJzZXJ2ZXJTdHJlYW1pbmciLCJNZXRob2RPcHRpb25zIiwicmVzb2x2ZWRSZXF1ZXN0VHlwZSIsInJlcXVlc3RUeXBlIiwicmVzb2x2ZWRSZXNwb25zZVR5cGUiLCJyZXNwb25zZVR5cGUiLCJyZXF1ZXN0U3RyZWFtIiwicmVzcG9uc2VTdHJlYW0iLCJncm91cCIsIm91dCIsImtleSIsInZhbCIsInZhbHVlc0J5SWQiLCJ1bmRlclNjb3JlIiwidG9PYmplY3QiLCJmaWVsZHMiLCJjYW1lbENhc2UiLCJmcm9tT2JqZWN0IiwiZnJvbSIsInRvIiwiZnJvbVBhdGgiLCJzcGxpdCIsInRvUGF0aCIsImsiLCJvdGhlciIsInNsaWNlIiwiam9pbiIsInN0ciIsIiQwIiwiJDEiLCJ0b0xvd2VyQ2FzZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/protobufjs/ext/descriptor/index.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/index.js":
/*!*******************************************!*\
  !*** ../node_modules/protobufjs/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// full library entry point.\n\nmodule.exports = __webpack_require__(/*! ./src/index */ \"(ssr)/../node_modules/protobufjs/src/index.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUEsNEJBQTRCO0FBRWY7QUFDYkEsd0dBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL2luZGV4LmpzPzFhZmIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZnVsbCBsaWJyYXJ5IGVudHJ5IHBvaW50LlxuXG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vc3JjL2luZGV4XCIpO1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/protobufjs/index.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/src/common.js":
/*!************************************************!*\
  !*** ../node_modules/protobufjs/src/common.js ***!
  \************************************************/
/***/ ((module) => {

eval("\nmodule.exports = common;\nvar commonRe = /\\/|\\./;\n/**\n * Provides common type definitions.\n * Can also be used to provide additional google types or your own custom types.\n * @param {string} name Short name as in `google/protobuf/[name].proto` or full file name\n * @param {Object.<string,*>} json JSON definition within `google.protobuf` if a short name, otherwise the file's root definition\n * @returns {undefined}\n * @property {INamespace} google/protobuf/any.proto Any\n * @property {INamespace} google/protobuf/duration.proto Duration\n * @property {INamespace} google/protobuf/empty.proto Empty\n * @property {INamespace} google/protobuf/field_mask.proto FieldMask\n * @property {INamespace} google/protobuf/struct.proto Struct, Value, NullValue and ListValue\n * @property {INamespace} google/protobuf/timestamp.proto Timestamp\n * @property {INamespace} google/protobuf/wrappers.proto Wrappers\n * @example\n * // manually provides descriptor.proto (assumes google/protobuf/ namespace and .proto extension)\n * protobuf.common(\"descriptor\", descriptorJson);\n *\n * // manually provides a custom definition (uses my.foo namespace)\n * protobuf.common(\"my/foo/bar.proto\", myFooBarJson);\n */ function common(name, json) {\n    if (!commonRe.test(name)) {\n        name = \"google/protobuf/\" + name + \".proto\";\n        json = {\n            nested: {\n                google: {\n                    nested: {\n                        protobuf: {\n                            nested: json\n                        }\n                    }\n                }\n            }\n        };\n    }\n    common[name] = json;\n}\n// Not provided because of limited use (feel free to discuss or to provide yourself):\n//\n// google/protobuf/descriptor.proto\n// google/protobuf/source_context.proto\n// google/protobuf/type.proto\n//\n// Stripped and pre-parsed versions of these non-bundled files are instead available as part of\n// the repository or package within the google/protobuf directory.\ncommon(\"any\", {\n    /**\n     * Properties of a google.protobuf.Any message.\n     * @interface IAny\n     * @type {Object}\n     * @property {string} [typeUrl]\n     * @property {Uint8Array} [bytes]\n     * @memberof common\n     */ Any: {\n        fields: {\n            type_url: {\n                type: \"string\",\n                id: 1\n            },\n            value: {\n                type: \"bytes\",\n                id: 2\n            }\n        }\n    }\n});\nvar timeType;\ncommon(\"duration\", {\n    /**\n     * Properties of a google.protobuf.Duration message.\n     * @interface IDuration\n     * @type {Object}\n     * @property {number|Long} [seconds]\n     * @property {number} [nanos]\n     * @memberof common\n     */ Duration: timeType = {\n        fields: {\n            seconds: {\n                type: \"int64\",\n                id: 1\n            },\n            nanos: {\n                type: \"int32\",\n                id: 2\n            }\n        }\n    }\n});\ncommon(\"timestamp\", {\n    /**\n     * Properties of a google.protobuf.Timestamp message.\n     * @interface ITimestamp\n     * @type {Object}\n     * @property {number|Long} [seconds]\n     * @property {number} [nanos]\n     * @memberof common\n     */ Timestamp: timeType\n});\ncommon(\"empty\", {\n    /**\n     * Properties of a google.protobuf.Empty message.\n     * @interface IEmpty\n     * @memberof common\n     */ Empty: {\n        fields: {}\n    }\n});\ncommon(\"struct\", {\n    /**\n     * Properties of a google.protobuf.Struct message.\n     * @interface IStruct\n     * @type {Object}\n     * @property {Object.<string,IValue>} [fields]\n     * @memberof common\n     */ Struct: {\n        fields: {\n            fields: {\n                keyType: \"string\",\n                type: \"Value\",\n                id: 1\n            }\n        }\n    },\n    /**\n     * Properties of a google.protobuf.Value message.\n     * @interface IValue\n     * @type {Object}\n     * @property {string} [kind]\n     * @property {0} [nullValue]\n     * @property {number} [numberValue]\n     * @property {string} [stringValue]\n     * @property {boolean} [boolValue]\n     * @property {IStruct} [structValue]\n     * @property {IListValue} [listValue]\n     * @memberof common\n     */ Value: {\n        oneofs: {\n            kind: {\n                oneof: [\n                    \"nullValue\",\n                    \"numberValue\",\n                    \"stringValue\",\n                    \"boolValue\",\n                    \"structValue\",\n                    \"listValue\"\n                ]\n            }\n        },\n        fields: {\n            nullValue: {\n                type: \"NullValue\",\n                id: 1\n            },\n            numberValue: {\n                type: \"double\",\n                id: 2\n            },\n            stringValue: {\n                type: \"string\",\n                id: 3\n            },\n            boolValue: {\n                type: \"bool\",\n                id: 4\n            },\n            structValue: {\n                type: \"Struct\",\n                id: 5\n            },\n            listValue: {\n                type: \"ListValue\",\n                id: 6\n            }\n        }\n    },\n    NullValue: {\n        values: {\n            NULL_VALUE: 0\n        }\n    },\n    /**\n     * Properties of a google.protobuf.ListValue message.\n     * @interface IListValue\n     * @type {Object}\n     * @property {Array.<IValue>} [values]\n     * @memberof common\n     */ ListValue: {\n        fields: {\n            values: {\n                rule: \"repeated\",\n                type: \"Value\",\n                id: 1\n            }\n        }\n    }\n});\ncommon(\"wrappers\", {\n    /**\n     * Properties of a google.protobuf.DoubleValue message.\n     * @interface IDoubleValue\n     * @type {Object}\n     * @property {number} [value]\n     * @memberof common\n     */ DoubleValue: {\n        fields: {\n            value: {\n                type: \"double\",\n                id: 1\n            }\n        }\n    },\n    /**\n     * Properties of a google.protobuf.FloatValue message.\n     * @interface IFloatValue\n     * @type {Object}\n     * @property {number} [value]\n     * @memberof common\n     */ FloatValue: {\n        fields: {\n            value: {\n                type: \"float\",\n                id: 1\n            }\n        }\n    },\n    /**\n     * Properties of a google.protobuf.Int64Value message.\n     * @interface IInt64Value\n     * @type {Object}\n     * @property {number|Long} [value]\n     * @memberof common\n     */ Int64Value: {\n        fields: {\n            value: {\n                type: \"int64\",\n                id: 1\n            }\n        }\n    },\n    /**\n     * Properties of a google.protobuf.UInt64Value message.\n     * @interface IUInt64Value\n     * @type {Object}\n     * @property {number|Long} [value]\n     * @memberof common\n     */ UInt64Value: {\n        fields: {\n            value: {\n                type: \"uint64\",\n                id: 1\n            }\n        }\n    },\n    /**\n     * Properties of a google.protobuf.Int32Value message.\n     * @interface IInt32Value\n     * @type {Object}\n     * @property {number} [value]\n     * @memberof common\n     */ Int32Value: {\n        fields: {\n            value: {\n                type: \"int32\",\n                id: 1\n            }\n        }\n    },\n    /**\n     * Properties of a google.protobuf.UInt32Value message.\n     * @interface IUInt32Value\n     * @type {Object}\n     * @property {number} [value]\n     * @memberof common\n     */ UInt32Value: {\n        fields: {\n            value: {\n                type: \"uint32\",\n                id: 1\n            }\n        }\n    },\n    /**\n     * Properties of a google.protobuf.BoolValue message.\n     * @interface IBoolValue\n     * @type {Object}\n     * @property {boolean} [value]\n     * @memberof common\n     */ BoolValue: {\n        fields: {\n            value: {\n                type: \"bool\",\n                id: 1\n            }\n        }\n    },\n    /**\n     * Properties of a google.protobuf.StringValue message.\n     * @interface IStringValue\n     * @type {Object}\n     * @property {string} [value]\n     * @memberof common\n     */ StringValue: {\n        fields: {\n            value: {\n                type: \"string\",\n                id: 1\n            }\n        }\n    },\n    /**\n     * Properties of a google.protobuf.BytesValue message.\n     * @interface IBytesValue\n     * @type {Object}\n     * @property {Uint8Array} [value]\n     * @memberof common\n     */ BytesValue: {\n        fields: {\n            value: {\n                type: \"bytes\",\n                id: 1\n            }\n        }\n    }\n});\ncommon(\"field_mask\", {\n    /**\n     * Properties of a google.protobuf.FieldMask message.\n     * @interface IDoubleValue\n     * @type {Object}\n     * @property {number} [value]\n     * @memberof common\n     */ FieldMask: {\n        fields: {\n            paths: {\n                rule: \"repeated\",\n                type: \"string\",\n                id: 1\n            }\n        }\n    }\n});\n/**\n * Gets the root definition of the specified common proto file.\n *\n * Bundled definitions are:\n * - google/protobuf/any.proto\n * - google/protobuf/duration.proto\n * - google/protobuf/empty.proto\n * - google/protobuf/field_mask.proto\n * - google/protobuf/struct.proto\n * - google/protobuf/timestamp.proto\n * - google/protobuf/wrappers.proto\n *\n * @param {string} file Proto file name\n * @returns {INamespace|null} Root definition or `null` if not defined\n */ common.get = function get(file) {\n    return common[file] || null;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL2NvbW1vbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSxPQUFPQyxPQUFPLEdBQUdDO0FBRWpCLElBQUlDLFdBQVc7QUFFZjs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW1CQyxHQUNELFNBQVNELE9BQU9FLElBQUksRUFBRUMsSUFBSTtJQUN0QixJQUFJLENBQUNGLFNBQVNHLElBQUksQ0FBQ0YsT0FBTztRQUN0QkEsT0FBTyxxQkFBcUJBLE9BQU87UUFDbkNDLE9BQU87WUFBRUUsUUFBUTtnQkFBRUMsUUFBUTtvQkFBRUQsUUFBUTt3QkFBRUUsVUFBVTs0QkFBRUYsUUFBUUY7d0JBQUs7b0JBQUU7Z0JBQUU7WUFBRTtRQUFFO0lBQzVFO0lBQ0FILE1BQU0sQ0FBQ0UsS0FBSyxHQUFHQztBQUNuQjtBQUVBLHFGQUFxRjtBQUNyRixFQUFFO0FBQ0YsbUNBQW1DO0FBQ25DLHVDQUF1QztBQUN2Qyw2QkFBNkI7QUFDN0IsRUFBRTtBQUNGLCtGQUErRjtBQUMvRixrRUFBa0U7QUFFbEVILE9BQU8sT0FBTztJQUVWOzs7Ozs7O0tBT0MsR0FDRFEsS0FBSztRQUNEQyxRQUFRO1lBQ0pDLFVBQVU7Z0JBQ05DLE1BQU07Z0JBQ05DLElBQUk7WUFDUjtZQUNBQyxPQUFPO2dCQUNIRixNQUFNO2dCQUNOQyxJQUFJO1lBQ1I7UUFDSjtJQUNKO0FBQ0o7QUFFQSxJQUFJRTtBQUVKZCxPQUFPLFlBQVk7SUFFZjs7Ozs7OztLQU9DLEdBQ0RlLFVBQVVELFdBQVc7UUFDakJMLFFBQVE7WUFDSk8sU0FBUztnQkFDTEwsTUFBTTtnQkFDTkMsSUFBSTtZQUNSO1lBQ0FLLE9BQU87Z0JBQ0hOLE1BQU07Z0JBQ05DLElBQUk7WUFDUjtRQUNKO0lBQ0o7QUFDSjtBQUVBWixPQUFPLGFBQWE7SUFFaEI7Ozs7Ozs7S0FPQyxHQUNEa0IsV0FBV0o7QUFDZjtBQUVBZCxPQUFPLFNBQVM7SUFFWjs7OztLQUlDLEdBQ0RtQixPQUFPO1FBQ0hWLFFBQVEsQ0FBQztJQUNiO0FBQ0o7QUFFQVQsT0FBTyxVQUFVO0lBRWI7Ozs7OztLQU1DLEdBQ0RvQixRQUFRO1FBQ0pYLFFBQVE7WUFDSkEsUUFBUTtnQkFDSlksU0FBUztnQkFDVFYsTUFBTTtnQkFDTkMsSUFBSTtZQUNSO1FBQ0o7SUFDSjtJQUVBOzs7Ozs7Ozs7Ozs7S0FZQyxHQUNEVSxPQUFPO1FBQ0hDLFFBQVE7WUFDSkMsTUFBTTtnQkFDRkMsT0FBTztvQkFDSDtvQkFDQTtvQkFDQTtvQkFDQTtvQkFDQTtvQkFDQTtpQkFDSDtZQUNMO1FBQ0o7UUFDQWhCLFFBQVE7WUFDSmlCLFdBQVc7Z0JBQ1BmLE1BQU07Z0JBQ05DLElBQUk7WUFDUjtZQUNBZSxhQUFhO2dCQUNUaEIsTUFBTTtnQkFDTkMsSUFBSTtZQUNSO1lBQ0FnQixhQUFhO2dCQUNUakIsTUFBTTtnQkFDTkMsSUFBSTtZQUNSO1lBQ0FpQixXQUFXO2dCQUNQbEIsTUFBTTtnQkFDTkMsSUFBSTtZQUNSO1lBQ0FrQixhQUFhO2dCQUNUbkIsTUFBTTtnQkFDTkMsSUFBSTtZQUNSO1lBQ0FtQixXQUFXO2dCQUNQcEIsTUFBTTtnQkFDTkMsSUFBSTtZQUNSO1FBQ0o7SUFDSjtJQUVBb0IsV0FBVztRQUNQQyxRQUFRO1lBQ0pDLFlBQVk7UUFDaEI7SUFDSjtJQUVBOzs7Ozs7S0FNQyxHQUNEQyxXQUFXO1FBQ1AxQixRQUFRO1lBQ0p3QixRQUFRO2dCQUNKRyxNQUFNO2dCQUNOekIsTUFBTTtnQkFDTkMsSUFBSTtZQUNSO1FBQ0o7SUFDSjtBQUNKO0FBRUFaLE9BQU8sWUFBWTtJQUVmOzs7Ozs7S0FNQyxHQUNEcUMsYUFBYTtRQUNUNUIsUUFBUTtZQUNKSSxPQUFPO2dCQUNIRixNQUFNO2dCQUNOQyxJQUFJO1lBQ1I7UUFDSjtJQUNKO0lBRUE7Ozs7OztLQU1DLEdBQ0QwQixZQUFZO1FBQ1I3QixRQUFRO1lBQ0pJLE9BQU87Z0JBQ0hGLE1BQU07Z0JBQ05DLElBQUk7WUFDUjtRQUNKO0lBQ0o7SUFFQTs7Ozs7O0tBTUMsR0FDRDJCLFlBQVk7UUFDUjlCLFFBQVE7WUFDSkksT0FBTztnQkFDSEYsTUFBTTtnQkFDTkMsSUFBSTtZQUNSO1FBQ0o7SUFDSjtJQUVBOzs7Ozs7S0FNQyxHQUNENEIsYUFBYTtRQUNUL0IsUUFBUTtZQUNKSSxPQUFPO2dCQUNIRixNQUFNO2dCQUNOQyxJQUFJO1lBQ1I7UUFDSjtJQUNKO0lBRUE7Ozs7OztLQU1DLEdBQ0Q2QixZQUFZO1FBQ1JoQyxRQUFRO1lBQ0pJLE9BQU87Z0JBQ0hGLE1BQU07Z0JBQ05DLElBQUk7WUFDUjtRQUNKO0lBQ0o7SUFFQTs7Ozs7O0tBTUMsR0FDRDhCLGFBQWE7UUFDVGpDLFFBQVE7WUFDSkksT0FBTztnQkFDSEYsTUFBTTtnQkFDTkMsSUFBSTtZQUNSO1FBQ0o7SUFDSjtJQUVBOzs7Ozs7S0FNQyxHQUNEK0IsV0FBVztRQUNQbEMsUUFBUTtZQUNKSSxPQUFPO2dCQUNIRixNQUFNO2dCQUNOQyxJQUFJO1lBQ1I7UUFDSjtJQUNKO0lBRUE7Ozs7OztLQU1DLEdBQ0RnQyxhQUFhO1FBQ1RuQyxRQUFRO1lBQ0pJLE9BQU87Z0JBQ0hGLE1BQU07Z0JBQ05DLElBQUk7WUFDUjtRQUNKO0lBQ0o7SUFFQTs7Ozs7O0tBTUMsR0FDRGlDLFlBQVk7UUFDUnBDLFFBQVE7WUFDSkksT0FBTztnQkFDSEYsTUFBTTtnQkFDTkMsSUFBSTtZQUNSO1FBQ0o7SUFDSjtBQUNKO0FBRUFaLE9BQU8sY0FBYztJQUVqQjs7Ozs7O0tBTUMsR0FDRDhDLFdBQVc7UUFDUHJDLFFBQVE7WUFDSnNDLE9BQU87Z0JBQ0hYLE1BQU07Z0JBQ056QixNQUFNO2dCQUNOQyxJQUFJO1lBQ1I7UUFDSjtJQUNKO0FBQ0o7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Q0FjQyxHQUNEWixPQUFPZ0QsR0FBRyxHQUFHLFNBQVNBLElBQUlDLElBQUk7SUFDMUIsT0FBT2pELE1BQU0sQ0FBQ2lELEtBQUssSUFBSTtBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvY29tbW9uLmpzP2IyZDUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGNvbW1vbjtcblxudmFyIGNvbW1vblJlID0gL1xcL3xcXC4vO1xuXG4vKipcbiAqIFByb3ZpZGVzIGNvbW1vbiB0eXBlIGRlZmluaXRpb25zLlxuICogQ2FuIGFsc28gYmUgdXNlZCB0byBwcm92aWRlIGFkZGl0aW9uYWwgZ29vZ2xlIHR5cGVzIG9yIHlvdXIgb3duIGN1c3RvbSB0eXBlcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFNob3J0IG5hbWUgYXMgaW4gYGdvb2dsZS9wcm90b2J1Zi9bbmFtZV0ucHJvdG9gIG9yIGZ1bGwgZmlsZSBuYW1lXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBqc29uIEpTT04gZGVmaW5pdGlvbiB3aXRoaW4gYGdvb2dsZS5wcm90b2J1ZmAgaWYgYSBzaG9ydCBuYW1lLCBvdGhlcndpc2UgdGhlIGZpbGUncyByb290IGRlZmluaXRpb25cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiBAcHJvcGVydHkge0lOYW1lc3BhY2V9IGdvb2dsZS9wcm90b2J1Zi9hbnkucHJvdG8gQW55XG4gKiBAcHJvcGVydHkge0lOYW1lc3BhY2V9IGdvb2dsZS9wcm90b2J1Zi9kdXJhdGlvbi5wcm90byBEdXJhdGlvblxuICogQHByb3BlcnR5IHtJTmFtZXNwYWNlfSBnb29nbGUvcHJvdG9idWYvZW1wdHkucHJvdG8gRW1wdHlcbiAqIEBwcm9wZXJ0eSB7SU5hbWVzcGFjZX0gZ29vZ2xlL3Byb3RvYnVmL2ZpZWxkX21hc2sucHJvdG8gRmllbGRNYXNrXG4gKiBAcHJvcGVydHkge0lOYW1lc3BhY2V9IGdvb2dsZS9wcm90b2J1Zi9zdHJ1Y3QucHJvdG8gU3RydWN0LCBWYWx1ZSwgTnVsbFZhbHVlIGFuZCBMaXN0VmFsdWVcbiAqIEBwcm9wZXJ0eSB7SU5hbWVzcGFjZX0gZ29vZ2xlL3Byb3RvYnVmL3RpbWVzdGFtcC5wcm90byBUaW1lc3RhbXBcbiAqIEBwcm9wZXJ0eSB7SU5hbWVzcGFjZX0gZ29vZ2xlL3Byb3RvYnVmL3dyYXBwZXJzLnByb3RvIFdyYXBwZXJzXG4gKiBAZXhhbXBsZVxuICogLy8gbWFudWFsbHkgcHJvdmlkZXMgZGVzY3JpcHRvci5wcm90byAoYXNzdW1lcyBnb29nbGUvcHJvdG9idWYvIG5hbWVzcGFjZSBhbmQgLnByb3RvIGV4dGVuc2lvbilcbiAqIHByb3RvYnVmLmNvbW1vbihcImRlc2NyaXB0b3JcIiwgZGVzY3JpcHRvckpzb24pO1xuICpcbiAqIC8vIG1hbnVhbGx5IHByb3ZpZGVzIGEgY3VzdG9tIGRlZmluaXRpb24gKHVzZXMgbXkuZm9vIG5hbWVzcGFjZSlcbiAqIHByb3RvYnVmLmNvbW1vbihcIm15L2Zvby9iYXIucHJvdG9cIiwgbXlGb29CYXJKc29uKTtcbiAqL1xuZnVuY3Rpb24gY29tbW9uKG5hbWUsIGpzb24pIHtcbiAgICBpZiAoIWNvbW1vblJlLnRlc3QobmFtZSkpIHtcbiAgICAgICAgbmFtZSA9IFwiZ29vZ2xlL3Byb3RvYnVmL1wiICsgbmFtZSArIFwiLnByb3RvXCI7XG4gICAgICAgIGpzb24gPSB7IG5lc3RlZDogeyBnb29nbGU6IHsgbmVzdGVkOiB7IHByb3RvYnVmOiB7IG5lc3RlZDoganNvbiB9IH0gfSB9IH07XG4gICAgfVxuICAgIGNvbW1vbltuYW1lXSA9IGpzb247XG59XG5cbi8vIE5vdCBwcm92aWRlZCBiZWNhdXNlIG9mIGxpbWl0ZWQgdXNlIChmZWVsIGZyZWUgdG8gZGlzY3VzcyBvciB0byBwcm92aWRlIHlvdXJzZWxmKTpcbi8vXG4vLyBnb29nbGUvcHJvdG9idWYvZGVzY3JpcHRvci5wcm90b1xuLy8gZ29vZ2xlL3Byb3RvYnVmL3NvdXJjZV9jb250ZXh0LnByb3RvXG4vLyBnb29nbGUvcHJvdG9idWYvdHlwZS5wcm90b1xuLy9cbi8vIFN0cmlwcGVkIGFuZCBwcmUtcGFyc2VkIHZlcnNpb25zIG9mIHRoZXNlIG5vbi1idW5kbGVkIGZpbGVzIGFyZSBpbnN0ZWFkIGF2YWlsYWJsZSBhcyBwYXJ0IG9mXG4vLyB0aGUgcmVwb3NpdG9yeSBvciBwYWNrYWdlIHdpdGhpbiB0aGUgZ29vZ2xlL3Byb3RvYnVmIGRpcmVjdG9yeS5cblxuY29tbW9uKFwiYW55XCIsIHtcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnRpZXMgb2YgYSBnb29nbGUucHJvdG9idWYuQW55IG1lc3NhZ2UuXG4gICAgICogQGludGVyZmFjZSBJQW55XG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3R5cGVVcmxdXG4gICAgICogQHByb3BlcnR5IHtVaW50OEFycmF5fSBbYnl0ZXNdXG4gICAgICogQG1lbWJlcm9mIGNvbW1vblxuICAgICAqL1xuICAgIEFueToge1xuICAgICAgICBmaWVsZHM6IHtcbiAgICAgICAgICAgIHR5cGVfdXJsOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICBpZDogMVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJieXRlc1wiLFxuICAgICAgICAgICAgICAgIGlkOiAyXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxudmFyIHRpbWVUeXBlO1xuXG5jb21tb24oXCJkdXJhdGlvblwiLCB7XG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uIG1lc3NhZ2UuXG4gICAgICogQGludGVyZmFjZSBJRHVyYXRpb25cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfExvbmd9IFtzZWNvbmRzXVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbmFub3NdXG4gICAgICogQG1lbWJlcm9mIGNvbW1vblxuICAgICAqL1xuICAgIER1cmF0aW9uOiB0aW1lVHlwZSA9IHtcbiAgICAgICAgZmllbGRzOiB7XG4gICAgICAgICAgICBzZWNvbmRzOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJpbnQ2NFwiLFxuICAgICAgICAgICAgICAgIGlkOiAxXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmFub3M6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImludDMyXCIsXG4gICAgICAgICAgICAgICAgaWQ6IDJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5jb21tb24oXCJ0aW1lc3RhbXBcIiwge1xuXG4gICAgLyoqXG4gICAgICogUHJvcGVydGllcyBvZiBhIGdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAgbWVzc2FnZS5cbiAgICAgKiBAaW50ZXJmYWNlIElUaW1lc3RhbXBcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfExvbmd9IFtzZWNvbmRzXVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbmFub3NdXG4gICAgICogQG1lbWJlcm9mIGNvbW1vblxuICAgICAqL1xuICAgIFRpbWVzdGFtcDogdGltZVR5cGVcbn0pO1xuXG5jb21tb24oXCJlbXB0eVwiLCB7XG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgZ29vZ2xlLnByb3RvYnVmLkVtcHR5IG1lc3NhZ2UuXG4gICAgICogQGludGVyZmFjZSBJRW1wdHlcbiAgICAgKiBAbWVtYmVyb2YgY29tbW9uXG4gICAgICovXG4gICAgRW1wdHk6IHtcbiAgICAgICAgZmllbGRzOiB7fVxuICAgIH1cbn0pO1xuXG5jb21tb24oXCJzdHJ1Y3RcIiwge1xuXG4gICAgLyoqXG4gICAgICogUHJvcGVydGllcyBvZiBhIGdvb2dsZS5wcm90b2J1Zi5TdHJ1Y3QgbWVzc2FnZS5cbiAgICAgKiBAaW50ZXJmYWNlIElTdHJ1Y3RcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsSVZhbHVlPn0gW2ZpZWxkc11cbiAgICAgKiBAbWVtYmVyb2YgY29tbW9uXG4gICAgICovXG4gICAgU3RydWN0OiB7XG4gICAgICAgIGZpZWxkczoge1xuICAgICAgICAgICAgZmllbGRzOiB7XG4gICAgICAgICAgICAgICAga2V5VHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICB0eXBlOiBcIlZhbHVlXCIsXG4gICAgICAgICAgICAgICAgaWQ6IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgZ29vZ2xlLnByb3RvYnVmLlZhbHVlIG1lc3NhZ2UuXG4gICAgICogQGludGVyZmFjZSBJVmFsdWVcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBba2luZF1cbiAgICAgKiBAcHJvcGVydHkgezB9IFtudWxsVmFsdWVdXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFtudW1iZXJWYWx1ZV1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3N0cmluZ1ZhbHVlXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2Jvb2xWYWx1ZV1cbiAgICAgKiBAcHJvcGVydHkge0lTdHJ1Y3R9IFtzdHJ1Y3RWYWx1ZV1cbiAgICAgKiBAcHJvcGVydHkge0lMaXN0VmFsdWV9IFtsaXN0VmFsdWVdXG4gICAgICogQG1lbWJlcm9mIGNvbW1vblxuICAgICAqL1xuICAgIFZhbHVlOiB7XG4gICAgICAgIG9uZW9mczoge1xuICAgICAgICAgICAga2luZDoge1xuICAgICAgICAgICAgICAgIG9uZW9mOiBbXG4gICAgICAgICAgICAgICAgICAgIFwibnVsbFZhbHVlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwibnVtYmVyVmFsdWVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzdHJpbmdWYWx1ZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImJvb2xWYWx1ZVwiLFxuICAgICAgICAgICAgICAgICAgICBcInN0cnVjdFZhbHVlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwibGlzdFZhbHVlXCJcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZpZWxkczoge1xuICAgICAgICAgICAgbnVsbFZhbHVlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJOdWxsVmFsdWVcIixcbiAgICAgICAgICAgICAgICBpZDogMVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG51bWJlclZhbHVlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJkb3VibGVcIixcbiAgICAgICAgICAgICAgICBpZDogMlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0cmluZ1ZhbHVlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICBpZDogM1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJvb2xWYWx1ZToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiYm9vbFwiLFxuICAgICAgICAgICAgICAgIGlkOiA0XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3RydWN0VmFsdWU6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIlN0cnVjdFwiLFxuICAgICAgICAgICAgICAgIGlkOiA1XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGlzdFZhbHVlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJMaXN0VmFsdWVcIixcbiAgICAgICAgICAgICAgICBpZDogNlxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIE51bGxWYWx1ZToge1xuICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgIE5VTExfVkFMVUU6IDBcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgZ29vZ2xlLnByb3RvYnVmLkxpc3RWYWx1ZSBtZXNzYWdlLlxuICAgICAqIEBpbnRlcmZhY2UgSUxpc3RWYWx1ZVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtBcnJheS48SVZhbHVlPn0gW3ZhbHVlc11cbiAgICAgKiBAbWVtYmVyb2YgY29tbW9uXG4gICAgICovXG4gICAgTGlzdFZhbHVlOiB7XG4gICAgICAgIGZpZWxkczoge1xuICAgICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICAgICAgcnVsZTogXCJyZXBlYXRlZFwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiVmFsdWVcIixcbiAgICAgICAgICAgICAgICBpZDogMVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSk7XG5cbmNvbW1vbihcIndyYXBwZXJzXCIsIHtcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnRpZXMgb2YgYSBnb29nbGUucHJvdG9idWYuRG91YmxlVmFsdWUgbWVzc2FnZS5cbiAgICAgKiBAaW50ZXJmYWNlIElEb3VibGVWYWx1ZVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFt2YWx1ZV1cbiAgICAgKiBAbWVtYmVyb2YgY29tbW9uXG4gICAgICovXG4gICAgRG91YmxlVmFsdWU6IHtcbiAgICAgICAgZmllbGRzOiB7XG4gICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZG91YmxlXCIsXG4gICAgICAgICAgICAgICAgaWQ6IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgZ29vZ2xlLnByb3RvYnVmLkZsb2F0VmFsdWUgbWVzc2FnZS5cbiAgICAgKiBAaW50ZXJmYWNlIElGbG9hdFZhbHVlXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gW3ZhbHVlXVxuICAgICAqIEBtZW1iZXJvZiBjb21tb25cbiAgICAgKi9cbiAgICBGbG9hdFZhbHVlOiB7XG4gICAgICAgIGZpZWxkczoge1xuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImZsb2F0XCIsXG4gICAgICAgICAgICAgICAgaWQ6IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgZ29vZ2xlLnByb3RvYnVmLkludDY0VmFsdWUgbWVzc2FnZS5cbiAgICAgKiBAaW50ZXJmYWNlIElJbnQ2NFZhbHVlXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge251bWJlcnxMb25nfSBbdmFsdWVdXG4gICAgICogQG1lbWJlcm9mIGNvbW1vblxuICAgICAqL1xuICAgIEludDY0VmFsdWU6IHtcbiAgICAgICAgZmllbGRzOiB7XG4gICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiaW50NjRcIixcbiAgICAgICAgICAgICAgICBpZDogMVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnRpZXMgb2YgYSBnb29nbGUucHJvdG9idWYuVUludDY0VmFsdWUgbWVzc2FnZS5cbiAgICAgKiBAaW50ZXJmYWNlIElVSW50NjRWYWx1ZVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ8TG9uZ30gW3ZhbHVlXVxuICAgICAqIEBtZW1iZXJvZiBjb21tb25cbiAgICAgKi9cbiAgICBVSW50NjRWYWx1ZToge1xuICAgICAgICBmaWVsZHM6IHtcbiAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ1aW50NjRcIixcbiAgICAgICAgICAgICAgICBpZDogMVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnRpZXMgb2YgYSBnb29nbGUucHJvdG9idWYuSW50MzJWYWx1ZSBtZXNzYWdlLlxuICAgICAqIEBpbnRlcmZhY2UgSUludDMyVmFsdWVcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdmFsdWVdXG4gICAgICogQG1lbWJlcm9mIGNvbW1vblxuICAgICAqL1xuICAgIEludDMyVmFsdWU6IHtcbiAgICAgICAgZmllbGRzOiB7XG4gICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiaW50MzJcIixcbiAgICAgICAgICAgICAgICBpZDogMVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnRpZXMgb2YgYSBnb29nbGUucHJvdG9idWYuVUludDMyVmFsdWUgbWVzc2FnZS5cbiAgICAgKiBAaW50ZXJmYWNlIElVSW50MzJWYWx1ZVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFt2YWx1ZV1cbiAgICAgKiBAbWVtYmVyb2YgY29tbW9uXG4gICAgICovXG4gICAgVUludDMyVmFsdWU6IHtcbiAgICAgICAgZmllbGRzOiB7XG4gICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidWludDMyXCIsXG4gICAgICAgICAgICAgICAgaWQ6IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgZ29vZ2xlLnByb3RvYnVmLkJvb2xWYWx1ZSBtZXNzYWdlLlxuICAgICAqIEBpbnRlcmZhY2UgSUJvb2xWYWx1ZVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbdmFsdWVdXG4gICAgICogQG1lbWJlcm9mIGNvbW1vblxuICAgICAqL1xuICAgIEJvb2xWYWx1ZToge1xuICAgICAgICBmaWVsZHM6IHtcbiAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJib29sXCIsXG4gICAgICAgICAgICAgICAgaWQ6IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgZ29vZ2xlLnByb3RvYnVmLlN0cmluZ1ZhbHVlIG1lc3NhZ2UuXG4gICAgICogQGludGVyZmFjZSBJU3RyaW5nVmFsdWVcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdmFsdWVdXG4gICAgICogQG1lbWJlcm9mIGNvbW1vblxuICAgICAqL1xuICAgIFN0cmluZ1ZhbHVlOiB7XG4gICAgICAgIGZpZWxkczoge1xuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgIGlkOiAxXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJvcGVydGllcyBvZiBhIGdvb2dsZS5wcm90b2J1Zi5CeXRlc1ZhbHVlIG1lc3NhZ2UuXG4gICAgICogQGludGVyZmFjZSBJQnl0ZXNWYWx1ZVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtVaW50OEFycmF5fSBbdmFsdWVdXG4gICAgICogQG1lbWJlcm9mIGNvbW1vblxuICAgICAqL1xuICAgIEJ5dGVzVmFsdWU6IHtcbiAgICAgICAgZmllbGRzOiB7XG4gICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiYnl0ZXNcIixcbiAgICAgICAgICAgICAgICBpZDogMVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSk7XG5cbmNvbW1vbihcImZpZWxkX21hc2tcIiwge1xuXG4gICAgLyoqXG4gICAgICogUHJvcGVydGllcyBvZiBhIGdvb2dsZS5wcm90b2J1Zi5GaWVsZE1hc2sgbWVzc2FnZS5cbiAgICAgKiBAaW50ZXJmYWNlIElEb3VibGVWYWx1ZVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFt2YWx1ZV1cbiAgICAgKiBAbWVtYmVyb2YgY29tbW9uXG4gICAgICovXG4gICAgRmllbGRNYXNrOiB7XG4gICAgICAgIGZpZWxkczoge1xuICAgICAgICAgICAgcGF0aHM6IHtcbiAgICAgICAgICAgICAgICBydWxlOiBcInJlcGVhdGVkXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICBpZDogMVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSk7XG5cbi8qKlxuICogR2V0cyB0aGUgcm9vdCBkZWZpbml0aW9uIG9mIHRoZSBzcGVjaWZpZWQgY29tbW9uIHByb3RvIGZpbGUuXG4gKlxuICogQnVuZGxlZCBkZWZpbml0aW9ucyBhcmU6XG4gKiAtIGdvb2dsZS9wcm90b2J1Zi9hbnkucHJvdG9cbiAqIC0gZ29vZ2xlL3Byb3RvYnVmL2R1cmF0aW9uLnByb3RvXG4gKiAtIGdvb2dsZS9wcm90b2J1Zi9lbXB0eS5wcm90b1xuICogLSBnb29nbGUvcHJvdG9idWYvZmllbGRfbWFzay5wcm90b1xuICogLSBnb29nbGUvcHJvdG9idWYvc3RydWN0LnByb3RvXG4gKiAtIGdvb2dsZS9wcm90b2J1Zi90aW1lc3RhbXAucHJvdG9cbiAqIC0gZ29vZ2xlL3Byb3RvYnVmL3dyYXBwZXJzLnByb3RvXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGZpbGUgUHJvdG8gZmlsZSBuYW1lXG4gKiBAcmV0dXJucyB7SU5hbWVzcGFjZXxudWxsfSBSb290IGRlZmluaXRpb24gb3IgYG51bGxgIGlmIG5vdCBkZWZpbmVkXG4gKi9cbmNvbW1vbi5nZXQgPSBmdW5jdGlvbiBnZXQoZmlsZSkge1xuICAgIHJldHVybiBjb21tb25bZmlsZV0gfHwgbnVsbDtcbn07XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsImNvbW1vbiIsImNvbW1vblJlIiwibmFtZSIsImpzb24iLCJ0ZXN0IiwibmVzdGVkIiwiZ29vZ2xlIiwicHJvdG9idWYiLCJBbnkiLCJmaWVsZHMiLCJ0eXBlX3VybCIsInR5cGUiLCJpZCIsInZhbHVlIiwidGltZVR5cGUiLCJEdXJhdGlvbiIsInNlY29uZHMiLCJuYW5vcyIsIlRpbWVzdGFtcCIsIkVtcHR5IiwiU3RydWN0Iiwia2V5VHlwZSIsIlZhbHVlIiwib25lb2ZzIiwia2luZCIsIm9uZW9mIiwibnVsbFZhbHVlIiwibnVtYmVyVmFsdWUiLCJzdHJpbmdWYWx1ZSIsImJvb2xWYWx1ZSIsInN0cnVjdFZhbHVlIiwibGlzdFZhbHVlIiwiTnVsbFZhbHVlIiwidmFsdWVzIiwiTlVMTF9WQUxVRSIsIkxpc3RWYWx1ZSIsInJ1bGUiLCJEb3VibGVWYWx1ZSIsIkZsb2F0VmFsdWUiLCJJbnQ2NFZhbHVlIiwiVUludDY0VmFsdWUiLCJJbnQzMlZhbHVlIiwiVUludDMyVmFsdWUiLCJCb29sVmFsdWUiLCJTdHJpbmdWYWx1ZSIsIkJ5dGVzVmFsdWUiLCJGaWVsZE1hc2siLCJwYXRocyIsImdldCIsImZpbGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/protobufjs/src/common.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/src/converter.js":
/*!***************************************************!*\
  !*** ../node_modules/protobufjs/src/converter.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Runtime message from/to plain object converters.\n * @namespace\n */ var converter = exports;\nvar Enum = __webpack_require__(/*! ./enum */ \"(ssr)/../node_modules/protobufjs/src/enum.js\"), util = __webpack_require__(/*! ./util */ \"(ssr)/../node_modules/protobufjs/src/util.js\");\n/**\n * Generates a partial value fromObject conveter.\n * @param {Codegen} gen Codegen instance\n * @param {Field} field Reflected field\n * @param {number} fieldIndex Field index\n * @param {string} prop Property reference\n * @returns {Codegen} Codegen instance\n * @ignore\n */ function genValuePartial_fromObject(gen, field, fieldIndex, prop) {\n    var defaultAlreadyEmitted = false;\n    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */ if (field.resolvedType) {\n        if (field.resolvedType instanceof Enum) {\n            gen(\"switch(d%s){\", prop);\n            for(var values = field.resolvedType.values, keys = Object.keys(values), i = 0; i < keys.length; ++i){\n                // enum unknown values passthrough\n                if (values[keys[i]] === field.typeDefault && !defaultAlreadyEmitted) {\n                    gen(\"default:\")('if(typeof(d%s)===\"number\"){m%s=d%s;break}', prop, prop, prop);\n                    if (!field.repeated) gen // fallback to default value only for\n                    (\"break\"); // for non-repeated fields, just ignore\n                    defaultAlreadyEmitted = true;\n                }\n                gen(\"case%j:\", keys[i])(\"case %i:\", values[keys[i]])(\"m%s=%j\", prop, values[keys[i]])(\"break\");\n            }\n            gen(\"}\");\n        } else gen('if(typeof d%s!==\"object\")', prop)(\"throw TypeError(%j)\", field.fullName + \": object expected\")(\"m%s=types[%i].fromObject(d%s)\", prop, fieldIndex, prop);\n    } else {\n        var isUnsigned = false;\n        switch(field.type){\n            case \"double\":\n            case \"float\":\n                gen(\"m%s=Number(d%s)\", prop, prop); // also catches \"NaN\", \"Infinity\"\n                break;\n            case \"uint32\":\n            case \"fixed32\":\n                gen(\"m%s=d%s>>>0\", prop, prop);\n                break;\n            case \"int32\":\n            case \"sint32\":\n            case \"sfixed32\":\n                gen(\"m%s=d%s|0\", prop, prop);\n                break;\n            case \"uint64\":\n                isUnsigned = true;\n            // eslint-disable-next-line no-fallthrough\n            case \"int64\":\n            case \"sint64\":\n            case \"fixed64\":\n            case \"sfixed64\":\n                gen(\"if(util.Long)\")(\"(m%s=util.Long.fromValue(d%s)).unsigned=%j\", prop, prop, isUnsigned)('else if(typeof d%s===\"string\")', prop)(\"m%s=parseInt(d%s,10)\", prop, prop)('else if(typeof d%s===\"number\")', prop)(\"m%s=d%s\", prop, prop)('else if(typeof d%s===\"object\")', prop)(\"m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)\", prop, prop, prop, isUnsigned ? \"true\" : \"\");\n                break;\n            case \"bytes\":\n                gen('if(typeof d%s===\"string\")', prop)(\"util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)\", prop, prop, prop)(\"else if(d%s.length >= 0)\", prop)(\"m%s=d%s\", prop, prop);\n                break;\n            case \"string\":\n                gen(\"m%s=String(d%s)\", prop, prop);\n                break;\n            case \"bool\":\n                gen(\"m%s=Boolean(d%s)\", prop, prop);\n                break;\n        }\n    }\n    return gen;\n/* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */ }\n/**\n * Generates a plain object to runtime message converter specific to the specified message type.\n * @param {Type} mtype Message type\n * @returns {Codegen} Codegen instance\n */ converter.fromObject = function fromObject(mtype) {\n    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */ var fields = mtype.fieldsArray;\n    var gen = util.codegen([\n        \"d\"\n    ], mtype.name + \"$fromObject\")(\"if(d instanceof this.ctor)\")(\"return d\");\n    if (!fields.length) return gen(\"return new this.ctor\");\n    gen(\"var m=new this.ctor\");\n    for(var i = 0; i < fields.length; ++i){\n        var field = fields[i].resolve(), prop = util.safeProp(field.name);\n        // Map fields\n        if (field.map) {\n            gen(\"if(d%s){\", prop)('if(typeof d%s!==\"object\")', prop)(\"throw TypeError(%j)\", field.fullName + \": object expected\")(\"m%s={}\", prop)(\"for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){\", prop);\n            genValuePartial_fromObject(gen, field, /* not sorted */ i, prop + \"[ks[i]]\")(\"}\")(\"}\");\n        // Repeated fields\n        } else if (field.repeated) {\n            gen(\"if(d%s){\", prop)(\"if(!Array.isArray(d%s))\", prop)(\"throw TypeError(%j)\", field.fullName + \": array expected\")(\"m%s=[]\", prop)(\"for(var i=0;i<d%s.length;++i){\", prop);\n            genValuePartial_fromObject(gen, field, /* not sorted */ i, prop + \"[i]\")(\"}\")(\"}\");\n        // Non-repeated fields\n        } else {\n            if (!(field.resolvedType instanceof Enum)) gen // no need to test for null/undefined if an enum (uses switch)\n            (\"if(d%s!=null){\", prop); // !== undefined && !== null\n            genValuePartial_fromObject(gen, field, /* not sorted */ i, prop);\n            if (!(field.resolvedType instanceof Enum)) gen(\"}\");\n        }\n    }\n    return gen(\"return m\");\n/* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */ };\n/**\n * Generates a partial value toObject converter.\n * @param {Codegen} gen Codegen instance\n * @param {Field} field Reflected field\n * @param {number} fieldIndex Field index\n * @param {string} prop Property reference\n * @returns {Codegen} Codegen instance\n * @ignore\n */ function genValuePartial_toObject(gen, field, fieldIndex, prop) {\n    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */ if (field.resolvedType) {\n        if (field.resolvedType instanceof Enum) gen(\"d%s=o.enums===String?(types[%i].values[m%s]===undefined?m%s:types[%i].values[m%s]):m%s\", prop, fieldIndex, prop, prop, fieldIndex, prop, prop);\n        else gen(\"d%s=types[%i].toObject(m%s,o)\", prop, fieldIndex, prop);\n    } else {\n        var isUnsigned = false;\n        switch(field.type){\n            case \"double\":\n            case \"float\":\n                gen(\"d%s=o.json&&!isFinite(m%s)?String(m%s):m%s\", prop, prop, prop, prop);\n                break;\n            case \"uint64\":\n                isUnsigned = true;\n            // eslint-disable-next-line no-fallthrough\n            case \"int64\":\n            case \"sint64\":\n            case \"fixed64\":\n            case \"sfixed64\":\n                gen('if(typeof m%s===\"number\")', prop)(\"d%s=o.longs===String?String(m%s):m%s\", prop, prop, prop)(\"else\") // Long-like\n                (\"d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s\", prop, prop, prop, prop, isUnsigned ? \"true\" : \"\", prop);\n                break;\n            case \"bytes\":\n                gen(\"d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s\", prop, prop, prop, prop, prop);\n                break;\n            default:\n                gen(\"d%s=m%s\", prop, prop);\n                break;\n        }\n    }\n    return gen;\n/* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */ }\n/**\n * Generates a runtime message to plain object converter specific to the specified message type.\n * @param {Type} mtype Message type\n * @returns {Codegen} Codegen instance\n */ converter.toObject = function toObject(mtype) {\n    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */ var fields = mtype.fieldsArray.slice().sort(util.compareFieldsById);\n    if (!fields.length) return util.codegen()(\"return {}\");\n    var gen = util.codegen([\n        \"m\",\n        \"o\"\n    ], mtype.name + \"$toObject\")(\"if(!o)\")(\"o={}\")(\"var d={}\");\n    var repeatedFields = [], mapFields = [], normalFields = [], i = 0;\n    for(; i < fields.length; ++i)if (!fields[i].partOf) (fields[i].resolve().repeated ? repeatedFields : fields[i].map ? mapFields : normalFields).push(fields[i]);\n    if (repeatedFields.length) {\n        gen(\"if(o.arrays||o.defaults){\");\n        for(i = 0; i < repeatedFields.length; ++i)gen(\"d%s=[]\", util.safeProp(repeatedFields[i].name));\n        gen(\"}\");\n    }\n    if (mapFields.length) {\n        gen(\"if(o.objects||o.defaults){\");\n        for(i = 0; i < mapFields.length; ++i)gen(\"d%s={}\", util.safeProp(mapFields[i].name));\n        gen(\"}\");\n    }\n    if (normalFields.length) {\n        gen(\"if(o.defaults){\");\n        for(i = 0; i < normalFields.length; ++i){\n            var field = normalFields[i], prop = util.safeProp(field.name);\n            if (field.resolvedType instanceof Enum) gen(\"d%s=o.enums===String?%j:%j\", prop, field.resolvedType.valuesById[field.typeDefault], field.typeDefault);\n            else if (field.long) gen(\"if(util.Long){\")(\"var n=new util.Long(%i,%i,%j)\", field.typeDefault.low, field.typeDefault.high, field.typeDefault.unsigned)(\"d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n\", prop)(\"}else\")(\"d%s=o.longs===String?%j:%i\", prop, field.typeDefault.toString(), field.typeDefault.toNumber());\n            else if (field.bytes) {\n                var arrayDefault = \"[\" + Array.prototype.slice.call(field.typeDefault).join(\",\") + \"]\";\n                gen(\"if(o.bytes===String)d%s=%j\", prop, String.fromCharCode.apply(String, field.typeDefault))(\"else{\")(\"d%s=%s\", prop, arrayDefault)(\"if(o.bytes!==Array)d%s=util.newBuffer(d%s)\", prop, prop)(\"}\");\n            } else gen(\"d%s=%j\", prop, field.typeDefault); // also messages (=null)\n        }\n        gen(\"}\");\n    }\n    var hasKs2 = false;\n    for(i = 0; i < fields.length; ++i){\n        var field = fields[i], index = mtype._fieldsArray.indexOf(field), prop = util.safeProp(field.name);\n        if (field.map) {\n            if (!hasKs2) {\n                hasKs2 = true;\n                gen(\"var ks2\");\n            }\n            gen(\"if(m%s&&(ks2=Object.keys(m%s)).length){\", prop, prop)(\"d%s={}\", prop)(\"for(var j=0;j<ks2.length;++j){\");\n            genValuePartial_toObject(gen, field, /* sorted */ index, prop + \"[ks2[j]]\")(\"}\");\n        } else if (field.repeated) {\n            gen(\"if(m%s&&m%s.length){\", prop, prop)(\"d%s=[]\", prop)(\"for(var j=0;j<m%s.length;++j){\", prop);\n            genValuePartial_toObject(gen, field, /* sorted */ index, prop + \"[j]\")(\"}\");\n        } else {\n            gen(\"if(m%s!=null&&m.hasOwnProperty(%j)){\", prop, field.name); // !== undefined && !== null\n            genValuePartial_toObject(gen, field, /* sorted */ index, prop);\n            if (field.partOf) gen(\"if(o.oneofs)\")(\"d%s=%j\", util.safeProp(field.partOf.name), field.name);\n        }\n        gen(\"}\");\n    }\n    return gen(\"return d\");\n/* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */ };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL2NvbnZlcnRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Q0FHQyxHQUNELElBQUlBLFlBQVlDO0FBRWhCLElBQUlDLE9BQU9DLG1CQUFPQSxDQUFDLDREQUFRLEdBQ3ZCQyxPQUFPRCxtQkFBT0EsQ0FBQyw0REFBUTtBQUUzQjs7Ozs7Ozs7Q0FRQyxHQUNELFNBQVNFLDJCQUEyQkMsR0FBRyxFQUFFQyxLQUFLLEVBQUVDLFVBQVUsRUFBRUMsSUFBSTtJQUM1RCxJQUFJQyx3QkFBd0I7SUFDNUIsMEVBQTBFLEdBQzFFLElBQUlILE1BQU1JLFlBQVksRUFBRTtRQUNwQixJQUFJSixNQUFNSSxZQUFZLFlBQVlULE1BQU07WUFBRUksSUFDckMsZ0JBQWdCRztZQUNqQixJQUFLLElBQUlHLFNBQVNMLE1BQU1JLFlBQVksQ0FBQ0MsTUFBTSxFQUFFQyxPQUFPQyxPQUFPRCxJQUFJLENBQUNELFNBQVNHLElBQUksR0FBR0EsSUFBSUYsS0FBS0csTUFBTSxFQUFFLEVBQUVELEVBQUc7Z0JBQ2xHLGtDQUFrQztnQkFDbEMsSUFBSUgsTUFBTSxDQUFDQyxJQUFJLENBQUNFLEVBQUUsQ0FBQyxLQUFLUixNQUFNVSxXQUFXLElBQUksQ0FBQ1AsdUJBQXVCO29CQUFFSixJQUNsRSxZQUNJLDZDQUErQ0csTUFBTUEsTUFBTUE7b0JBQ2hFLElBQUksQ0FBQ0YsTUFBTVcsUUFBUSxFQUFFWixJQUFJLHFDQUFxQztxQkFFekQsVUFBb0IsdUNBQXVDO29CQUNoRUksd0JBQXdCO2dCQUM1QjtnQkFDQUosSUFDQyxXQUFXTyxJQUFJLENBQUNFLEVBQUUsRUFDbEIsWUFBWUgsTUFBTSxDQUFDQyxJQUFJLENBQUNFLEVBQUUsQ0FBQyxFQUN2QixVQUFVTixNQUFNRyxNQUFNLENBQUNDLElBQUksQ0FBQ0UsRUFBRSxDQUFDLEVBQy9CO1lBQ1Q7WUFBRVQsSUFDRDtRQUNMLE9BQU9BLElBQ0YsNkJBQStCRyxNQUMzQix1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TztZQUFFQSxJQUNULDJDQUEyQ0csTUFBTUEsTUFDN0MsVUFBVUEsTUFDVjtZQUNHc0IseUJBQXlCekIsS0FBS0MsT0FBTyxVQUFVLEdBQUdtRCxPQUFPakQsT0FBTyxZQUNuRTtRQUNELE9BQU8sSUFBSUYsTUFBTVcsUUFBUSxFQUFFO1lBQUVaLElBQ2hDLHdCQUF3QkcsTUFBTUEsTUFDMUIsVUFBVUEsTUFDVixrQ0FBa0NBO1lBQy9Cc0IseUJBQXlCekIsS0FBS0MsT0FBTyxVQUFVLEdBQUdtRCxPQUFPakQsT0FBTyxPQUNuRTtRQUNELE9BQU87WUFBRUgsSUFDWix3Q0FBd0NHLE1BQU1GLE1BQU1vQixJQUFJLEdBQUcsNEJBQTRCO1lBQ3BGSSx5QkFBeUJ6QixLQUFLQyxPQUFPLFVBQVUsR0FBR21ELE9BQU9qRDtZQUN6RCxJQUFJRixNQUFNZ0MsTUFBTSxFQUFFakMsSUFDakIsZ0JBQ0ksVUFBVUYsS0FBS3lCLFFBQVEsQ0FBQ3RCLE1BQU1nQyxNQUFNLENBQUNaLElBQUksR0FBR3BCLE1BQU1vQixJQUFJO1FBQzNEO1FBQ0FyQixJQUNIO0lBQ0Q7SUFDQSxPQUFPQSxJQUNOO0FBQ0QseUVBQXlFLEdBQzdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9jb252ZXJ0ZXIuanM/ZGY1ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogUnVudGltZSBtZXNzYWdlIGZyb20vdG8gcGxhaW4gb2JqZWN0IGNvbnZlcnRlcnMuXG4gKiBAbmFtZXNwYWNlXG4gKi9cbnZhciBjb252ZXJ0ZXIgPSBleHBvcnRzO1xuXG52YXIgRW51bSA9IHJlcXVpcmUoXCIuL2VudW1cIiksXG4gICAgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcGFydGlhbCB2YWx1ZSBmcm9tT2JqZWN0IGNvbnZldGVyLlxuICogQHBhcmFtIHtDb2RlZ2VufSBnZW4gQ29kZWdlbiBpbnN0YW5jZVxuICogQHBhcmFtIHtGaWVsZH0gZmllbGQgUmVmbGVjdGVkIGZpZWxkXG4gKiBAcGFyYW0ge251bWJlcn0gZmllbGRJbmRleCBGaWVsZCBpbmRleFxuICogQHBhcmFtIHtzdHJpbmd9IHByb3AgUHJvcGVydHkgcmVmZXJlbmNlXG4gKiBAcmV0dXJucyB7Q29kZWdlbn0gQ29kZWdlbiBpbnN0YW5jZVxuICogQGlnbm9yZVxuICovXG5mdW5jdGlvbiBnZW5WYWx1ZVBhcnRpYWxfZnJvbU9iamVjdChnZW4sIGZpZWxkLCBmaWVsZEluZGV4LCBwcm9wKSB7XG4gICAgdmFyIGRlZmF1bHRBbHJlYWR5RW1pdHRlZCA9IGZhbHNlO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVuZXhwZWN0ZWQtbXVsdGlsaW5lLCBibG9jay1zY29wZWQtdmFyLCBuby1yZWRlY2xhcmUgKi9cbiAgICBpZiAoZmllbGQucmVzb2x2ZWRUeXBlKSB7XG4gICAgICAgIGlmIChmaWVsZC5yZXNvbHZlZFR5cGUgaW5zdGFuY2VvZiBFbnVtKSB7IGdlblxuICAgICAgICAgICAgKFwic3dpdGNoKGQlcyl7XCIsIHByb3ApO1xuICAgICAgICAgICAgZm9yICh2YXIgdmFsdWVzID0gZmllbGQucmVzb2x2ZWRUeXBlLnZhbHVlcywga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIC8vIGVudW0gdW5rbm93biB2YWx1ZXMgcGFzc3Rocm91Z2hcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVzW2tleXNbaV1dID09PSBmaWVsZC50eXBlRGVmYXVsdCAmJiAhZGVmYXVsdEFscmVhZHlFbWl0dGVkKSB7IGdlblxuICAgICAgICAgICAgICAgICAgICAoXCJkZWZhdWx0OlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgKFwiaWYodHlwZW9mKGQlcyk9PT1cXFwibnVtYmVyXFxcIil7bSVzPWQlczticmVha31cIiwgcHJvcCwgcHJvcCwgcHJvcCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZmllbGQucmVwZWF0ZWQpIGdlbiAvLyBmYWxsYmFjayB0byBkZWZhdWx0IHZhbHVlIG9ubHkgZm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhcnJheXMsIHRvIGF2b2lkIGxlYXZpbmcgaG9sZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAoXCJicmVha1wiKTsgICAgICAgICAgIC8vIGZvciBub24tcmVwZWF0ZWQgZmllbGRzLCBqdXN0IGlnbm9yZVxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0QWxyZWFkeUVtaXR0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBnZW5cbiAgICAgICAgICAgICAgICAoXCJjYXNlJWo6XCIsIGtleXNbaV0pXG4gICAgICAgICAgICAgICAgKFwiY2FzZSAlaTpcIiwgdmFsdWVzW2tleXNbaV1dKVxuICAgICAgICAgICAgICAgICAgICAoXCJtJXM9JWpcIiwgcHJvcCwgdmFsdWVzW2tleXNbaV1dKVxuICAgICAgICAgICAgICAgICAgICAoXCJicmVha1wiKTtcbiAgICAgICAgICAgIH0gZ2VuXG4gICAgICAgICAgICAoXCJ9XCIpO1xuICAgICAgICB9IGVsc2UgZ2VuXG4gICAgICAgICAgICAoXCJpZih0eXBlb2YgZCVzIT09XFxcIm9iamVjdFxcXCIpXCIsIHByb3ApXG4gICAgICAgICAgICAgICAgKFwidGhyb3cgVHlwZUVycm9yKCVqKVwiLCBmaWVsZC5mdWxsTmFtZSArIFwiOiBvYmplY3QgZXhwZWN0ZWRcIilcbiAgICAgICAgICAgIChcIm0lcz10eXBlc1slaV0uZnJvbU9iamVjdChkJXMpXCIsIHByb3AsIGZpZWxkSW5kZXgsIHByb3ApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpc1Vuc2lnbmVkID0gZmFsc2U7XG4gICAgICAgIHN3aXRjaCAoZmllbGQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcImRvdWJsZVwiOlxuICAgICAgICAgICAgY2FzZSBcImZsb2F0XCI6IGdlblxuICAgICAgICAgICAgICAgIChcIm0lcz1OdW1iZXIoZCVzKVwiLCBwcm9wLCBwcm9wKTsgLy8gYWxzbyBjYXRjaGVzIFwiTmFOXCIsIFwiSW5maW5pdHlcIlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInVpbnQzMlwiOlxuICAgICAgICAgICAgY2FzZSBcImZpeGVkMzJcIjogZ2VuXG4gICAgICAgICAgICAgICAgKFwibSVzPWQlcz4+PjBcIiwgcHJvcCwgcHJvcCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiaW50MzJcIjpcbiAgICAgICAgICAgIGNhc2UgXCJzaW50MzJcIjpcbiAgICAgICAgICAgIGNhc2UgXCJzZml4ZWQzMlwiOiBnZW5cbiAgICAgICAgICAgICAgICAoXCJtJXM9ZCVzfDBcIiwgcHJvcCwgcHJvcCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwidWludDY0XCI6XG4gICAgICAgICAgICAgICAgaXNVbnNpZ25lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXG4gICAgICAgICAgICBjYXNlIFwiaW50NjRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJzaW50NjRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJmaXhlZDY0XCI6XG4gICAgICAgICAgICBjYXNlIFwic2ZpeGVkNjRcIjogZ2VuXG4gICAgICAgICAgICAgICAgKFwiaWYodXRpbC5Mb25nKVwiKVxuICAgICAgICAgICAgICAgICAgICAoXCIobSVzPXV0aWwuTG9uZy5mcm9tVmFsdWUoZCVzKSkudW5zaWduZWQ9JWpcIiwgcHJvcCwgcHJvcCwgaXNVbnNpZ25lZClcbiAgICAgICAgICAgICAgICAoXCJlbHNlIGlmKHR5cGVvZiBkJXM9PT1cXFwic3RyaW5nXFxcIilcIiwgcHJvcClcbiAgICAgICAgICAgICAgICAgICAgKFwibSVzPXBhcnNlSW50KGQlcywxMClcIiwgcHJvcCwgcHJvcClcbiAgICAgICAgICAgICAgICAoXCJlbHNlIGlmKHR5cGVvZiBkJXM9PT1cXFwibnVtYmVyXFxcIilcIiwgcHJvcClcbiAgICAgICAgICAgICAgICAgICAgKFwibSVzPWQlc1wiLCBwcm9wLCBwcm9wKVxuICAgICAgICAgICAgICAgIChcImVsc2UgaWYodHlwZW9mIGQlcz09PVxcXCJvYmplY3RcXFwiKVwiLCBwcm9wKVxuICAgICAgICAgICAgICAgICAgICAoXCJtJXM9bmV3IHV0aWwuTG9uZ0JpdHMoZCVzLmxvdz4+PjAsZCVzLmhpZ2g+Pj4wKS50b051bWJlciglcylcIiwgcHJvcCwgcHJvcCwgcHJvcCwgaXNVbnNpZ25lZCA/IFwidHJ1ZVwiIDogXCJcIik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiYnl0ZXNcIjogZ2VuXG4gICAgICAgICAgICAgICAgKFwiaWYodHlwZW9mIGQlcz09PVxcXCJzdHJpbmdcXFwiKVwiLCBwcm9wKVxuICAgICAgICAgICAgICAgICAgICAoXCJ1dGlsLmJhc2U2NC5kZWNvZGUoZCVzLG0lcz11dGlsLm5ld0J1ZmZlcih1dGlsLmJhc2U2NC5sZW5ndGgoZCVzKSksMClcIiwgcHJvcCwgcHJvcCwgcHJvcClcbiAgICAgICAgICAgICAgICAoXCJlbHNlIGlmKGQlcy5sZW5ndGggPj0gMClcIiwgcHJvcClcbiAgICAgICAgICAgICAgICAgICAgKFwibSVzPWQlc1wiLCBwcm9wLCBwcm9wKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjogZ2VuXG4gICAgICAgICAgICAgICAgKFwibSVzPVN0cmluZyhkJXMpXCIsIHByb3AsIHByb3ApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImJvb2xcIjogZ2VuXG4gICAgICAgICAgICAgICAgKFwibSVzPUJvb2xlYW4oZCVzKVwiLCBwcm9wLCBwcm9wKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8qIGRlZmF1bHQ6IGdlblxuICAgICAgICAgICAgICAgIChcIm0lcz1kJXNcIiwgcHJvcCwgcHJvcCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7ICovXG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGdlbjtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVuZXhwZWN0ZWQtbXVsdGlsaW5lLCBibG9jay1zY29wZWQtdmFyLCBuby1yZWRlY2xhcmUgKi9cbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBwbGFpbiBvYmplY3QgdG8gcnVudGltZSBtZXNzYWdlIGNvbnZlcnRlciBzcGVjaWZpYyB0byB0aGUgc3BlY2lmaWVkIG1lc3NhZ2UgdHlwZS5cbiAqIEBwYXJhbSB7VHlwZX0gbXR5cGUgTWVzc2FnZSB0eXBlXG4gKiBAcmV0dXJucyB7Q29kZWdlbn0gQ29kZWdlbiBpbnN0YW5jZVxuICovXG5jb252ZXJ0ZXIuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3QobXR5cGUpIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bmV4cGVjdGVkLW11bHRpbGluZSwgYmxvY2stc2NvcGVkLXZhciwgbm8tcmVkZWNsYXJlICovXG4gICAgdmFyIGZpZWxkcyA9IG10eXBlLmZpZWxkc0FycmF5O1xuICAgIHZhciBnZW4gPSB1dGlsLmNvZGVnZW4oW1wiZFwiXSwgbXR5cGUubmFtZSArIFwiJGZyb21PYmplY3RcIilcbiAgICAoXCJpZihkIGluc3RhbmNlb2YgdGhpcy5jdG9yKVwiKVxuICAgICAgICAoXCJyZXR1cm4gZFwiKTtcbiAgICBpZiAoIWZpZWxkcy5sZW5ndGgpIHJldHVybiBnZW5cbiAgICAoXCJyZXR1cm4gbmV3IHRoaXMuY3RvclwiKTtcbiAgICBnZW5cbiAgICAoXCJ2YXIgbT1uZXcgdGhpcy5jdG9yXCIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBmaWVsZCAgPSBmaWVsZHNbaV0ucmVzb2x2ZSgpLFxuICAgICAgICAgICAgcHJvcCAgID0gdXRpbC5zYWZlUHJvcChmaWVsZC5uYW1lKTtcblxuICAgICAgICAvLyBNYXAgZmllbGRzXG4gICAgICAgIGlmIChmaWVsZC5tYXApIHsgZ2VuXG4gICAgKFwiaWYoZCVzKXtcIiwgcHJvcClcbiAgICAgICAgKFwiaWYodHlwZW9mIGQlcyE9PVxcXCJvYmplY3RcXFwiKVwiLCBwcm9wKVxuICAgICAgICAgICAgKFwidGhyb3cgVHlwZUVycm9yKCVqKVwiLCBmaWVsZC5mdWxsTmFtZSArIFwiOiBvYmplY3QgZXhwZWN0ZWRcIilcbiAgICAgICAgKFwibSVzPXt9XCIsIHByb3ApXG4gICAgICAgIChcImZvcih2YXIga3M9T2JqZWN0LmtleXMoZCVzKSxpPTA7aTxrcy5sZW5ndGg7KytpKXtcIiwgcHJvcCk7XG4gICAgICAgICAgICBnZW5WYWx1ZVBhcnRpYWxfZnJvbU9iamVjdChnZW4sIGZpZWxkLCAvKiBub3Qgc29ydGVkICovIGksIHByb3AgKyBcIltrc1tpXV1cIilcbiAgICAgICAgKFwifVwiKVxuICAgIChcIn1cIik7XG5cbiAgICAgICAgLy8gUmVwZWF0ZWQgZmllbGRzXG4gICAgICAgIH0gZWxzZSBpZiAoZmllbGQucmVwZWF0ZWQpIHsgZ2VuXG4gICAgKFwiaWYoZCVzKXtcIiwgcHJvcClcbiAgICAgICAgKFwiaWYoIUFycmF5LmlzQXJyYXkoZCVzKSlcIiwgcHJvcClcbiAgICAgICAgICAgIChcInRocm93IFR5cGVFcnJvciglailcIiwgZmllbGQuZnVsbE5hbWUgKyBcIjogYXJyYXkgZXhwZWN0ZWRcIilcbiAgICAgICAgKFwibSVzPVtdXCIsIHByb3ApXG4gICAgICAgIChcImZvcih2YXIgaT0wO2k8ZCVzLmxlbmd0aDsrK2kpe1wiLCBwcm9wKTtcbiAgICAgICAgICAgIGdlblZhbHVlUGFydGlhbF9mcm9tT2JqZWN0KGdlbiwgZmllbGQsIC8qIG5vdCBzb3J0ZWQgKi8gaSwgcHJvcCArIFwiW2ldXCIpXG4gICAgICAgIChcIn1cIilcbiAgICAoXCJ9XCIpO1xuXG4gICAgICAgIC8vIE5vbi1yZXBlYXRlZCBmaWVsZHNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghKGZpZWxkLnJlc29sdmVkVHlwZSBpbnN0YW5jZW9mIEVudW0pKSBnZW4gLy8gbm8gbmVlZCB0byB0ZXN0IGZvciBudWxsL3VuZGVmaW5lZCBpZiBhbiBlbnVtICh1c2VzIHN3aXRjaClcbiAgICAoXCJpZihkJXMhPW51bGwpe1wiLCBwcm9wKTsgLy8gIT09IHVuZGVmaW5lZCAmJiAhPT0gbnVsbFxuICAgICAgICBnZW5WYWx1ZVBhcnRpYWxfZnJvbU9iamVjdChnZW4sIGZpZWxkLCAvKiBub3Qgc29ydGVkICovIGksIHByb3ApO1xuICAgICAgICAgICAgaWYgKCEoZmllbGQucmVzb2x2ZWRUeXBlIGluc3RhbmNlb2YgRW51bSkpIGdlblxuICAgIChcIn1cIik7XG4gICAgICAgIH1cbiAgICB9IHJldHVybiBnZW5cbiAgICAoXCJyZXR1cm4gbVwiKTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVuZXhwZWN0ZWQtbXVsdGlsaW5lLCBibG9jay1zY29wZWQtdmFyLCBuby1yZWRlY2xhcmUgKi9cbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcGFydGlhbCB2YWx1ZSB0b09iamVjdCBjb252ZXJ0ZXIuXG4gKiBAcGFyYW0ge0NvZGVnZW59IGdlbiBDb2RlZ2VuIGluc3RhbmNlXG4gKiBAcGFyYW0ge0ZpZWxkfSBmaWVsZCBSZWZsZWN0ZWQgZmllbGRcbiAqIEBwYXJhbSB7bnVtYmVyfSBmaWVsZEluZGV4IEZpZWxkIGluZGV4XG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBQcm9wZXJ0eSByZWZlcmVuY2VcbiAqIEByZXR1cm5zIHtDb2RlZ2VufSBDb2RlZ2VuIGluc3RhbmNlXG4gKiBAaWdub3JlXG4gKi9cbmZ1bmN0aW9uIGdlblZhbHVlUGFydGlhbF90b09iamVjdChnZW4sIGZpZWxkLCBmaWVsZEluZGV4LCBwcm9wKSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmUsIGJsb2NrLXNjb3BlZC12YXIsIG5vLXJlZGVjbGFyZSAqL1xuICAgIGlmIChmaWVsZC5yZXNvbHZlZFR5cGUpIHtcbiAgICAgICAgaWYgKGZpZWxkLnJlc29sdmVkVHlwZSBpbnN0YW5jZW9mIEVudW0pIGdlblxuICAgICAgICAgICAgKFwiZCVzPW8uZW51bXM9PT1TdHJpbmc/KHR5cGVzWyVpXS52YWx1ZXNbbSVzXT09PXVuZGVmaW5lZD9tJXM6dHlwZXNbJWldLnZhbHVlc1ttJXNdKTptJXNcIiwgcHJvcCwgZmllbGRJbmRleCwgcHJvcCwgcHJvcCwgZmllbGRJbmRleCwgcHJvcCwgcHJvcCk7XG4gICAgICAgIGVsc2UgZ2VuXG4gICAgICAgICAgICAoXCJkJXM9dHlwZXNbJWldLnRvT2JqZWN0KG0lcyxvKVwiLCBwcm9wLCBmaWVsZEluZGV4LCBwcm9wKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaXNVbnNpZ25lZCA9IGZhbHNlO1xuICAgICAgICBzd2l0Y2ggKGZpZWxkLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJkb3VibGVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJmbG9hdFwiOiBnZW5cbiAgICAgICAgICAgIChcImQlcz1vLmpzb24mJiFpc0Zpbml0ZShtJXMpP1N0cmluZyhtJXMpOm0lc1wiLCBwcm9wLCBwcm9wLCBwcm9wLCBwcm9wKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ1aW50NjRcIjpcbiAgICAgICAgICAgICAgICBpc1Vuc2lnbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcbiAgICAgICAgICAgIGNhc2UgXCJpbnQ2NFwiOlxuICAgICAgICAgICAgY2FzZSBcInNpbnQ2NFwiOlxuICAgICAgICAgICAgY2FzZSBcImZpeGVkNjRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJzZml4ZWQ2NFwiOiBnZW5cbiAgICAgICAgICAgIChcImlmKHR5cGVvZiBtJXM9PT1cXFwibnVtYmVyXFxcIilcIiwgcHJvcClcbiAgICAgICAgICAgICAgICAoXCJkJXM9by5sb25ncz09PVN0cmluZz9TdHJpbmcobSVzKTptJXNcIiwgcHJvcCwgcHJvcCwgcHJvcClcbiAgICAgICAgICAgIChcImVsc2VcIikgLy8gTG9uZy1saWtlXG4gICAgICAgICAgICAgICAgKFwiZCVzPW8ubG9uZ3M9PT1TdHJpbmc/dXRpbC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG0lcyk6by5sb25ncz09PU51bWJlcj9uZXcgdXRpbC5Mb25nQml0cyhtJXMubG93Pj4+MCxtJXMuaGlnaD4+PjApLnRvTnVtYmVyKCVzKTptJXNcIiwgcHJvcCwgcHJvcCwgcHJvcCwgcHJvcCwgaXNVbnNpZ25lZCA/IFwidHJ1ZVwiOiBcIlwiLCBwcm9wKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJieXRlc1wiOiBnZW5cbiAgICAgICAgICAgIChcImQlcz1vLmJ5dGVzPT09U3RyaW5nP3V0aWwuYmFzZTY0LmVuY29kZShtJXMsMCxtJXMubGVuZ3RoKTpvLmJ5dGVzPT09QXJyYXk/QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobSVzKTptJXNcIiwgcHJvcCwgcHJvcCwgcHJvcCwgcHJvcCwgcHJvcCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OiBnZW5cbiAgICAgICAgICAgIChcImQlcz1tJXNcIiwgcHJvcCwgcHJvcCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGdlbjtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVuZXhwZWN0ZWQtbXVsdGlsaW5lLCBibG9jay1zY29wZWQtdmFyLCBuby1yZWRlY2xhcmUgKi9cbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBydW50aW1lIG1lc3NhZ2UgdG8gcGxhaW4gb2JqZWN0IGNvbnZlcnRlciBzcGVjaWZpYyB0byB0aGUgc3BlY2lmaWVkIG1lc3NhZ2UgdHlwZS5cbiAqIEBwYXJhbSB7VHlwZX0gbXR5cGUgTWVzc2FnZSB0eXBlXG4gKiBAcmV0dXJucyB7Q29kZWdlbn0gQ29kZWdlbiBpbnN0YW5jZVxuICovXG5jb252ZXJ0ZXIudG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtdHlwZSkge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVuZXhwZWN0ZWQtbXVsdGlsaW5lLCBibG9jay1zY29wZWQtdmFyLCBuby1yZWRlY2xhcmUgKi9cbiAgICB2YXIgZmllbGRzID0gbXR5cGUuZmllbGRzQXJyYXkuc2xpY2UoKS5zb3J0KHV0aWwuY29tcGFyZUZpZWxkc0J5SWQpO1xuICAgIGlmICghZmllbGRzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIHV0aWwuY29kZWdlbigpKFwicmV0dXJuIHt9XCIpO1xuICAgIHZhciBnZW4gPSB1dGlsLmNvZGVnZW4oW1wibVwiLCBcIm9cIl0sIG10eXBlLm5hbWUgKyBcIiR0b09iamVjdFwiKVxuICAgIChcImlmKCFvKVwiKVxuICAgICAgICAoXCJvPXt9XCIpXG4gICAgKFwidmFyIGQ9e31cIik7XG5cbiAgICB2YXIgcmVwZWF0ZWRGaWVsZHMgPSBbXSxcbiAgICAgICAgbWFwRmllbGRzID0gW10sXG4gICAgICAgIG5vcm1hbEZpZWxkcyA9IFtdLFxuICAgICAgICBpID0gMDtcbiAgICBmb3IgKDsgaSA8IGZpZWxkcy5sZW5ndGg7ICsraSlcbiAgICAgICAgaWYgKCFmaWVsZHNbaV0ucGFydE9mKVxuICAgICAgICAgICAgKCBmaWVsZHNbaV0ucmVzb2x2ZSgpLnJlcGVhdGVkID8gcmVwZWF0ZWRGaWVsZHNcbiAgICAgICAgICAgIDogZmllbGRzW2ldLm1hcCA/IG1hcEZpZWxkc1xuICAgICAgICAgICAgOiBub3JtYWxGaWVsZHMpLnB1c2goZmllbGRzW2ldKTtcblxuICAgIGlmIChyZXBlYXRlZEZpZWxkcy5sZW5ndGgpIHsgZ2VuXG4gICAgKFwiaWYoby5hcnJheXN8fG8uZGVmYXVsdHMpe1wiKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHJlcGVhdGVkRmllbGRzLmxlbmd0aDsgKytpKSBnZW5cbiAgICAgICAgKFwiZCVzPVtdXCIsIHV0aWwuc2FmZVByb3AocmVwZWF0ZWRGaWVsZHNbaV0ubmFtZSkpO1xuICAgICAgICBnZW5cbiAgICAoXCJ9XCIpO1xuICAgIH1cblxuICAgIGlmIChtYXBGaWVsZHMubGVuZ3RoKSB7IGdlblxuICAgIChcImlmKG8ub2JqZWN0c3x8by5kZWZhdWx0cyl7XCIpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbWFwRmllbGRzLmxlbmd0aDsgKytpKSBnZW5cbiAgICAgICAgKFwiZCVzPXt9XCIsIHV0aWwuc2FmZVByb3AobWFwRmllbGRzW2ldLm5hbWUpKTtcbiAgICAgICAgZ2VuXG4gICAgKFwifVwiKTtcbiAgICB9XG5cbiAgICBpZiAobm9ybWFsRmllbGRzLmxlbmd0aCkgeyBnZW5cbiAgICAoXCJpZihvLmRlZmF1bHRzKXtcIik7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBub3JtYWxGaWVsZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBmaWVsZCA9IG5vcm1hbEZpZWxkc1tpXSxcbiAgICAgICAgICAgICAgICBwcm9wICA9IHV0aWwuc2FmZVByb3AoZmllbGQubmFtZSk7XG4gICAgICAgICAgICBpZiAoZmllbGQucmVzb2x2ZWRUeXBlIGluc3RhbmNlb2YgRW51bSkgZ2VuXG4gICAgICAgIChcImQlcz1vLmVudW1zPT09U3RyaW5nPyVqOiVqXCIsIHByb3AsIGZpZWxkLnJlc29sdmVkVHlwZS52YWx1ZXNCeUlkW2ZpZWxkLnR5cGVEZWZhdWx0XSwgZmllbGQudHlwZURlZmF1bHQpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZmllbGQubG9uZykgZ2VuXG4gICAgICAgIChcImlmKHV0aWwuTG9uZyl7XCIpXG4gICAgICAgICAgICAoXCJ2YXIgbj1uZXcgdXRpbC5Mb25nKCVpLCVpLCVqKVwiLCBmaWVsZC50eXBlRGVmYXVsdC5sb3csIGZpZWxkLnR5cGVEZWZhdWx0LmhpZ2gsIGZpZWxkLnR5cGVEZWZhdWx0LnVuc2lnbmVkKVxuICAgICAgICAgICAgKFwiZCVzPW8ubG9uZ3M9PT1TdHJpbmc/bi50b1N0cmluZygpOm8ubG9uZ3M9PT1OdW1iZXI/bi50b051bWJlcigpOm5cIiwgcHJvcClcbiAgICAgICAgKFwifWVsc2VcIilcbiAgICAgICAgICAgIChcImQlcz1vLmxvbmdzPT09U3RyaW5nPyVqOiVpXCIsIHByb3AsIGZpZWxkLnR5cGVEZWZhdWx0LnRvU3RyaW5nKCksIGZpZWxkLnR5cGVEZWZhdWx0LnRvTnVtYmVyKCkpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZmllbGQuYnl0ZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJyYXlEZWZhdWx0ID0gXCJbXCIgKyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmaWVsZC50eXBlRGVmYXVsdCkuam9pbihcIixcIikgKyBcIl1cIjtcbiAgICAgICAgICAgICAgICBnZW5cbiAgICAgICAgKFwiaWYoby5ieXRlcz09PVN0cmluZylkJXM9JWpcIiwgcHJvcCwgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGZpZWxkLnR5cGVEZWZhdWx0KSlcbiAgICAgICAgKFwiZWxzZXtcIilcbiAgICAgICAgICAgIChcImQlcz0lc1wiLCBwcm9wLCBhcnJheURlZmF1bHQpXG4gICAgICAgICAgICAoXCJpZihvLmJ5dGVzIT09QXJyYXkpZCVzPXV0aWwubmV3QnVmZmVyKGQlcylcIiwgcHJvcCwgcHJvcClcbiAgICAgICAgKFwifVwiKTtcbiAgICAgICAgICAgIH0gZWxzZSBnZW5cbiAgICAgICAgKFwiZCVzPSVqXCIsIHByb3AsIGZpZWxkLnR5cGVEZWZhdWx0KTsgLy8gYWxzbyBtZXNzYWdlcyAoPW51bGwpXG4gICAgICAgIH0gZ2VuXG4gICAgKFwifVwiKTtcbiAgICB9XG4gICAgdmFyIGhhc0tzMiA9IGZhbHNlO1xuICAgIGZvciAoaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGZpZWxkID0gZmllbGRzW2ldLFxuICAgICAgICAgICAgaW5kZXggPSBtdHlwZS5fZmllbGRzQXJyYXkuaW5kZXhPZihmaWVsZCksXG4gICAgICAgICAgICBwcm9wICA9IHV0aWwuc2FmZVByb3AoZmllbGQubmFtZSk7XG4gICAgICAgIGlmIChmaWVsZC5tYXApIHtcbiAgICAgICAgICAgIGlmICghaGFzS3MyKSB7IGhhc0tzMiA9IHRydWU7IGdlblxuICAgIChcInZhciBrczJcIik7XG4gICAgICAgICAgICB9IGdlblxuICAgIChcImlmKG0lcyYmKGtzMj1PYmplY3Qua2V5cyhtJXMpKS5sZW5ndGgpe1wiLCBwcm9wLCBwcm9wKVxuICAgICAgICAoXCJkJXM9e31cIiwgcHJvcClcbiAgICAgICAgKFwiZm9yKHZhciBqPTA7ajxrczIubGVuZ3RoOysrail7XCIpO1xuICAgICAgICAgICAgZ2VuVmFsdWVQYXJ0aWFsX3RvT2JqZWN0KGdlbiwgZmllbGQsIC8qIHNvcnRlZCAqLyBpbmRleCwgcHJvcCArIFwiW2tzMltqXV1cIilcbiAgICAgICAgKFwifVwiKTtcbiAgICAgICAgfSBlbHNlIGlmIChmaWVsZC5yZXBlYXRlZCkgeyBnZW5cbiAgICAoXCJpZihtJXMmJm0lcy5sZW5ndGgpe1wiLCBwcm9wLCBwcm9wKVxuICAgICAgICAoXCJkJXM9W11cIiwgcHJvcClcbiAgICAgICAgKFwiZm9yKHZhciBqPTA7ajxtJXMubGVuZ3RoOysrail7XCIsIHByb3ApO1xuICAgICAgICAgICAgZ2VuVmFsdWVQYXJ0aWFsX3RvT2JqZWN0KGdlbiwgZmllbGQsIC8qIHNvcnRlZCAqLyBpbmRleCwgcHJvcCArIFwiW2pdXCIpXG4gICAgICAgIChcIn1cIik7XG4gICAgICAgIH0gZWxzZSB7IGdlblxuICAgIChcImlmKG0lcyE9bnVsbCYmbS5oYXNPd25Qcm9wZXJ0eSglaikpe1wiLCBwcm9wLCBmaWVsZC5uYW1lKTsgLy8gIT09IHVuZGVmaW5lZCAmJiAhPT0gbnVsbFxuICAgICAgICBnZW5WYWx1ZVBhcnRpYWxfdG9PYmplY3QoZ2VuLCBmaWVsZCwgLyogc29ydGVkICovIGluZGV4LCBwcm9wKTtcbiAgICAgICAgaWYgKGZpZWxkLnBhcnRPZikgZ2VuXG4gICAgICAgIChcImlmKG8ub25lb2ZzKVwiKVxuICAgICAgICAgICAgKFwiZCVzPSVqXCIsIHV0aWwuc2FmZVByb3AoZmllbGQucGFydE9mLm5hbWUpLCBmaWVsZC5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBnZW5cbiAgICAoXCJ9XCIpO1xuICAgIH1cbiAgICByZXR1cm4gZ2VuXG4gICAgKFwicmV0dXJuIGRcIik7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby11bmV4cGVjdGVkLW11bHRpbGluZSwgYmxvY2stc2NvcGVkLXZhciwgbm8tcmVkZWNsYXJlICovXG59O1xuIl0sIm5hbWVzIjpbImNvbnZlcnRlciIsImV4cG9ydHMiLCJFbnVtIiwicmVxdWlyZSIsInV0aWwiLCJnZW5WYWx1ZVBhcnRpYWxfZnJvbU9iamVjdCIsImdlbiIsImZpZWxkIiwiZmllbGRJbmRleCIsInByb3AiLCJkZWZhdWx0QWxyZWFkeUVtaXR0ZWQiLCJyZXNvbHZlZFR5cGUiLCJ2YWx1ZXMiLCJrZXlzIiwiT2JqZWN0IiwiaSIsImxlbmd0aCIsInR5cGVEZWZhdWx0IiwicmVwZWF0ZWQiLCJmdWxsTmFtZSIsImlzVW5zaWduZWQiLCJ0eXBlIiwiZnJvbU9iamVjdCIsIm10eXBlIiwiZmllbGRzIiwiZmllbGRzQXJyYXkiLCJjb2RlZ2VuIiwibmFtZSIsInJlc29sdmUiLCJzYWZlUHJvcCIsIm1hcCIsImdlblZhbHVlUGFydGlhbF90b09iamVjdCIsInRvT2JqZWN0Iiwic2xpY2UiLCJzb3J0IiwiY29tcGFyZUZpZWxkc0J5SWQiLCJyZXBlYXRlZEZpZWxkcyIsIm1hcEZpZWxkcyIsIm5vcm1hbEZpZWxkcyIsInBhcnRPZiIsInB1c2giLCJ2YWx1ZXNCeUlkIiwibG9uZyIsImxvdyIsImhpZ2giLCJ1bnNpZ25lZCIsInRvU3RyaW5nIiwidG9OdW1iZXIiLCJieXRlcyIsImFycmF5RGVmYXVsdCIsIkFycmF5IiwicHJvdG90eXBlIiwiY2FsbCIsImpvaW4iLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJhcHBseSIsImhhc0tzMiIsImluZGV4IiwiX2ZpZWxkc0FycmF5IiwiaW5kZXhPZiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/protobufjs/src/converter.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/src/decoder.js":
/*!*************************************************!*\
  !*** ../node_modules/protobufjs/src/decoder.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = decoder;\nvar Enum = __webpack_require__(/*! ./enum */ \"(ssr)/../node_modules/protobufjs/src/enum.js\"), types = __webpack_require__(/*! ./types */ \"(ssr)/../node_modules/protobufjs/src/types.js\"), util = __webpack_require__(/*! ./util */ \"(ssr)/../node_modules/protobufjs/src/util.js\");\nfunction missing(field) {\n    return \"missing required '\" + field.name + \"'\";\n}\n/**\n * Generates a decoder specific to the specified message type.\n * @param {Type} mtype Message type\n * @returns {Codegen} Codegen instance\n */ function decoder(mtype) {\n    /* eslint-disable no-unexpected-multiline */ var gen = util.codegen([\n        \"r\",\n        \"l\"\n    ], mtype.name + \"$decode\")(\"if(!(r instanceof Reader))\")(\"r=Reader.create(r)\")(\"var c=l===undefined?r.len:r.pos+l,m=new this.ctor\" + (mtype.fieldsArray.filter(function(field) {\n        return field.map;\n    }).length ? \",k,value\" : \"\"))(\"while(r.pos<c){\")(\"var t=r.uint32()\");\n    if (mtype.group) gen(\"if((t&7)===4)\")(\"break\");\n    gen(\"switch(t>>>3){\");\n    var i = 0;\n    for(; i < /* initializes */ mtype.fieldsArray.length; ++i){\n        var field = mtype._fieldsArray[i].resolve(), type = field.resolvedType instanceof Enum ? \"int32\" : field.type, ref = \"m\" + util.safeProp(field.name);\n        gen(\"case %i: {\", field.id);\n        // Map fields\n        if (field.map) {\n            gen(\"if(%s===util.emptyObject)\", ref)(\"%s={}\", ref)(\"var c2 = r.uint32()+r.pos\");\n            if (types.defaults[field.keyType] !== undefined) gen(\"k=%j\", types.defaults[field.keyType]);\n            else gen(\"k=null\");\n            if (types.defaults[type] !== undefined) gen(\"value=%j\", types.defaults[type]);\n            else gen(\"value=null\");\n            gen(\"while(r.pos<c2){\")(\"var tag2=r.uint32()\")(\"switch(tag2>>>3){\")(\"case 1: k=r.%s(); break\", field.keyType)(\"case 2:\");\n            if (types.basic[type] === undefined) gen(\"value=types[%i].decode(r,r.uint32())\", i); // can't be groups\n            else gen(\"value=r.%s()\", type);\n            gen(\"break\")(\"default:\")(\"r.skipType(tag2&7)\")(\"break\")(\"}\")(\"}\");\n            if (types.long[field.keyType] !== undefined) gen('%s[typeof k===\"object\"?util.longToHash(k):k]=value', ref);\n            else gen(\"%s[k]=value\", ref);\n        // Repeated fields\n        } else if (field.repeated) {\n            gen(\"if(!(%s&&%s.length))\", ref, ref)(\"%s=[]\", ref);\n            // Packable (always check for forward and backward compatiblity)\n            if (types.packed[type] !== undefined) gen(\"if((t&7)===2){\")(\"var c2=r.uint32()+r.pos\")(\"while(r.pos<c2)\")(\"%s.push(r.%s())\", ref, type)(\"}else\");\n            // Non-packed\n            if (types.basic[type] === undefined) gen(field.resolvedType.group ? \"%s.push(types[%i].decode(r))\" : \"%s.push(types[%i].decode(r,r.uint32()))\", ref, i);\n            else gen(\"%s.push(r.%s())\", ref, type);\n        // Non-repeated\n        } else if (types.basic[type] === undefined) gen(field.resolvedType.group ? \"%s=types[%i].decode(r)\" : \"%s=types[%i].decode(r,r.uint32())\", ref, i);\n        else gen(\"%s=r.%s()\", ref, type);\n        gen(\"break\")(\"}\");\n    // Unknown fields\n    }\n    gen(\"default:\")(\"r.skipType(t&7)\")(\"break\")(\"}\")(\"}\");\n    // Field presence\n    for(i = 0; i < mtype._fieldsArray.length; ++i){\n        var rfield = mtype._fieldsArray[i];\n        if (rfield.required) gen(\"if(!m.hasOwnProperty(%j))\", rfield.name)(\"throw util.ProtocolError(%j,{instance:m})\", missing(rfield));\n    }\n    return gen(\"return m\");\n/* eslint-enable no-unexpected-multiline */ }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL2RlY29kZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsT0FBT0MsT0FBTyxHQUFHQztBQUVqQixJQUFJQyxPQUFVQyxtQkFBT0EsQ0FBQyw0REFBUSxHQUMxQkMsUUFBVUQsbUJBQU9BLENBQUMsOERBQVMsR0FDM0JFLE9BQVVGLG1CQUFPQSxDQUFDLDREQUFRO0FBRTlCLFNBQVNHLFFBQVFDLEtBQUs7SUFDbEIsT0FBTyx1QkFBdUJBLE1BQU1DLElBQUksR0FBRztBQUMvQztBQUVBOzs7O0NBSUMsR0FDRCxTQUFTUCxRQUFRUSxLQUFLO0lBQ2xCLDBDQUEwQyxHQUMxQyxJQUFJQyxNQUFNTCxLQUFLTSxPQUFPLENBQUM7UUFBQztRQUFLO0tBQUksRUFBRUYsTUFBTUQsSUFBSSxHQUFHLFdBQy9DLDhCQUNJLHNCQUNKLHNEQUF1REMsQ0FBQUEsTUFBTUcsV0FBVyxDQUFDQyxNQUFNLENBQUMsU0FBU04sS0FBSztRQUFJLE9BQU9BLE1BQU1PLEdBQUc7SUFBRSxHQUFHQyxNQUFNLEdBQUcsYUFBYSxFQUFDLEdBQzlJLG1CQUNJO0lBQ0wsSUFBSU4sTUFBTU8sS0FBSyxFQUFFTixJQUNaLGlCQUNJO0lBQ1RBLElBQ0s7SUFFTCxJQUFJTyxJQUFJO0lBQ1IsTUFBT0EsSUFBSSxlQUFlLEdBQUdSLE1BQU1HLFdBQVcsQ0FBQ0csTUFBTSxFQUFFLEVBQUVFLEVBQUc7UUFDeEQsSUFBSVYsUUFBUUUsTUFBTVMsWUFBWSxDQUFDRCxFQUFFLENBQUNFLE9BQU8sSUFDckNDLE9BQVFiLE1BQU1jLFlBQVksWUFBWW5CLE9BQU8sVUFBVUssTUFBTWEsSUFBSSxFQUNqRUUsTUFBUSxNQUFNakIsS0FBS2tCLFFBQVEsQ0FBQ2hCLE1BQU1DLElBQUk7UUFBR0UsSUFDeEMsY0FBY0gsTUFBTWlCLEVBQUU7UUFFM0IsYUFBYTtRQUNiLElBQUlqQixNQUFNTyxHQUFHLEVBQUU7WUFBRUosSUFDUiw2QkFBNkJZLEtBQ3pCLFNBQVNBLEtBQ2I7WUFFTCxJQUFJbEIsTUFBTXFCLFFBQVEsQ0FBQ2xCLE1BQU1tQixPQUFPLENBQUMsS0FBS0MsV0FBV2pCLElBQzVDLFFBQVFOLE1BQU1xQixRQUFRLENBQUNsQixNQUFNbUIsT0FBTyxDQUFDO2lCQUNyQ2hCLElBQ0E7WUFFTCxJQUFJTixNQUFNcUIsUUFBUSxDQUFDTCxLQUFLLEtBQUtPLFdBQVdqQixJQUNuQyxZQUFZTixNQUFNcUIsUUFBUSxDQUFDTCxLQUFLO2lCQUNoQ1YsSUFDQTtZQUVMQSxJQUNLLG9CQUNJLHVCQUNBLHFCQUNJLDJCQUEyQkgsTUFBTW1CLE9BQU8sRUFDeEM7WUFFYixJQUFJdEIsTUFBTXdCLEtBQUssQ0FBQ1IsS0FBSyxLQUFLTyxXQUFXakIsSUFDcEIsd0NBQXdDTyxJQUFJLGtCQUFrQjtpQkFDMUVQLElBQ1ksZ0JBQWdCVTtZQUVqQ1YsSUFDaUIsU0FDSixZQUNJLHNCQUNBLFNBQ1IsS0FDSjtZQUVMLElBQUlOLE1BQU15QixJQUFJLENBQUN0QixNQUFNbUIsT0FBTyxDQUFDLEtBQUtDLFdBQVdqQixJQUN4QyxzREFBd0RZO2lCQUN4RFosSUFDQSxlQUFlWTtRQUV4QixrQkFBa0I7UUFDbEIsT0FBTyxJQUFJZixNQUFNdUIsUUFBUSxFQUFFO1lBQUVwQixJQUVwQix3QkFBd0JZLEtBQUtBLEtBQ3pCLFNBQVNBO1lBRWxCLGdFQUFnRTtZQUNoRSxJQUFJbEIsTUFBTTJCLE1BQU0sQ0FBQ1gsS0FBSyxLQUFLTyxXQUFXakIsSUFDakMsa0JBQ0ksMkJBQ0EsbUJBQ0ksbUJBQW1CWSxLQUFLRixNQUNoQztZQUVMLGFBQWE7WUFDYixJQUFJaEIsTUFBTXdCLEtBQUssQ0FBQ1IsS0FBSyxLQUFLTyxXQUFXakIsSUFBSUgsTUFBTWMsWUFBWSxDQUFDTCxLQUFLLEdBQ3ZELGlDQUNBLDJDQUEyQ00sS0FBS0w7aUJBQ3JEUCxJQUNJLG1CQUFtQlksS0FBS0Y7UUFFckMsZUFBZTtRQUNmLE9BQU8sSUFBSWhCLE1BQU13QixLQUFLLENBQUNSLEtBQUssS0FBS08sV0FBV2pCLElBQUlILE1BQU1jLFlBQVksQ0FBQ0wsS0FBSyxHQUM5RCwyQkFDQSxxQ0FBcUNNLEtBQUtMO2FBQy9DUCxJQUNJLGFBQWFZLEtBQUtGO1FBQzNCVixJQUNTLFNBQ0o7SUFDTCxpQkFBaUI7SUFDckI7SUFBRUEsSUFDTyxZQUNJLG1CQUNBLFNBRVIsS0FDSjtJQUVELGlCQUFpQjtJQUNqQixJQUFLTyxJQUFJLEdBQUdBLElBQUlSLE1BQU1TLFlBQVksQ0FBQ0gsTUFBTSxFQUFFLEVBQUVFLEVBQUc7UUFDNUMsSUFBSWUsU0FBU3ZCLE1BQU1TLFlBQVksQ0FBQ0QsRUFBRTtRQUNsQyxJQUFJZSxPQUFPQyxRQUFRLEVBQUV2QixJQUN4Qiw2QkFBNkJzQixPQUFPeEIsSUFBSSxFQUNwQyw2Q0FBNkNGLFFBQVEwQjtJQUMxRDtJQUVBLE9BQU90QixJQUNOO0FBQ0QseUNBQXlDLEdBQzdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9kZWNvZGVyLmpzPzgxNWUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGRlY29kZXI7XG5cbnZhciBFbnVtICAgID0gcmVxdWlyZShcIi4vZW51bVwiKSxcbiAgICB0eXBlcyAgID0gcmVxdWlyZShcIi4vdHlwZXNcIiksXG4gICAgdXRpbCAgICA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbmZ1bmN0aW9uIG1pc3NpbmcoZmllbGQpIHtcbiAgICByZXR1cm4gXCJtaXNzaW5nIHJlcXVpcmVkICdcIiArIGZpZWxkLm5hbWUgKyBcIidcIjtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBkZWNvZGVyIHNwZWNpZmljIHRvIHRoZSBzcGVjaWZpZWQgbWVzc2FnZSB0eXBlLlxuICogQHBhcmFtIHtUeXBlfSBtdHlwZSBNZXNzYWdlIHR5cGVcbiAqIEByZXR1cm5zIHtDb2RlZ2VufSBDb2RlZ2VuIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGRlY29kZXIobXR5cGUpIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bmV4cGVjdGVkLW11bHRpbGluZSAqL1xuICAgIHZhciBnZW4gPSB1dGlsLmNvZGVnZW4oW1wiclwiLCBcImxcIl0sIG10eXBlLm5hbWUgKyBcIiRkZWNvZGVcIilcbiAgICAoXCJpZighKHIgaW5zdGFuY2VvZiBSZWFkZXIpKVwiKVxuICAgICAgICAoXCJyPVJlYWRlci5jcmVhdGUocilcIilcbiAgICAoXCJ2YXIgYz1sPT09dW5kZWZpbmVkP3IubGVuOnIucG9zK2wsbT1uZXcgdGhpcy5jdG9yXCIgKyAobXR5cGUuZmllbGRzQXJyYXkuZmlsdGVyKGZ1bmN0aW9uKGZpZWxkKSB7IHJldHVybiBmaWVsZC5tYXA7IH0pLmxlbmd0aCA/IFwiLGssdmFsdWVcIiA6IFwiXCIpKVxuICAgIChcIndoaWxlKHIucG9zPGMpe1wiKVxuICAgICAgICAoXCJ2YXIgdD1yLnVpbnQzMigpXCIpO1xuICAgIGlmIChtdHlwZS5ncm91cCkgZ2VuXG4gICAgICAgIChcImlmKCh0JjcpPT09NClcIilcbiAgICAgICAgICAgIChcImJyZWFrXCIpO1xuICAgIGdlblxuICAgICAgICAoXCJzd2l0Y2godD4+PjMpe1wiKTtcblxuICAgIHZhciBpID0gMDtcbiAgICBmb3IgKDsgaSA8IC8qIGluaXRpYWxpemVzICovIG10eXBlLmZpZWxkc0FycmF5Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBmaWVsZCA9IG10eXBlLl9maWVsZHNBcnJheVtpXS5yZXNvbHZlKCksXG4gICAgICAgICAgICB0eXBlICA9IGZpZWxkLnJlc29sdmVkVHlwZSBpbnN0YW5jZW9mIEVudW0gPyBcImludDMyXCIgOiBmaWVsZC50eXBlLFxuICAgICAgICAgICAgcmVmICAgPSBcIm1cIiArIHV0aWwuc2FmZVByb3AoZmllbGQubmFtZSk7IGdlblxuICAgICAgICAgICAgKFwiY2FzZSAlaToge1wiLCBmaWVsZC5pZCk7XG5cbiAgICAgICAgLy8gTWFwIGZpZWxkc1xuICAgICAgICBpZiAoZmllbGQubWFwKSB7IGdlblxuICAgICAgICAgICAgICAgIChcImlmKCVzPT09dXRpbC5lbXB0eU9iamVjdClcIiwgcmVmKVxuICAgICAgICAgICAgICAgICAgICAoXCIlcz17fVwiLCByZWYpXG4gICAgICAgICAgICAgICAgKFwidmFyIGMyID0gci51aW50MzIoKStyLnBvc1wiKTtcblxuICAgICAgICAgICAgaWYgKHR5cGVzLmRlZmF1bHRzW2ZpZWxkLmtleVR5cGVdICE9PSB1bmRlZmluZWQpIGdlblxuICAgICAgICAgICAgICAgIChcIms9JWpcIiwgdHlwZXMuZGVmYXVsdHNbZmllbGQua2V5VHlwZV0pO1xuICAgICAgICAgICAgZWxzZSBnZW5cbiAgICAgICAgICAgICAgICAoXCJrPW51bGxcIik7XG5cbiAgICAgICAgICAgIGlmICh0eXBlcy5kZWZhdWx0c1t0eXBlXSAhPT0gdW5kZWZpbmVkKSBnZW5cbiAgICAgICAgICAgICAgICAoXCJ2YWx1ZT0lalwiLCB0eXBlcy5kZWZhdWx0c1t0eXBlXSk7XG4gICAgICAgICAgICBlbHNlIGdlblxuICAgICAgICAgICAgICAgIChcInZhbHVlPW51bGxcIik7XG5cbiAgICAgICAgICAgIGdlblxuICAgICAgICAgICAgICAgIChcIndoaWxlKHIucG9zPGMyKXtcIilcbiAgICAgICAgICAgICAgICAgICAgKFwidmFyIHRhZzI9ci51aW50MzIoKVwiKVxuICAgICAgICAgICAgICAgICAgICAoXCJzd2l0Y2godGFnMj4+PjMpe1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgKFwiY2FzZSAxOiBrPXIuJXMoKTsgYnJlYWtcIiwgZmllbGQua2V5VHlwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIChcImNhc2UgMjpcIik7XG5cbiAgICAgICAgICAgIGlmICh0eXBlcy5iYXNpY1t0eXBlXSA9PT0gdW5kZWZpbmVkKSBnZW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXCJ2YWx1ZT10eXBlc1slaV0uZGVjb2RlKHIsci51aW50MzIoKSlcIiwgaSk7IC8vIGNhbid0IGJlIGdyb3Vwc1xuICAgICAgICAgICAgZWxzZSBnZW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXCJ2YWx1ZT1yLiVzKClcIiwgdHlwZSk7XG5cbiAgICAgICAgICAgIGdlblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChcImJyZWFrXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAoXCJkZWZhdWx0OlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChcInIuc2tpcFR5cGUodGFnMiY3KVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChcImJyZWFrXCIpXG4gICAgICAgICAgICAgICAgICAgIChcIn1cIilcbiAgICAgICAgICAgICAgICAoXCJ9XCIpO1xuXG4gICAgICAgICAgICBpZiAodHlwZXMubG9uZ1tmaWVsZC5rZXlUeXBlXSAhPT0gdW5kZWZpbmVkKSBnZW5cbiAgICAgICAgICAgICAgICAoXCIlc1t0eXBlb2Ygaz09PVxcXCJvYmplY3RcXFwiP3V0aWwubG9uZ1RvSGFzaChrKTprXT12YWx1ZVwiLCByZWYpO1xuICAgICAgICAgICAgZWxzZSBnZW5cbiAgICAgICAgICAgICAgICAoXCIlc1trXT12YWx1ZVwiLCByZWYpO1xuXG4gICAgICAgIC8vIFJlcGVhdGVkIGZpZWxkc1xuICAgICAgICB9IGVsc2UgaWYgKGZpZWxkLnJlcGVhdGVkKSB7IGdlblxuXG4gICAgICAgICAgICAgICAgKFwiaWYoISglcyYmJXMubGVuZ3RoKSlcIiwgcmVmLCByZWYpXG4gICAgICAgICAgICAgICAgICAgIChcIiVzPVtdXCIsIHJlZik7XG5cbiAgICAgICAgICAgIC8vIFBhY2thYmxlIChhbHdheXMgY2hlY2sgZm9yIGZvcndhcmQgYW5kIGJhY2t3YXJkIGNvbXBhdGlibGl0eSlcbiAgICAgICAgICAgIGlmICh0eXBlcy5wYWNrZWRbdHlwZV0gIT09IHVuZGVmaW5lZCkgZ2VuXG4gICAgICAgICAgICAgICAgKFwiaWYoKHQmNyk9PT0yKXtcIilcbiAgICAgICAgICAgICAgICAgICAgKFwidmFyIGMyPXIudWludDMyKCkrci5wb3NcIilcbiAgICAgICAgICAgICAgICAgICAgKFwid2hpbGUoci5wb3M8YzIpXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAoXCIlcy5wdXNoKHIuJXMoKSlcIiwgcmVmLCB0eXBlKVxuICAgICAgICAgICAgICAgIChcIn1lbHNlXCIpO1xuXG4gICAgICAgICAgICAvLyBOb24tcGFja2VkXG4gICAgICAgICAgICBpZiAodHlwZXMuYmFzaWNbdHlwZV0gPT09IHVuZGVmaW5lZCkgZ2VuKGZpZWxkLnJlc29sdmVkVHlwZS5ncm91cFxuICAgICAgICAgICAgICAgICAgICA/IFwiJXMucHVzaCh0eXBlc1slaV0uZGVjb2RlKHIpKVwiXG4gICAgICAgICAgICAgICAgICAgIDogXCIlcy5wdXNoKHR5cGVzWyVpXS5kZWNvZGUocixyLnVpbnQzMigpKSlcIiwgcmVmLCBpKTtcbiAgICAgICAgICAgIGVsc2UgZ2VuXG4gICAgICAgICAgICAgICAgICAgIChcIiVzLnB1c2goci4lcygpKVwiLCByZWYsIHR5cGUpO1xuXG4gICAgICAgIC8vIE5vbi1yZXBlYXRlZFxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVzLmJhc2ljW3R5cGVdID09PSB1bmRlZmluZWQpIGdlbihmaWVsZC5yZXNvbHZlZFR5cGUuZ3JvdXBcbiAgICAgICAgICAgICAgICA/IFwiJXM9dHlwZXNbJWldLmRlY29kZShyKVwiXG4gICAgICAgICAgICAgICAgOiBcIiVzPXR5cGVzWyVpXS5kZWNvZGUocixyLnVpbnQzMigpKVwiLCByZWYsIGkpO1xuICAgICAgICBlbHNlIGdlblxuICAgICAgICAgICAgICAgIChcIiVzPXIuJXMoKVwiLCByZWYsIHR5cGUpO1xuICAgICAgICBnZW5cbiAgICAgICAgICAgICAgICAoXCJicmVha1wiKVxuICAgICAgICAgICAgKFwifVwiKTtcbiAgICAgICAgLy8gVW5rbm93biBmaWVsZHNcbiAgICB9IGdlblxuICAgICAgICAgICAgKFwiZGVmYXVsdDpcIilcbiAgICAgICAgICAgICAgICAoXCJyLnNraXBUeXBlKHQmNylcIilcbiAgICAgICAgICAgICAgICAoXCJicmVha1wiKVxuXG4gICAgICAgIChcIn1cIilcbiAgICAoXCJ9XCIpO1xuXG4gICAgLy8gRmllbGQgcHJlc2VuY2VcbiAgICBmb3IgKGkgPSAwOyBpIDwgbXR5cGUuX2ZpZWxkc0FycmF5Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciByZmllbGQgPSBtdHlwZS5fZmllbGRzQXJyYXlbaV07XG4gICAgICAgIGlmIChyZmllbGQucmVxdWlyZWQpIGdlblxuICAgIChcImlmKCFtLmhhc093blByb3BlcnR5KCVqKSlcIiwgcmZpZWxkLm5hbWUpXG4gICAgICAgIChcInRocm93IHV0aWwuUHJvdG9jb2xFcnJvciglaix7aW5zdGFuY2U6bX0pXCIsIG1pc3NpbmcocmZpZWxkKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdlblxuICAgIChcInJldHVybiBtXCIpO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmUgKi9cbn1cbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwiZGVjb2RlciIsIkVudW0iLCJyZXF1aXJlIiwidHlwZXMiLCJ1dGlsIiwibWlzc2luZyIsImZpZWxkIiwibmFtZSIsIm10eXBlIiwiZ2VuIiwiY29kZWdlbiIsImZpZWxkc0FycmF5IiwiZmlsdGVyIiwibWFwIiwibGVuZ3RoIiwiZ3JvdXAiLCJpIiwiX2ZpZWxkc0FycmF5IiwicmVzb2x2ZSIsInR5cGUiLCJyZXNvbHZlZFR5cGUiLCJyZWYiLCJzYWZlUHJvcCIsImlkIiwiZGVmYXVsdHMiLCJrZXlUeXBlIiwidW5kZWZpbmVkIiwiYmFzaWMiLCJsb25nIiwicmVwZWF0ZWQiLCJwYWNrZWQiLCJyZmllbGQiLCJyZXF1aXJlZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/protobufjs/src/decoder.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/src/encoder.js":
/*!*************************************************!*\
  !*** ../node_modules/protobufjs/src/encoder.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = encoder;\nvar Enum = __webpack_require__(/*! ./enum */ \"(ssr)/../node_modules/protobufjs/src/enum.js\"), types = __webpack_require__(/*! ./types */ \"(ssr)/../node_modules/protobufjs/src/types.js\"), util = __webpack_require__(/*! ./util */ \"(ssr)/../node_modules/protobufjs/src/util.js\");\n/**\n * Generates a partial message type encoder.\n * @param {Codegen} gen Codegen instance\n * @param {Field} field Reflected field\n * @param {number} fieldIndex Field index\n * @param {string} ref Variable reference\n * @returns {Codegen} Codegen instance\n * @ignore\n */ function genTypePartial(gen, field, fieldIndex, ref) {\n    return field.resolvedType.group ? gen(\"types[%i].encode(%s,w.uint32(%i)).uint32(%i)\", fieldIndex, ref, (field.id << 3 | 3) >>> 0, (field.id << 3 | 4) >>> 0) : gen(\"types[%i].encode(%s,w.uint32(%i).fork()).ldelim()\", fieldIndex, ref, (field.id << 3 | 2) >>> 0);\n}\n/**\n * Generates an encoder specific to the specified message type.\n * @param {Type} mtype Message type\n * @returns {Codegen} Codegen instance\n */ function encoder(mtype) {\n    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */ var gen = util.codegen([\n        \"m\",\n        \"w\"\n    ], mtype.name + \"$encode\")(\"if(!w)\")(\"w=Writer.create()\");\n    var i, ref;\n    // \"when a message is serialized its known fields should be written sequentially by field number\"\n    var fields = /* initializes */ mtype.fieldsArray.slice().sort(util.compareFieldsById);\n    for(var i = 0; i < fields.length; ++i){\n        var field = fields[i].resolve(), index = mtype._fieldsArray.indexOf(field), type = field.resolvedType instanceof Enum ? \"int32\" : field.type, wireType = types.basic[type];\n        ref = \"m\" + util.safeProp(field.name);\n        // Map fields\n        if (field.map) {\n            gen(\"if(%s!=null&&Object.hasOwnProperty.call(m,%j)){\", ref, field.name) // !== undefined && !== null\n            (\"for(var ks=Object.keys(%s),i=0;i<ks.length;++i){\", ref)(\"w.uint32(%i).fork().uint32(%i).%s(ks[i])\", (field.id << 3 | 2) >>> 0, 8 | types.mapKey[field.keyType], field.keyType);\n            if (wireType === undefined) gen(\"types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()\", index, ref); // can't be groups\n            else gen(\".uint32(%i).%s(%s[ks[i]]).ldelim()\", 16 | wireType, type, ref);\n            gen(\"}\")(\"}\");\n        // Repeated fields\n        } else if (field.repeated) {\n            gen(\"if(%s!=null&&%s.length){\", ref, ref); // !== undefined && !== null\n            // Packed repeated\n            if (field.packed && types.packed[type] !== undefined) {\n                gen(\"w.uint32(%i).fork()\", (field.id << 3 | 2) >>> 0)(\"for(var i=0;i<%s.length;++i)\", ref)(\"w.%s(%s[i])\", type, ref)(\"w.ldelim()\");\n            // Non-packed\n            } else {\n                gen(\"for(var i=0;i<%s.length;++i)\", ref);\n                if (wireType === undefined) genTypePartial(gen, field, index, ref + \"[i]\");\n                else gen(\"w.uint32(%i).%s(%s[i])\", (field.id << 3 | wireType) >>> 0, type, ref);\n            }\n            gen(\"}\");\n        // Non-repeated\n        } else {\n            if (field.optional) gen(\"if(%s!=null&&Object.hasOwnProperty.call(m,%j))\", ref, field.name); // !== undefined && !== null\n            if (wireType === undefined) genTypePartial(gen, field, index, ref);\n            else gen(\"w.uint32(%i).%s(%s)\", (field.id << 3 | wireType) >>> 0, type, ref);\n        }\n    }\n    return gen(\"return w\");\n/* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */ }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL2VuY29kZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsT0FBT0MsT0FBTyxHQUFHQztBQUVqQixJQUFJQyxPQUFXQyxtQkFBT0EsQ0FBQyw0REFBUSxHQUMzQkMsUUFBV0QsbUJBQU9BLENBQUMsOERBQVMsR0FDNUJFLE9BQVdGLG1CQUFPQSxDQUFDLDREQUFRO0FBRS9COzs7Ozs7OztDQVFDLEdBQ0QsU0FBU0csZUFBZUMsR0FBRyxFQUFFQyxLQUFLLEVBQUVDLFVBQVUsRUFBRUMsR0FBRztJQUMvQyxPQUFPRixNQUFNRyxZQUFZLENBQUNDLEtBQUssR0FDekJMLElBQUksZ0RBQWdERSxZQUFZQyxLQUFLLENBQUNGLE1BQU1LLEVBQUUsSUFBSSxJQUFJLE9BQU8sR0FBRyxDQUFDTCxNQUFNSyxFQUFFLElBQUksSUFBSSxPQUFPLEtBQ3hITixJQUFJLHFEQUFxREUsWUFBWUMsS0FBSyxDQUFDRixNQUFNSyxFQUFFLElBQUksSUFBSSxPQUFPO0FBQzVHO0FBRUE7Ozs7Q0FJQyxHQUNELFNBQVNaLFFBQVFhLEtBQUs7SUFDbEIsMEVBQTBFLEdBQzFFLElBQUlQLE1BQU1GLEtBQUtVLE9BQU8sQ0FBQztRQUFDO1FBQUs7S0FBSSxFQUFFRCxNQUFNRSxJQUFJLEdBQUcsV0FDL0MsVUFDSTtJQUVMLElBQUlDLEdBQUdQO0lBRVAsaUdBQWlHO0lBQ2pHLElBQUlRLFNBQVMsZUFBZSxHQUFHSixNQUFNSyxXQUFXLENBQUNDLEtBQUssR0FBR0MsSUFBSSxDQUFDaEIsS0FBS2lCLGlCQUFpQjtJQUVwRixJQUFLLElBQUlMLElBQUksR0FBR0EsSUFBSUMsT0FBT0ssTUFBTSxFQUFFLEVBQUVOLEVBQUc7UUFDcEMsSUFBSVQsUUFBV1UsTUFBTSxDQUFDRCxFQUFFLENBQUNPLE9BQU8sSUFDNUJDLFFBQVdYLE1BQU1ZLFlBQVksQ0FBQ0MsT0FBTyxDQUFDbkIsUUFDdENvQixPQUFXcEIsTUFBTUcsWUFBWSxZQUFZVCxPQUFPLFVBQVVNLE1BQU1vQixJQUFJLEVBQ3BFQyxXQUFXekIsTUFBTTBCLEtBQUssQ0FBQ0YsS0FBSztRQUM1QmxCLE1BQVcsTUFBTUwsS0FBSzBCLFFBQVEsQ0FBQ3ZCLE1BQU1RLElBQUk7UUFFN0MsYUFBYTtRQUNiLElBQUlSLE1BQU13QixHQUFHLEVBQUU7WUFDWHpCLElBQ1AsbURBQW1ERyxLQUFLRixNQUFNUSxJQUFJLEVBQUUsNEJBQTRCO2FBQzVGLG9EQUFvRE4sS0FDaEQsNENBQTRDLENBQUNGLE1BQU1LLEVBQUUsSUFBSSxJQUFJLE9BQU8sR0FBRyxJQUFJVCxNQUFNNkIsTUFBTSxDQUFDekIsTUFBTTBCLE9BQU8sQ0FBQyxFQUFFMUIsTUFBTTBCLE9BQU87WUFDdEgsSUFBSUwsYUFBYU0sV0FBVzVCLElBQzNCLHFFQUFxRWtCLE9BQU9mLE1BQU0sa0JBQWtCO2lCQUNoR0gsSUFDSixzQ0FBc0MsS0FBS3NCLFVBQVVELE1BQU1sQjtZQUM1REgsSUFDSCxLQUNKO1FBRU8sa0JBQWtCO1FBQ3RCLE9BQU8sSUFBSUMsTUFBTTRCLFFBQVEsRUFBRTtZQUFFN0IsSUFDaEMsNEJBQTRCRyxLQUFLQSxNQUFNLDRCQUE0QjtZQUU1RCxrQkFBa0I7WUFDbEIsSUFBSUYsTUFBTTZCLE1BQU0sSUFBSWpDLE1BQU1pQyxNQUFNLENBQUNULEtBQUssS0FBS08sV0FBVztnQkFBRTVCLElBRTNELHVCQUF1QixDQUFDQyxNQUFNSyxFQUFFLElBQUksSUFBSSxPQUFPLEdBQy9DLGdDQUFnQ0gsS0FDNUIsZUFBZWtCLE1BQU1sQixLQUN6QjtZQUVHLGFBQWE7WUFDYixPQUFPO2dCQUFFSCxJQUVaLGdDQUFnQ0c7Z0JBQ3pCLElBQUltQixhQUFhTSxXQUNyQjdCLGVBQWVDLEtBQUtDLE9BQU9pQixPQUFPZixNQUFNO3FCQUMvQkgsSUFDUiwwQkFBMEIsQ0FBQ0MsTUFBTUssRUFBRSxJQUFJLElBQUlnQixRQUFPLE1BQU8sR0FBR0QsTUFBTWxCO1lBRW5FO1lBQUVILElBQ1Q7UUFFRyxlQUFlO1FBQ2YsT0FBTztZQUNILElBQUlDLE1BQU04QixRQUFRLEVBQUUvQixJQUMzQixrREFBa0RHLEtBQUtGLE1BQU1RLElBQUksR0FBRyw0QkFBNEI7WUFFekYsSUFBSWEsYUFBYU0sV0FDckI3QixlQUFlQyxLQUFLQyxPQUFPaUIsT0FBT2Y7aUJBQ3pCSCxJQUNSLHVCQUF1QixDQUFDQyxNQUFNSyxFQUFFLElBQUksSUFBSWdCLFFBQU8sTUFBTyxHQUFHRCxNQUFNbEI7UUFFaEU7SUFDSjtJQUVBLE9BQU9ILElBQ047QUFDRCx5RUFBeUUsR0FDN0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL2VuY29kZXIuanM/NzA4NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZW5jb2RlcjtcblxudmFyIEVudW0gICAgID0gcmVxdWlyZShcIi4vZW51bVwiKSxcbiAgICB0eXBlcyAgICA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpLFxuICAgIHV0aWwgICAgID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBwYXJ0aWFsIG1lc3NhZ2UgdHlwZSBlbmNvZGVyLlxuICogQHBhcmFtIHtDb2RlZ2VufSBnZW4gQ29kZWdlbiBpbnN0YW5jZVxuICogQHBhcmFtIHtGaWVsZH0gZmllbGQgUmVmbGVjdGVkIGZpZWxkXG4gKiBAcGFyYW0ge251bWJlcn0gZmllbGRJbmRleCBGaWVsZCBpbmRleFxuICogQHBhcmFtIHtzdHJpbmd9IHJlZiBWYXJpYWJsZSByZWZlcmVuY2VcbiAqIEByZXR1cm5zIHtDb2RlZ2VufSBDb2RlZ2VuIGluc3RhbmNlXG4gKiBAaWdub3JlXG4gKi9cbmZ1bmN0aW9uIGdlblR5cGVQYXJ0aWFsKGdlbiwgZmllbGQsIGZpZWxkSW5kZXgsIHJlZikge1xuICAgIHJldHVybiBmaWVsZC5yZXNvbHZlZFR5cGUuZ3JvdXBcbiAgICAgICAgPyBnZW4oXCJ0eXBlc1slaV0uZW5jb2RlKCVzLHcudWludDMyKCVpKSkudWludDMyKCVpKVwiLCBmaWVsZEluZGV4LCByZWYsIChmaWVsZC5pZCA8PCAzIHwgMykgPj4+IDAsIChmaWVsZC5pZCA8PCAzIHwgNCkgPj4+IDApXG4gICAgICAgIDogZ2VuKFwidHlwZXNbJWldLmVuY29kZSglcyx3LnVpbnQzMiglaSkuZm9yaygpKS5sZGVsaW0oKVwiLCBmaWVsZEluZGV4LCByZWYsIChmaWVsZC5pZCA8PCAzIHwgMikgPj4+IDApO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhbiBlbmNvZGVyIHNwZWNpZmljIHRvIHRoZSBzcGVjaWZpZWQgbWVzc2FnZSB0eXBlLlxuICogQHBhcmFtIHtUeXBlfSBtdHlwZSBNZXNzYWdlIHR5cGVcbiAqIEByZXR1cm5zIHtDb2RlZ2VufSBDb2RlZ2VuIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGVuY29kZXIobXR5cGUpIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bmV4cGVjdGVkLW11bHRpbGluZSwgYmxvY2stc2NvcGVkLXZhciwgbm8tcmVkZWNsYXJlICovXG4gICAgdmFyIGdlbiA9IHV0aWwuY29kZWdlbihbXCJtXCIsIFwid1wiXSwgbXR5cGUubmFtZSArIFwiJGVuY29kZVwiKVxuICAgIChcImlmKCF3KVwiKVxuICAgICAgICAoXCJ3PVdyaXRlci5jcmVhdGUoKVwiKTtcblxuICAgIHZhciBpLCByZWY7XG5cbiAgICAvLyBcIndoZW4gYSBtZXNzYWdlIGlzIHNlcmlhbGl6ZWQgaXRzIGtub3duIGZpZWxkcyBzaG91bGQgYmUgd3JpdHRlbiBzZXF1ZW50aWFsbHkgYnkgZmllbGQgbnVtYmVyXCJcbiAgICB2YXIgZmllbGRzID0gLyogaW5pdGlhbGl6ZXMgKi8gbXR5cGUuZmllbGRzQXJyYXkuc2xpY2UoKS5zb3J0KHV0aWwuY29tcGFyZUZpZWxkc0J5SWQpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGZpZWxkICAgID0gZmllbGRzW2ldLnJlc29sdmUoKSxcbiAgICAgICAgICAgIGluZGV4ICAgID0gbXR5cGUuX2ZpZWxkc0FycmF5LmluZGV4T2YoZmllbGQpLFxuICAgICAgICAgICAgdHlwZSAgICAgPSBmaWVsZC5yZXNvbHZlZFR5cGUgaW5zdGFuY2VvZiBFbnVtID8gXCJpbnQzMlwiIDogZmllbGQudHlwZSxcbiAgICAgICAgICAgIHdpcmVUeXBlID0gdHlwZXMuYmFzaWNbdHlwZV07XG4gICAgICAgICAgICByZWYgICAgICA9IFwibVwiICsgdXRpbC5zYWZlUHJvcChmaWVsZC5uYW1lKTtcblxuICAgICAgICAvLyBNYXAgZmllbGRzXG4gICAgICAgIGlmIChmaWVsZC5tYXApIHtcbiAgICAgICAgICAgIGdlblxuICAgIChcImlmKCVzIT1udWxsJiZPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtLCVqKSl7XCIsIHJlZiwgZmllbGQubmFtZSkgLy8gIT09IHVuZGVmaW5lZCAmJiAhPT0gbnVsbFxuICAgICAgICAoXCJmb3IodmFyIGtzPU9iamVjdC5rZXlzKCVzKSxpPTA7aTxrcy5sZW5ndGg7KytpKXtcIiwgcmVmKVxuICAgICAgICAgICAgKFwidy51aW50MzIoJWkpLmZvcmsoKS51aW50MzIoJWkpLiVzKGtzW2ldKVwiLCAoZmllbGQuaWQgPDwgMyB8IDIpID4+PiAwLCA4IHwgdHlwZXMubWFwS2V5W2ZpZWxkLmtleVR5cGVdLCBmaWVsZC5rZXlUeXBlKTtcbiAgICAgICAgICAgIGlmICh3aXJlVHlwZSA9PT0gdW5kZWZpbmVkKSBnZW5cbiAgICAgICAgICAgIChcInR5cGVzWyVpXS5lbmNvZGUoJXNba3NbaV1dLHcudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpLmxkZWxpbSgpXCIsIGluZGV4LCByZWYpOyAvLyBjYW4ndCBiZSBncm91cHNcbiAgICAgICAgICAgIGVsc2UgZ2VuXG4gICAgICAgICAgICAoXCIudWludDMyKCVpKS4lcyglc1trc1tpXV0pLmxkZWxpbSgpXCIsIDE2IHwgd2lyZVR5cGUsIHR5cGUsIHJlZik7XG4gICAgICAgICAgICBnZW5cbiAgICAgICAgKFwifVwiKVxuICAgIChcIn1cIik7XG5cbiAgICAgICAgICAgIC8vIFJlcGVhdGVkIGZpZWxkc1xuICAgICAgICB9IGVsc2UgaWYgKGZpZWxkLnJlcGVhdGVkKSB7IGdlblxuICAgIChcImlmKCVzIT1udWxsJiYlcy5sZW5ndGgpe1wiLCByZWYsIHJlZik7IC8vICE9PSB1bmRlZmluZWQgJiYgIT09IG51bGxcblxuICAgICAgICAgICAgLy8gUGFja2VkIHJlcGVhdGVkXG4gICAgICAgICAgICBpZiAoZmllbGQucGFja2VkICYmIHR5cGVzLnBhY2tlZFt0eXBlXSAhPT0gdW5kZWZpbmVkKSB7IGdlblxuXG4gICAgICAgIChcIncudWludDMyKCVpKS5mb3JrKClcIiwgKGZpZWxkLmlkIDw8IDMgfCAyKSA+Pj4gMClcbiAgICAgICAgKFwiZm9yKHZhciBpPTA7aTwlcy5sZW5ndGg7KytpKVwiLCByZWYpXG4gICAgICAgICAgICAoXCJ3LiVzKCVzW2ldKVwiLCB0eXBlLCByZWYpXG4gICAgICAgIChcIncubGRlbGltKClcIik7XG5cbiAgICAgICAgICAgIC8vIE5vbi1wYWNrZWRcbiAgICAgICAgICAgIH0gZWxzZSB7IGdlblxuXG4gICAgICAgIChcImZvcih2YXIgaT0wO2k8JXMubGVuZ3RoOysraSlcIiwgcmVmKTtcbiAgICAgICAgICAgICAgICBpZiAod2lyZVR5cGUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIGdlblR5cGVQYXJ0aWFsKGdlbiwgZmllbGQsIGluZGV4LCByZWYgKyBcIltpXVwiKTtcbiAgICAgICAgICAgICAgICBlbHNlIGdlblxuICAgICAgICAgICAgKFwidy51aW50MzIoJWkpLiVzKCVzW2ldKVwiLCAoZmllbGQuaWQgPDwgMyB8IHdpcmVUeXBlKSA+Pj4gMCwgdHlwZSwgcmVmKTtcblxuICAgICAgICAgICAgfSBnZW5cbiAgICAoXCJ9XCIpO1xuXG4gICAgICAgIC8vIE5vbi1yZXBlYXRlZFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGZpZWxkLm9wdGlvbmFsKSBnZW5cbiAgICAoXCJpZiglcyE9bnVsbCYmT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobSwlaikpXCIsIHJlZiwgZmllbGQubmFtZSk7IC8vICE9PSB1bmRlZmluZWQgJiYgIT09IG51bGxcblxuICAgICAgICAgICAgaWYgKHdpcmVUeXBlID09PSB1bmRlZmluZWQpXG4gICAgICAgIGdlblR5cGVQYXJ0aWFsKGdlbiwgZmllbGQsIGluZGV4LCByZWYpO1xuICAgICAgICAgICAgZWxzZSBnZW5cbiAgICAgICAgKFwidy51aW50MzIoJWkpLiVzKCVzKVwiLCAoZmllbGQuaWQgPDwgMyB8IHdpcmVUeXBlKSA+Pj4gMCwgdHlwZSwgcmVmKTtcblxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGdlblxuICAgIChcInJldHVybiB3XCIpO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmUsIGJsb2NrLXNjb3BlZC12YXIsIG5vLXJlZGVjbGFyZSAqL1xufVxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJlbmNvZGVyIiwiRW51bSIsInJlcXVpcmUiLCJ0eXBlcyIsInV0aWwiLCJnZW5UeXBlUGFydGlhbCIsImdlbiIsImZpZWxkIiwiZmllbGRJbmRleCIsInJlZiIsInJlc29sdmVkVHlwZSIsImdyb3VwIiwiaWQiLCJtdHlwZSIsImNvZGVnZW4iLCJuYW1lIiwiaSIsImZpZWxkcyIsImZpZWxkc0FycmF5Iiwic2xpY2UiLCJzb3J0IiwiY29tcGFyZUZpZWxkc0J5SWQiLCJsZW5ndGgiLCJyZXNvbHZlIiwiaW5kZXgiLCJfZmllbGRzQXJyYXkiLCJpbmRleE9mIiwidHlwZSIsIndpcmVUeXBlIiwiYmFzaWMiLCJzYWZlUHJvcCIsIm1hcCIsIm1hcEtleSIsImtleVR5cGUiLCJ1bmRlZmluZWQiLCJyZXBlYXRlZCIsInBhY2tlZCIsIm9wdGlvbmFsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/protobufjs/src/encoder.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/src/enum.js":
/*!**********************************************!*\
  !*** ../node_modules/protobufjs/src/enum.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = Enum;\n// extends ReflectionObject\nvar ReflectionObject = __webpack_require__(/*! ./object */ \"(ssr)/../node_modules/protobufjs/src/object.js\");\n((Enum.prototype = Object.create(ReflectionObject.prototype)).constructor = Enum).className = \"Enum\";\nvar Namespace = __webpack_require__(/*! ./namespace */ \"(ssr)/../node_modules/protobufjs/src/namespace.js\"), util = __webpack_require__(/*! ./util */ \"(ssr)/../node_modules/protobufjs/src/util.js\");\n/**\n * Constructs a new enum instance.\n * @classdesc Reflected enum.\n * @extends ReflectionObject\n * @constructor\n * @param {string} name Unique name within its namespace\n * @param {Object.<string,number>} [values] Enum values as an object, by name\n * @param {Object.<string,*>} [options] Declared options\n * @param {string} [comment] The comment for this enum\n * @param {Object.<string,string>} [comments] The value comments for this enum\n * @param {Object.<string,Object<string,*>>|undefined} [valuesOptions] The value options for this enum\n */ function Enum(name, values, options, comment, comments, valuesOptions) {\n    ReflectionObject.call(this, name, options);\n    if (values && typeof values !== \"object\") throw TypeError(\"values must be an object\");\n    /**\n     * Enum values by id.\n     * @type {Object.<number,string>}\n     */ this.valuesById = {};\n    /**\n     * Enum values by name.\n     * @type {Object.<string,number>}\n     */ this.values = Object.create(this.valuesById); // toJSON, marker\n    /**\n     * Enum comment text.\n     * @type {string|null}\n     */ this.comment = comment;\n    /**\n     * Value comment texts, if any.\n     * @type {Object.<string,string>}\n     */ this.comments = comments || {};\n    /**\n     * Values options, if any\n     * @type {Object<string, Object<string, *>>|undefined}\n     */ this.valuesOptions = valuesOptions;\n    /**\n     * Reserved ranges, if any.\n     * @type {Array.<number[]|string>}\n     */ this.reserved = undefined; // toJSON\n    // Note that values inherit valuesById on their prototype which makes them a TypeScript-\n    // compatible enum. This is used by pbts to write actual enum definitions that work for\n    // static and reflection code alike instead of emitting generic object definitions.\n    if (values) {\n        for(var keys = Object.keys(values), i = 0; i < keys.length; ++i)if (typeof values[keys[i]] === \"number\") this.valuesById[this.values[keys[i]] = values[keys[i]]] = keys[i];\n    }\n}\n/**\n * Enum descriptor.\n * @interface IEnum\n * @property {Object.<string,number>} values Enum values\n * @property {Object.<string,*>} [options] Enum options\n */ /**\n * Constructs an enum from an enum descriptor.\n * @param {string} name Enum name\n * @param {IEnum} json Enum descriptor\n * @returns {Enum} Created enum\n * @throws {TypeError} If arguments are invalid\n */ Enum.fromJSON = function fromJSON(name, json) {\n    var enm = new Enum(name, json.values, json.options, json.comment, json.comments);\n    enm.reserved = json.reserved;\n    return enm;\n};\n/**\n * Converts this enum to an enum descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IEnum} Enum descriptor\n */ Enum.prototype.toJSON = function toJSON(toJSONOptions) {\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n    return util.toObject([\n        \"options\",\n        this.options,\n        \"valuesOptions\",\n        this.valuesOptions,\n        \"values\",\n        this.values,\n        \"reserved\",\n        this.reserved && this.reserved.length ? this.reserved : undefined,\n        \"comment\",\n        keepComments ? this.comment : undefined,\n        \"comments\",\n        keepComments ? this.comments : undefined\n    ]);\n};\n/**\n * Adds a value to this enum.\n * @param {string} name Value name\n * @param {number} id Value id\n * @param {string} [comment] Comment, if any\n * @param {Object.<string, *>|undefined} [options] Options, if any\n * @returns {Enum} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If there is already a value with this name or id\n */ Enum.prototype.add = function add(name, id, comment, options) {\n    // utilized by the parser but not by .fromJSON\n    if (!util.isString(name)) throw TypeError(\"name must be a string\");\n    if (!util.isInteger(id)) throw TypeError(\"id must be an integer\");\n    if (this.values[name] !== undefined) throw Error(\"duplicate name '\" + name + \"' in \" + this);\n    if (this.isReservedId(id)) throw Error(\"id \" + id + \" is reserved in \" + this);\n    if (this.isReservedName(name)) throw Error(\"name '\" + name + \"' is reserved in \" + this);\n    if (this.valuesById[id] !== undefined) {\n        if (!(this.options && this.options.allow_alias)) throw Error(\"duplicate id \" + id + \" in \" + this);\n        this.values[name] = id;\n    } else this.valuesById[this.values[name] = id] = name;\n    if (options) {\n        if (this.valuesOptions === undefined) this.valuesOptions = {};\n        this.valuesOptions[name] = options || null;\n    }\n    this.comments[name] = comment || null;\n    return this;\n};\n/**\n * Removes a value from this enum\n * @param {string} name Value name\n * @returns {Enum} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If `name` is not a name of this enum\n */ Enum.prototype.remove = function remove(name) {\n    if (!util.isString(name)) throw TypeError(\"name must be a string\");\n    var val = this.values[name];\n    if (val == null) throw Error(\"name '\" + name + \"' does not exist in \" + this);\n    delete this.valuesById[val];\n    delete this.values[name];\n    delete this.comments[name];\n    if (this.valuesOptions) delete this.valuesOptions[name];\n    return this;\n};\n/**\n * Tests if the specified id is reserved.\n * @param {number} id Id to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */ Enum.prototype.isReservedId = function isReservedId(id) {\n    return Namespace.isReservedId(this.reserved, id);\n};\n/**\n * Tests if the specified name is reserved.\n * @param {string} name Name to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */ Enum.prototype.isReservedName = function isReservedName(name) {\n    return Namespace.isReservedName(this.reserved, name);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL2VudW0uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsT0FBT0MsT0FBTyxHQUFHQztBQUVqQiwyQkFBMkI7QUFDM0IsSUFBSUMsbUJBQW1CQyxtQkFBT0EsQ0FBQyxnRUFBVTtBQUN4QyxFQUFDRixLQUFLRyxTQUFTLEdBQUdDLE9BQU9DLE1BQU0sQ0FBQ0osaUJBQWlCRSxTQUFTLEdBQUdHLFdBQVcsR0FBR04sSUFBRyxFQUFHTyxTQUFTLEdBQUc7QUFFOUYsSUFBSUMsWUFBWU4sbUJBQU9BLENBQUMsc0VBQWEsR0FDakNPLE9BQU9QLG1CQUFPQSxDQUFDLDREQUFRO0FBRTNCOzs7Ozs7Ozs7OztDQVdDLEdBQ0QsU0FBU0YsS0FBS1UsSUFBSSxFQUFFQyxNQUFNLEVBQUVDLE9BQU8sRUFBRUMsT0FBTyxFQUFFQyxRQUFRLEVBQUVDLGFBQWE7SUFDakVkLGlCQUFpQmUsSUFBSSxDQUFDLElBQUksRUFBRU4sTUFBTUU7SUFFbEMsSUFBSUQsVUFBVSxPQUFPQSxXQUFXLFVBQzVCLE1BQU1NLFVBQVU7SUFFcEI7OztLQUdDLEdBQ0QsSUFBSSxDQUFDQyxVQUFVLEdBQUcsQ0FBQztJQUVuQjs7O0tBR0MsR0FDRCxJQUFJLENBQUNQLE1BQU0sR0FBR1AsT0FBT0MsTUFBTSxDQUFDLElBQUksQ0FBQ2EsVUFBVSxHQUFHLGlCQUFpQjtJQUUvRDs7O0tBR0MsR0FDRCxJQUFJLENBQUNMLE9BQU8sR0FBR0E7SUFFZjs7O0tBR0MsR0FDRCxJQUFJLENBQUNDLFFBQVEsR0FBR0EsWUFBWSxDQUFDO0lBRTdCOzs7S0FHQyxHQUNELElBQUksQ0FBQ0MsYUFBYSxHQUFHQTtJQUVyQjs7O0tBR0MsR0FDRCxJQUFJLENBQUNJLFFBQVEsR0FBR0MsV0FBVyxTQUFTO0lBRXBDLHdGQUF3RjtJQUN4Rix1RkFBdUY7SUFDdkYsbUZBQW1GO0lBRW5GLElBQUlULFFBQ0E7UUFBQSxJQUFLLElBQUlVLE9BQU9qQixPQUFPaUIs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O0lBQ2pDLE9BQU8sSUFBSTtBQUNmO0FBRUE7Ozs7OztDQU1DLEdBQ0RiLEtBQUtHLFNBQVMsQ0FBQ3FDLE1BQU0sR0FBRyxTQUFTQSxPQUFPOUIsSUFBSTtJQUV4QyxJQUFJLENBQUNELEtBQUt5QixRQUFRLENBQUN4QixPQUNmLE1BQU1PLFVBQVU7SUFFcEIsSUFBSXdCLE1BQU0sSUFBSSxDQUFDOUIsTUFBTSxDQUFDRCxLQUFLO0lBQzNCLElBQUkrQixPQUFPLE1BQ1AsTUFBTUwsTUFBTSxXQUFXMUIsT0FBTyx5QkFBeUIsSUFBSTtJQUUvRCxPQUFPLElBQUksQ0FBQ1EsVUFBVSxDQUFDdUIsSUFBSTtJQUMzQixPQUFPLElBQUksQ0FBQzlCLE1BQU0sQ0FBQ0QsS0FBSztJQUN4QixPQUFPLElBQUksQ0FBQ0ksUUFBUSxDQUFDSixLQUFLO0lBQzFCLElBQUksSUFBSSxDQUFDSyxhQUFhLEVBQ2xCLE9BQU8sSUFBSSxDQUFDQSxhQUFhLENBQUNMLEtBQUs7SUFFbkMsT0FBTyxJQUFJO0FBQ2Y7QUFFQTs7OztDQUlDLEdBQ0RWLEtBQUtHLFNBQVMsQ0FBQ2tDLFlBQVksR0FBRyxTQUFTQSxhQUFhSixFQUFFO0lBQ2xELE9BQU96QixVQUFVNkIsWUFBWSxDQUFDLElBQUksQ0FBQ2xCLFFBQVEsRUFBRWM7QUFDakQ7QUFFQTs7OztDQUlDLEdBQ0RqQyxLQUFLRyxTQUFTLENBQUNtQyxjQUFjLEdBQUcsU0FBU0EsZUFBZTVCLElBQUk7SUFDeEQsT0FBT0YsVUFBVThCLGNBQWMsQ0FBQyxJQUFJLENBQUNuQixRQUFRLEVBQUVUO0FBQ25EIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9lbnVtLmpzPzU3MWMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IEVudW07XG5cbi8vIGV4dGVuZHMgUmVmbGVjdGlvbk9iamVjdFxudmFyIFJlZmxlY3Rpb25PYmplY3QgPSByZXF1aXJlKFwiLi9vYmplY3RcIik7XG4oKEVudW0ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShSZWZsZWN0aW9uT2JqZWN0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gRW51bSkuY2xhc3NOYW1lID0gXCJFbnVtXCI7XG5cbnZhciBOYW1lc3BhY2UgPSByZXF1aXJlKFwiLi9uYW1lc3BhY2VcIiksXG4gICAgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBlbnVtIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBSZWZsZWN0ZWQgZW51bS5cbiAqIEBleHRlbmRzIFJlZmxlY3Rpb25PYmplY3RcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVW5pcXVlIG5hbWUgd2l0aGluIGl0cyBuYW1lc3BhY2VcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsbnVtYmVyPn0gW3ZhbHVlc10gRW51bSB2YWx1ZXMgYXMgYW4gb2JqZWN0LCBieSBuYW1lXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBbb3B0aW9uc10gRGVjbGFyZWQgb3B0aW9uc1xuICogQHBhcmFtIHtzdHJpbmd9IFtjb21tZW50XSBUaGUgY29tbWVudCBmb3IgdGhpcyBlbnVtXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLHN0cmluZz59IFtjb21tZW50c10gVGhlIHZhbHVlIGNvbW1lbnRzIGZvciB0aGlzIGVudW1cbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsT2JqZWN0PHN0cmluZywqPj58dW5kZWZpbmVkfSBbdmFsdWVzT3B0aW9uc10gVGhlIHZhbHVlIG9wdGlvbnMgZm9yIHRoaXMgZW51bVxuICovXG5mdW5jdGlvbiBFbnVtKG5hbWUsIHZhbHVlcywgb3B0aW9ucywgY29tbWVudCwgY29tbWVudHMsIHZhbHVlc09wdGlvbnMpIHtcbiAgICBSZWZsZWN0aW9uT2JqZWN0LmNhbGwodGhpcywgbmFtZSwgb3B0aW9ucyk7XG5cbiAgICBpZiAodmFsdWVzICYmIHR5cGVvZiB2YWx1ZXMgIT09IFwib2JqZWN0XCIpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcInZhbHVlcyBtdXN0IGJlIGFuIG9iamVjdFwiKTtcblxuICAgIC8qKlxuICAgICAqIEVudW0gdmFsdWVzIGJ5IGlkLlxuICAgICAqIEB0eXBlIHtPYmplY3QuPG51bWJlcixzdHJpbmc+fVxuICAgICAqL1xuICAgIHRoaXMudmFsdWVzQnlJZCA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogRW51bSB2YWx1ZXMgYnkgbmFtZS5cbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsbnVtYmVyPn1cbiAgICAgKi9cbiAgICB0aGlzLnZhbHVlcyA9IE9iamVjdC5jcmVhdGUodGhpcy52YWx1ZXNCeUlkKTsgLy8gdG9KU09OLCBtYXJrZXJcblxuICAgIC8qKlxuICAgICAqIEVudW0gY29tbWVudCB0ZXh0LlxuICAgICAqIEB0eXBlIHtzdHJpbmd8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLmNvbW1lbnQgPSBjb21tZW50O1xuXG4gICAgLyoqXG4gICAgICogVmFsdWUgY29tbWVudCB0ZXh0cywgaWYgYW55LlxuICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZyxzdHJpbmc+fVxuICAgICAqL1xuICAgIHRoaXMuY29tbWVudHMgPSBjb21tZW50cyB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIFZhbHVlcyBvcHRpb25zLCBpZiBhbnlcbiAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgKj4+fHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnZhbHVlc09wdGlvbnMgPSB2YWx1ZXNPcHRpb25zO1xuXG4gICAgLyoqXG4gICAgICogUmVzZXJ2ZWQgcmFuZ2VzLCBpZiBhbnkuXG4gICAgICogQHR5cGUge0FycmF5LjxudW1iZXJbXXxzdHJpbmc+fVxuICAgICAqL1xuICAgIHRoaXMucmVzZXJ2ZWQgPSB1bmRlZmluZWQ7IC8vIHRvSlNPTlxuXG4gICAgLy8gTm90ZSB0aGF0IHZhbHVlcyBpbmhlcml0IHZhbHVlc0J5SWQgb24gdGhlaXIgcHJvdG90eXBlIHdoaWNoIG1ha2VzIHRoZW0gYSBUeXBlU2NyaXB0LVxuICAgIC8vIGNvbXBhdGlibGUgZW51bS4gVGhpcyBpcyB1c2VkIGJ5IHBidHMgdG8gd3JpdGUgYWN0dWFsIGVudW0gZGVmaW5pdGlvbnMgdGhhdCB3b3JrIGZvclxuICAgIC8vIHN0YXRpYyBhbmQgcmVmbGVjdGlvbiBjb2RlIGFsaWtlIGluc3RlYWQgb2YgZW1pdHRpbmcgZ2VuZXJpYyBvYmplY3QgZGVmaW5pdGlvbnMuXG5cbiAgICBpZiAodmFsdWVzKVxuICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZXNba2V5c1tpXV0gPT09IFwibnVtYmVyXCIpIC8vIHVzZSBmb3J3YXJkIGVudHJpZXMgb25seVxuICAgICAgICAgICAgICAgIHRoaXMudmFsdWVzQnlJZFsgdGhpcy52YWx1ZXNba2V5c1tpXV0gPSB2YWx1ZXNba2V5c1tpXV0gXSA9IGtleXNbaV07XG59XG5cbi8qKlxuICogRW51bSBkZXNjcmlwdG9yLlxuICogQGludGVyZmFjZSBJRW51bVxuICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZyxudW1iZXI+fSB2YWx1ZXMgRW51bSB2YWx1ZXNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsKj59IFtvcHRpb25zXSBFbnVtIG9wdGlvbnNcbiAqL1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYW4gZW51bSBmcm9tIGFuIGVudW0gZGVzY3JpcHRvci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEVudW0gbmFtZVxuICogQHBhcmFtIHtJRW51bX0ganNvbiBFbnVtIGRlc2NyaXB0b3JcbiAqIEByZXR1cm5zIHtFbnVtfSBDcmVhdGVkIGVudW1cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYXJndW1lbnRzIGFyZSBpbnZhbGlkXG4gKi9cbkVudW0uZnJvbUpTT04gPSBmdW5jdGlvbiBmcm9tSlNPTihuYW1lLCBqc29uKSB7XG4gICAgdmFyIGVubSA9IG5ldyBFbnVtKG5hbWUsIGpzb24udmFsdWVzLCBqc29uLm9wdGlvbnMsIGpzb24uY29tbWVudCwganNvbi5jb21tZW50cyk7XG4gICAgZW5tLnJlc2VydmVkID0ganNvbi5yZXNlcnZlZDtcbiAgICByZXR1cm4gZW5tO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIGVudW0gdG8gYW4gZW51bSBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtJVG9KU09OT3B0aW9uc30gW3RvSlNPTk9wdGlvbnNdIEpTT04gY29udmVyc2lvbiBvcHRpb25zXG4gKiBAcmV0dXJucyB7SUVudW19IEVudW0gZGVzY3JpcHRvclxuICovXG5FbnVtLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04odG9KU09OT3B0aW9ucykge1xuICAgIHZhciBrZWVwQ29tbWVudHMgPSB0b0pTT05PcHRpb25zID8gQm9vbGVhbih0b0pTT05PcHRpb25zLmtlZXBDb21tZW50cykgOiBmYWxzZTtcbiAgICByZXR1cm4gdXRpbC50b09iamVjdChbXG4gICAgICAgIFwib3B0aW9uc1wiICAgICAgICwgdGhpcy5vcHRpb25zLFxuICAgICAgICBcInZhbHVlc09wdGlvbnNcIiAsIHRoaXMudmFsdWVzT3B0aW9ucyxcbiAgICAgICAgXCJ2YWx1ZXNcIiAgICAgICAgLCB0aGlzLnZhbHVlcyxcbiAgICAgICAgXCJyZXNlcnZlZFwiICAgICAgLCB0aGlzLnJlc2VydmVkICYmIHRoaXMucmVzZXJ2ZWQubGVuZ3RoID8gdGhpcy5yZXNlcnZlZCA6IHVuZGVmaW5lZCxcbiAgICAgICAgXCJjb21tZW50XCIgICAgICAgLCBrZWVwQ29tbWVudHMgPyB0aGlzLmNvbW1lbnQgOiB1bmRlZmluZWQsXG4gICAgICAgIFwiY29tbWVudHNcIiAgICAgICwga2VlcENvbW1lbnRzID8gdGhpcy5jb21tZW50cyA6IHVuZGVmaW5lZFxuICAgIF0pO1xufTtcblxuLyoqXG4gKiBBZGRzIGEgdmFsdWUgdG8gdGhpcyBlbnVtLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVmFsdWUgbmFtZVxuICogQHBhcmFtIHtudW1iZXJ9IGlkIFZhbHVlIGlkXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvbW1lbnRdIENvbW1lbnQsIGlmIGFueVxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgKj58dW5kZWZpbmVkfSBbb3B0aW9uc10gT3B0aW9ucywgaWYgYW55XG4gKiBAcmV0dXJucyB7RW51bX0gYHRoaXNgXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGFyZ3VtZW50cyBhcmUgaW52YWxpZFxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZXJlIGlzIGFscmVhZHkgYSB2YWx1ZSB3aXRoIHRoaXMgbmFtZSBvciBpZFxuICovXG5FbnVtLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQobmFtZSwgaWQsIGNvbW1lbnQsIG9wdGlvbnMpIHtcbiAgICAvLyB1dGlsaXplZCBieSB0aGUgcGFyc2VyIGJ1dCBub3QgYnkgLmZyb21KU09OXG5cbiAgICBpZiAoIXV0aWwuaXNTdHJpbmcobmFtZSkpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcIm5hbWUgbXVzdCBiZSBhIHN0cmluZ1wiKTtcblxuICAgIGlmICghdXRpbC5pc0ludGVnZXIoaWQpKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJpZCBtdXN0IGJlIGFuIGludGVnZXJcIik7XG5cbiAgICBpZiAodGhpcy52YWx1ZXNbbmFtZV0gIT09IHVuZGVmaW5lZClcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJkdXBsaWNhdGUgbmFtZSAnXCIgKyBuYW1lICsgXCInIGluIFwiICsgdGhpcyk7XG5cbiAgICBpZiAodGhpcy5pc1Jlc2VydmVkSWQoaWQpKVxuICAgICAgICB0aHJvdyBFcnJvcihcImlkIFwiICsgaWQgKyBcIiBpcyByZXNlcnZlZCBpbiBcIiArIHRoaXMpO1xuXG4gICAgaWYgKHRoaXMuaXNSZXNlcnZlZE5hbWUobmFtZSkpXG4gICAgICAgIHRocm93IEVycm9yKFwibmFtZSAnXCIgKyBuYW1lICsgXCInIGlzIHJlc2VydmVkIGluIFwiICsgdGhpcyk7XG5cbiAgICBpZiAodGhpcy52YWx1ZXNCeUlkW2lkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghKHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMuYWxsb3dfYWxpYXMpKVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJkdXBsaWNhdGUgaWQgXCIgKyBpZCArIFwiIGluIFwiICsgdGhpcyk7XG4gICAgICAgIHRoaXMudmFsdWVzW25hbWVdID0gaWQ7XG4gICAgfSBlbHNlXG4gICAgICAgIHRoaXMudmFsdWVzQnlJZFt0aGlzLnZhbHVlc1tuYW1lXSA9IGlkXSA9IG5hbWU7XG5cbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcy52YWx1ZXNPcHRpb25zID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aGlzLnZhbHVlc09wdGlvbnMgPSB7fTtcbiAgICAgICAgdGhpcy52YWx1ZXNPcHRpb25zW25hbWVdID0gb3B0aW9ucyB8fCBudWxsO1xuICAgIH1cblxuICAgIHRoaXMuY29tbWVudHNbbmFtZV0gPSBjb21tZW50IHx8IG51bGw7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYSB2YWx1ZSBmcm9tIHRoaXMgZW51bVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVmFsdWUgbmFtZVxuICogQHJldHVybnMge0VudW19IGB0aGlzYFxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBhcmd1bWVudHMgYXJlIGludmFsaWRcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBgbmFtZWAgaXMgbm90IGEgbmFtZSBvZiB0aGlzIGVudW1cbiAqL1xuRW51bS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKG5hbWUpIHtcblxuICAgIGlmICghdXRpbC5pc1N0cmluZyhuYW1lKSlcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwibmFtZSBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuXG4gICAgdmFyIHZhbCA9IHRoaXMudmFsdWVzW25hbWVdO1xuICAgIGlmICh2YWwgPT0gbnVsbClcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJuYW1lICdcIiArIG5hbWUgKyBcIicgZG9lcyBub3QgZXhpc3QgaW4gXCIgKyB0aGlzKTtcblxuICAgIGRlbGV0ZSB0aGlzLnZhbHVlc0J5SWRbdmFsXTtcbiAgICBkZWxldGUgdGhpcy52YWx1ZXNbbmFtZV07XG4gICAgZGVsZXRlIHRoaXMuY29tbWVudHNbbmFtZV07XG4gICAgaWYgKHRoaXMudmFsdWVzT3B0aW9ucylcbiAgICAgICAgZGVsZXRlIHRoaXMudmFsdWVzT3B0aW9uc1tuYW1lXTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIGlkIGlzIHJlc2VydmVkLlxuICogQHBhcmFtIHtudW1iZXJ9IGlkIElkIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgcmVzZXJ2ZWQsIG90aGVyd2lzZSBgZmFsc2VgXG4gKi9cbkVudW0ucHJvdG90eXBlLmlzUmVzZXJ2ZWRJZCA9IGZ1bmN0aW9uIGlzUmVzZXJ2ZWRJZChpZCkge1xuICAgIHJldHVybiBOYW1lc3BhY2UuaXNSZXNlcnZlZElkKHRoaXMucmVzZXJ2ZWQsIGlkKTtcbn07XG5cbi8qKlxuICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCBuYW1lIGlzIHJlc2VydmVkLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHJlc2VydmVkLCBvdGhlcndpc2UgYGZhbHNlYFxuICovXG5FbnVtLnByb3RvdHlwZS5pc1Jlc2VydmVkTmFtZSA9IGZ1bmN0aW9uIGlzUmVzZXJ2ZWROYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gTmFtZXNwYWNlLmlzUmVzZXJ2ZWROYW1lKHRoaXMucmVzZXJ2ZWQsIG5hbWUpO1xufTtcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwiRW51bSIsIlJlZmxlY3Rpb25PYmplY3QiLCJyZXF1aXJlIiwicHJvdG90eXBlIiwiT2JqZWN0IiwiY3JlYXRlIiwiY29uc3RydWN0b3IiLCJjbGFzc05hbWUiLCJOYW1lc3BhY2UiLCJ1dGlsIiwibmFtZSIsInZhbHVlcyIsIm9wdGlvbnMiLCJjb21tZW50IiwiY29tbWVudHMiLCJ2YWx1ZXNPcHRpb25zIiwiY2FsbCIsIlR5cGVFcnJvciIsInZhbHVlc0J5SWQiLCJyZXNlcnZlZCIsInVuZGVmaW5lZCIsImtleXMiLCJpIiwibGVuZ3RoIiwiZnJvbUpTT04iLCJqc29uIiwiZW5tIiwidG9KU09OIiwidG9KU09OT3B0aW9ucyIsImtlZXBDb21tZW50cyIsIkJvb2xlYW4iLCJ0b09iamVjdCIsImFkZCIsImlkIiwiaXNTdHJpbmciLCJpc0ludGVnZXIiLCJFcnJvciIsImlzUmVzZXJ2ZWRJZCIsImlzUmVzZXJ2ZWROYW1lIiwiYWxsb3dfYWxpYXMiLCJyZW1vdmUiLCJ2YWwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/protobufjs/src/enum.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/src/field.js":
/*!***********************************************!*\
  !*** ../node_modules/protobufjs/src/field.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = Field;\n// extends ReflectionObject\nvar ReflectionObject = __webpack_require__(/*! ./object */ \"(ssr)/../node_modules/protobufjs/src/object.js\");\n((Field.prototype = Object.create(ReflectionObject.prototype)).constructor = Field).className = \"Field\";\nvar Enum = __webpack_require__(/*! ./enum */ \"(ssr)/../node_modules/protobufjs/src/enum.js\"), types = __webpack_require__(/*! ./types */ \"(ssr)/../node_modules/protobufjs/src/types.js\"), util = __webpack_require__(/*! ./util */ \"(ssr)/../node_modules/protobufjs/src/util.js\");\nvar Type; // cyclic\nvar ruleRe = /^required|optional|repeated$/;\n/**\n * Constructs a new message field instance. Note that {@link MapField|map fields} have their own class.\n * @name Field\n * @classdesc Reflected message field.\n * @extends FieldBase\n * @constructor\n * @param {string} name Unique name within its namespace\n * @param {number} id Unique id within its namespace\n * @param {string} type Value type\n * @param {string|Object.<string,*>} [rule=\"optional\"] Field rule\n * @param {string|Object.<string,*>} [extend] Extended type if different from parent\n * @param {Object.<string,*>} [options] Declared options\n */ /**\n * Constructs a field from a field descriptor.\n * @param {string} name Field name\n * @param {IField} json Field descriptor\n * @returns {Field} Created field\n * @throws {TypeError} If arguments are invalid\n */ Field.fromJSON = function fromJSON(name, json) {\n    return new Field(name, json.id, json.type, json.rule, json.extend, json.options, json.comment);\n};\n/**\n * Not an actual constructor. Use {@link Field} instead.\n * @classdesc Base class of all reflected message fields. This is not an actual class but here for the sake of having consistent type definitions.\n * @exports FieldBase\n * @extends ReflectionObject\n * @constructor\n * @param {string} name Unique name within its namespace\n * @param {number} id Unique id within its namespace\n * @param {string} type Value type\n * @param {string|Object.<string,*>} [rule=\"optional\"] Field rule\n * @param {string|Object.<string,*>} [extend] Extended type if different from parent\n * @param {Object.<string,*>} [options] Declared options\n * @param {string} [comment] Comment associated with this field\n */ function Field(name, id, type, rule, extend, options, comment) {\n    if (util.isObject(rule)) {\n        comment = extend;\n        options = rule;\n        rule = extend = undefined;\n    } else if (util.isObject(extend)) {\n        comment = options;\n        options = extend;\n        extend = undefined;\n    }\n    ReflectionObject.call(this, name, options);\n    if (!util.isInteger(id) || id < 0) throw TypeError(\"id must be a non-negative integer\");\n    if (!util.isString(type)) throw TypeError(\"type must be a string\");\n    if (rule !== undefined && !ruleRe.test(rule = rule.toString().toLowerCase())) throw TypeError(\"rule must be a string rule\");\n    if (extend !== undefined && !util.isString(extend)) throw TypeError(\"extend must be a string\");\n    /**\n     * Field rule, if any.\n     * @type {string|undefined}\n     */ if (rule === \"proto3_optional\") {\n        rule = \"optional\";\n    }\n    this.rule = rule && rule !== \"optional\" ? rule : undefined; // toJSON\n    /**\n     * Field type.\n     * @type {string}\n     */ this.type = type; // toJSON\n    /**\n     * Unique field id.\n     * @type {number}\n     */ this.id = id; // toJSON, marker\n    /**\n     * Extended type if different from parent.\n     * @type {string|undefined}\n     */ this.extend = extend || undefined; // toJSON\n    /**\n     * Whether this field is required.\n     * @type {boolean}\n     */ this.required = rule === \"required\";\n    /**\n     * Whether this field is optional.\n     * @type {boolean}\n     */ this.optional = !this.required;\n    /**\n     * Whether this field is repeated.\n     * @type {boolean}\n     */ this.repeated = rule === \"repeated\";\n    /**\n     * Whether this field is a map or not.\n     * @type {boolean}\n     */ this.map = false;\n    /**\n     * Message this field belongs to.\n     * @type {Type|null}\n     */ this.message = null;\n    /**\n     * OneOf this field belongs to, if any,\n     * @type {OneOf|null}\n     */ this.partOf = null;\n    /**\n     * The field type's default value.\n     * @type {*}\n     */ this.typeDefault = null;\n    /**\n     * The field's default value on prototypes.\n     * @type {*}\n     */ this.defaultValue = null;\n    /**\n     * Whether this field's value should be treated as a long.\n     * @type {boolean}\n     */ this.long = util.Long ? types.long[type] !== undefined : /* istanbul ignore next */ false;\n    /**\n     * Whether this field's value is a buffer.\n     * @type {boolean}\n     */ this.bytes = type === \"bytes\";\n    /**\n     * Resolved type if not a basic type.\n     * @type {Type|Enum|null}\n     */ this.resolvedType = null;\n    /**\n     * Sister-field within the extended type if a declaring extension field.\n     * @type {Field|null}\n     */ this.extensionField = null;\n    /**\n     * Sister-field within the declaring namespace if an extended field.\n     * @type {Field|null}\n     */ this.declaringField = null;\n    /**\n     * Internally remembers whether this field is packed.\n     * @type {boolean|null}\n     * @private\n     */ this._packed = null;\n    /**\n     * Comment for this field.\n     * @type {string|null}\n     */ this.comment = comment;\n}\n/**\n * Determines whether this field is packed. Only relevant when repeated and working with proto2.\n * @name Field#packed\n * @type {boolean}\n * @readonly\n */ Object.defineProperty(Field.prototype, \"packed\", {\n    get: function() {\n        // defaults to packed=true if not explicity set to false\n        if (this._packed === null) this._packed = this.getOption(\"packed\") !== false;\n        return this._packed;\n    }\n});\n/**\n * @override\n */ Field.prototype.setOption = function setOption(name, value, ifNotSet) {\n    if (name === \"packed\") this._packed = null;\n    return ReflectionObject.prototype.setOption.call(this, name, value, ifNotSet);\n};\n/**\n * Field descriptor.\n * @interface IField\n * @property {string} [rule=\"optional\"] Field rule\n * @property {string} type Field type\n * @property {number} id Field id\n * @property {Object.<string,*>} [options] Field options\n */ /**\n * Extension field descriptor.\n * @interface IExtensionField\n * @extends IField\n * @property {string} extend Extended type\n */ /**\n * Converts this field to a field descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IField} Field descriptor\n */ Field.prototype.toJSON = function toJSON(toJSONOptions) {\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n    return util.toObject([\n        \"rule\",\n        this.rule !== \"optional\" && this.rule || undefined,\n        \"type\",\n        this.type,\n        \"id\",\n        this.id,\n        \"extend\",\n        this.extend,\n        \"options\",\n        this.options,\n        \"comment\",\n        keepComments ? this.comment : undefined\n    ]);\n};\n/**\n * Resolves this field's type references.\n * @returns {Field} `this`\n * @throws {Error} If any reference cannot be resolved\n */ Field.prototype.resolve = function resolve() {\n    if (this.resolved) return this;\n    if ((this.typeDefault = types.defaults[this.type]) === undefined) {\n        this.resolvedType = (this.declaringField ? this.declaringField.parent : this.parent).lookupTypeOrEnum(this.type);\n        if (this.resolvedType instanceof Type) this.typeDefault = null;\n        else this.typeDefault = this.resolvedType.values[Object.keys(this.resolvedType.values)[0]]; // first defined\n    } else if (this.options && this.options.proto3_optional) {\n        // proto3 scalar value marked optional; should default to null\n        this.typeDefault = null;\n    }\n    // use explicitly set default value if present\n    if (this.options && this.options[\"default\"] != null) {\n        this.typeDefault = this.options[\"default\"];\n        if (this.resolvedType instanceof Enum && typeof this.typeDefault === \"string\") this.typeDefault = this.resolvedType.values[this.typeDefault];\n    }\n    // remove unnecessary options\n    if (this.options) {\n        if (this.options.packed === true || this.options.packed !== undefined && this.resolvedType && !(this.resolvedType instanceof Enum)) delete this.options.packed;\n        if (!Object.keys(this.options).length) this.options = undefined;\n    }\n    // convert to internal data type if necesssary\n    if (this.long) {\n        this.typeDefault = util.Long.fromNumber(this.typeDefault, this.type.charAt(0) === \"u\");\n        /* istanbul ignore else */ if (Object.freeze) Object.freeze(this.typeDefault); // long instances are meant to be immutable anyway (i.e. use small int cache that even requires it)\n    } else if (this.bytes && typeof this.typeDefault === \"string\") {\n        var buf;\n        if (util.base64.test(this.typeDefault)) util.base64.decode(this.typeDefault, buf = util.newBuffer(util.base64.length(this.typeDefault)), 0);\n        else util.utf8.write(this.typeDefault, buf = util.newBuffer(util.utf8.length(this.typeDefault)), 0);\n        this.typeDefault = buf;\n    }\n    // take special care of maps and repeated fields\n    if (this.map) this.defaultValue = util.emptyObject;\n    else if (this.repeated) this.defaultValue = util.emptyArray;\n    else this.defaultValue = this.typeDefault;\n    // ensure proper value on prototype\n    if (this.parent instanceof Type) this.parent.ctor.prototype[this.name] = this.defaultValue;\n    return ReflectionObject.prototype.resolve.call(this);\n};\n/**\n * Decorator function as returned by {@link Field.d} and {@link MapField.d} (TypeScript).\n * @typedef FieldDecorator\n * @type {function}\n * @param {Object} prototype Target prototype\n * @param {string} fieldName Field name\n * @returns {undefined}\n */ /**\n * Field decorator (TypeScript).\n * @name Field.d\n * @function\n * @param {number} fieldId Field id\n * @param {\"double\"|\"float\"|\"int32\"|\"uint32\"|\"sint32\"|\"fixed32\"|\"sfixed32\"|\"int64\"|\"uint64\"|\"sint64\"|\"fixed64\"|\"sfixed64\"|\"string\"|\"bool\"|\"bytes\"|Object} fieldType Field type\n * @param {\"optional\"|\"required\"|\"repeated\"} [fieldRule=\"optional\"] Field rule\n * @param {T} [defaultValue] Default value\n * @returns {FieldDecorator} Decorator function\n * @template T extends number | number[] | Long | Long[] | string | string[] | boolean | boolean[] | Uint8Array | Uint8Array[] | Buffer | Buffer[]\n */ Field.d = function decorateField(fieldId, fieldType, fieldRule, defaultValue) {\n    // submessage: decorate the submessage and use its name as the type\n    if (typeof fieldType === \"function\") fieldType = util.decorateType(fieldType).name;\n    else if (fieldType && typeof fieldType === \"object\") fieldType = util.decorateEnum(fieldType).name;\n    return function fieldDecorator(prototype, fieldName) {\n        util.decorateType(prototype.constructor).add(new Field(fieldName, fieldId, fieldType, fieldRule, {\n            \"default\": defaultValue\n        }));\n    };\n};\n/**\n * Field decorator (TypeScript).\n * @name Field.d\n * @function\n * @param {number} fieldId Field id\n * @param {Constructor<T>|string} fieldType Field type\n * @param {\"optional\"|\"required\"|\"repeated\"} [fieldRule=\"optional\"] Field rule\n * @returns {FieldDecorator} Decorator function\n * @template T extends Message<T>\n * @variation 2\n */ // like Field.d but without a default value\n// Sets up cyclic dependencies (called in index-light)\nField._configure = function configure(Type_) {\n    Type = Type_;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL2ZpZWxkLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLE9BQU9DLE9BQU8sR0FBR0M7QUFFakIsMkJBQTJCO0FBQzNCLElBQUlDLG1CQUFtQkMsbUJBQU9BLENBQUMsZ0VBQVU7QUFDeEMsRUFBQ0YsTUFBTUcsU0FBUyxHQUFHQyxPQUFPQyxNQUFNLENBQUNKLGlCQUFpQkUsU0FBUyxHQUFHRyxXQUFXLEdBQUdOLEtBQUksRUFBR08sU0FBUyxHQUFHO0FBRWhHLElBQUlDLE9BQVFOLG1CQUFPQSxDQUFDLDREQUFRLEdBQ3hCTyxRQUFRUCxtQkFBT0EsQ0FBQyw4REFBUyxHQUN6QlEsT0FBUVIsbUJBQU9BLENBQUMsNERBQVE7QUFFNUIsSUFBSVMsTUFBTSxTQUFTO0FBRW5CLElBQUlDLFNBQVM7QUFFYjs7Ozs7Ozs7Ozs7O0NBWUMsR0FFRDs7Ozs7O0NBTUMsR0FDRFosTUFBTWEsUUFBUSxHQUFHLFNBQVNBLFNBQVNDLElBQUksRUFBRUMsSUFBSTtJQUN6QyxPQUFPLElBQUlmLE1BQU1jLE1BQU1DLEtBQUtDLEVBQUUsRUFBRUQsS0FBS0UsSUFBSSxFQUFFRixLQUFLRyxJQUFJLEVBQUVILEtBQUtJLE1BQU0sRUFBRUosS0FBS0ssT0FBTyxFQUFFTCxLQUFLTSxPQUFPO0FBQ2pHO0FBRUE7Ozs7Ozs7Ozs7Ozs7Q0FhQyxHQUNELFNBQVNyQixNQUFNYyxJQUFJLEVBQUVFLEVBQUUsRUFBRUMsSUFBSSxFQUFFQyxJQUFJLEVBQUVDLE1BQU0sRUFBRUMsT0FBTyxFQUFFQyxPQUFPO0lBRXpELElBQUlYLEtBQUtZLFFBQVEsQ0FBQ0osT0FBTztRQUNyQkcsVUFBVUY7UUFDVkMsVUFBVUY7UUFDVkEsT0FBT0MsU0FBU0k7SUFDcEIsT0FBTyxJQUFJYixLQUFLWSxRQUFRLENBQUNILFNBQVM7UUFDOUJFLFVBQVVEO1FBQ1ZBLFVBQVVEO1FBQ1ZBLFNBQVNJO0lBQ2I7SUFFQXRCLGlCQUFpQnVCLElBQUks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R0FBRyxTQUFTQyxjQUFjQyxPQUFPLEVBQUVDLFNBQVMsRUFBRUMsU0FBUyxFQUFFN0MsWUFBWTtJQUV4RSxtRUFBbUU7SUFDbkUsSUFBSSxPQUFPNEMsY0FBYyxZQUNyQkEsWUFBWXhFLEtBQUswRSxZQUFZLENBQUNGLFdBQVdwRSxJQUFJO1NBRzVDLElBQUlvRSxhQUFhLE9BQU9BLGNBQWMsVUFDdkNBLFlBQVl4RSxLQUFLMkUsWUFBWSxDQUFDSCxXQUFXcEUsSUFBSTtJQUVqRCxPQUFPLFNBQVN3RSxlQUFlbkYsU0FBUyxFQUFFb0YsU0FBUztRQUMvQzdFLEtBQUswRSxZQUFZLENBQUNqRixVQUFVRyxXQUFXLEVBQ2xDa0YsR0FBRyxDQUFDLElBQUl4RixNQUFNdUYsV0FBV04sU0FBU0MsV0FBV0MsV0FBVztZQUFFLFdBQVc3QztRQUFhO0lBQzNGO0FBQ0o7QUFFQTs7Ozs7Ozs7OztDQVVDLEdBQ0QsMkNBQTJDO0FBRTNDLHNEQUFzRDtBQUN0RHRDLE1BQU15RixVQUFVLEdBQUcsU0FBU0MsVUFBVUMsS0FBSztJQUN2Q2hGLE9BQU9nRjtBQUNYIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9maWVsZC5qcz9lNTUxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBGaWVsZDtcblxuLy8gZXh0ZW5kcyBSZWZsZWN0aW9uT2JqZWN0XG52YXIgUmVmbGVjdGlvbk9iamVjdCA9IHJlcXVpcmUoXCIuL29iamVjdFwiKTtcbigoRmllbGQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShSZWZsZWN0aW9uT2JqZWN0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gRmllbGQpLmNsYXNzTmFtZSA9IFwiRmllbGRcIjtcblxudmFyIEVudW0gID0gcmVxdWlyZShcIi4vZW51bVwiKSxcbiAgICB0eXBlcyA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpLFxuICAgIHV0aWwgID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcblxudmFyIFR5cGU7IC8vIGN5Y2xpY1xuXG52YXIgcnVsZVJlID0gL15yZXF1aXJlZHxvcHRpb25hbHxyZXBlYXRlZCQvO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgbWVzc2FnZSBmaWVsZCBpbnN0YW5jZS4gTm90ZSB0aGF0IHtAbGluayBNYXBGaWVsZHxtYXAgZmllbGRzfSBoYXZlIHRoZWlyIG93biBjbGFzcy5cbiAqIEBuYW1lIEZpZWxkXG4gKiBAY2xhc3NkZXNjIFJlZmxlY3RlZCBtZXNzYWdlIGZpZWxkLlxuICogQGV4dGVuZHMgRmllbGRCYXNlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFVuaXF1ZSBuYW1lIHdpdGhpbiBpdHMgbmFtZXNwYWNlXG4gKiBAcGFyYW0ge251bWJlcn0gaWQgVW5pcXVlIGlkIHdpdGhpbiBpdHMgbmFtZXNwYWNlXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBWYWx1ZSB0eXBlXG4gKiBAcGFyYW0ge3N0cmluZ3xPYmplY3QuPHN0cmluZywqPn0gW3J1bGU9XCJvcHRpb25hbFwiXSBGaWVsZCBydWxlXG4gKiBAcGFyYW0ge3N0cmluZ3xPYmplY3QuPHN0cmluZywqPn0gW2V4dGVuZF0gRXh0ZW5kZWQgdHlwZSBpZiBkaWZmZXJlbnQgZnJvbSBwYXJlbnRcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IFtvcHRpb25zXSBEZWNsYXJlZCBvcHRpb25zXG4gKi9cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgZmllbGQgZnJvbSBhIGZpZWxkIGRlc2NyaXB0b3IuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBGaWVsZCBuYW1lXG4gKiBAcGFyYW0ge0lGaWVsZH0ganNvbiBGaWVsZCBkZXNjcmlwdG9yXG4gKiBAcmV0dXJucyB7RmllbGR9IENyZWF0ZWQgZmllbGRcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYXJndW1lbnRzIGFyZSBpbnZhbGlkXG4gKi9cbkZpZWxkLmZyb21KU09OID0gZnVuY3Rpb24gZnJvbUpTT04obmFtZSwganNvbikge1xuICAgIHJldHVybiBuZXcgRmllbGQobmFtZSwganNvbi5pZCwganNvbi50eXBlLCBqc29uLnJ1bGUsIGpzb24uZXh0ZW5kLCBqc29uLm9wdGlvbnMsIGpzb24uY29tbWVudCk7XG59O1xuXG4vKipcbiAqIE5vdCBhbiBhY3R1YWwgY29uc3RydWN0b3IuIFVzZSB7QGxpbmsgRmllbGR9IGluc3RlYWQuXG4gKiBAY2xhc3NkZXNjIEJhc2UgY2xhc3Mgb2YgYWxsIHJlZmxlY3RlZCBtZXNzYWdlIGZpZWxkcy4gVGhpcyBpcyBub3QgYW4gYWN0dWFsIGNsYXNzIGJ1dCBoZXJlIGZvciB0aGUgc2FrZSBvZiBoYXZpbmcgY29uc2lzdGVudCB0eXBlIGRlZmluaXRpb25zLlxuICogQGV4cG9ydHMgRmllbGRCYXNlXG4gKiBAZXh0ZW5kcyBSZWZsZWN0aW9uT2JqZWN0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFVuaXF1ZSBuYW1lIHdpdGhpbiBpdHMgbmFtZXNwYWNlXG4gKiBAcGFyYW0ge251bWJlcn0gaWQgVW5pcXVlIGlkIHdpdGhpbiBpdHMgbmFtZXNwYWNlXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBWYWx1ZSB0eXBlXG4gKiBAcGFyYW0ge3N0cmluZ3xPYmplY3QuPHN0cmluZywqPn0gW3J1bGU9XCJvcHRpb25hbFwiXSBGaWVsZCBydWxlXG4gKiBAcGFyYW0ge3N0cmluZ3xPYmplY3QuPHN0cmluZywqPn0gW2V4dGVuZF0gRXh0ZW5kZWQgdHlwZSBpZiBkaWZmZXJlbnQgZnJvbSBwYXJlbnRcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IFtvcHRpb25zXSBEZWNsYXJlZCBvcHRpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvbW1lbnRdIENvbW1lbnQgYXNzb2NpYXRlZCB3aXRoIHRoaXMgZmllbGRcbiAqL1xuZnVuY3Rpb24gRmllbGQobmFtZSwgaWQsIHR5cGUsIHJ1bGUsIGV4dGVuZCwgb3B0aW9ucywgY29tbWVudCkge1xuXG4gICAgaWYgKHV0aWwuaXNPYmplY3QocnVsZSkpIHtcbiAgICAgICAgY29tbWVudCA9IGV4dGVuZDtcbiAgICAgICAgb3B0aW9ucyA9IHJ1bGU7XG4gICAgICAgIHJ1bGUgPSBleHRlbmQgPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIGlmICh1dGlsLmlzT2JqZWN0KGV4dGVuZCkpIHtcbiAgICAgICAgY29tbWVudCA9IG9wdGlvbnM7XG4gICAgICAgIG9wdGlvbnMgPSBleHRlbmQ7XG4gICAgICAgIGV4dGVuZCA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBSZWZsZWN0aW9uT2JqZWN0LmNhbGwodGhpcywgbmFtZSwgb3B0aW9ucyk7XG5cbiAgICBpZiAoIXV0aWwuaXNJbnRlZ2VyKGlkKSB8fCBpZCA8IDApXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcImlkIG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlclwiKTtcblxuICAgIGlmICghdXRpbC5pc1N0cmluZyh0eXBlKSlcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwidHlwZSBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuXG4gICAgaWYgKHJ1bGUgIT09IHVuZGVmaW5lZCAmJiAhcnVsZVJlLnRlc3QocnVsZSA9IHJ1bGUudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpKSlcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwicnVsZSBtdXN0IGJlIGEgc3RyaW5nIHJ1bGVcIik7XG5cbiAgICBpZiAoZXh0ZW5kICE9PSB1bmRlZmluZWQgJiYgIXV0aWwuaXNTdHJpbmcoZXh0ZW5kKSlcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiZXh0ZW5kIG11c3QgYmUgYSBzdHJpbmdcIik7XG5cbiAgICAvKipcbiAgICAgKiBGaWVsZCBydWxlLCBpZiBhbnkuXG4gICAgICogQHR5cGUge3N0cmluZ3x1bmRlZmluZWR9XG4gICAgICovXG4gICAgaWYgKHJ1bGUgPT09IFwicHJvdG8zX29wdGlvbmFsXCIpIHtcbiAgICAgICAgcnVsZSA9IFwib3B0aW9uYWxcIjtcbiAgICB9XG4gICAgdGhpcy5ydWxlID0gcnVsZSAmJiBydWxlICE9PSBcIm9wdGlvbmFsXCIgPyBydWxlIDogdW5kZWZpbmVkOyAvLyB0b0pTT05cblxuICAgIC8qKlxuICAgICAqIEZpZWxkIHR5cGUuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnR5cGUgPSB0eXBlOyAvLyB0b0pTT05cblxuICAgIC8qKlxuICAgICAqIFVuaXF1ZSBmaWVsZCBpZC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaWQgPSBpZDsgLy8gdG9KU09OLCBtYXJrZXJcblxuICAgIC8qKlxuICAgICAqIEV4dGVuZGVkIHR5cGUgaWYgZGlmZmVyZW50IGZyb20gcGFyZW50LlxuICAgICAqIEB0eXBlIHtzdHJpbmd8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMuZXh0ZW5kID0gZXh0ZW5kIHx8IHVuZGVmaW5lZDsgLy8gdG9KU09OXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoaXMgZmllbGQgaXMgcmVxdWlyZWQuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5yZXF1aXJlZCA9IHJ1bGUgPT09IFwicmVxdWlyZWRcIjtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhpcyBmaWVsZCBpcyBvcHRpb25hbC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLm9wdGlvbmFsID0gIXRoaXMucmVxdWlyZWQ7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoaXMgZmllbGQgaXMgcmVwZWF0ZWQuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5yZXBlYXRlZCA9IHJ1bGUgPT09IFwicmVwZWF0ZWRcIjtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhpcyBmaWVsZCBpcyBhIG1hcCBvciBub3QuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5tYXAgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIE1lc3NhZ2UgdGhpcyBmaWVsZCBiZWxvbmdzIHRvLlxuICAgICAqIEB0eXBlIHtUeXBlfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5tZXNzYWdlID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIE9uZU9mIHRoaXMgZmllbGQgYmVsb25ncyB0bywgaWYgYW55LFxuICAgICAqIEB0eXBlIHtPbmVPZnxudWxsfVxuICAgICAqL1xuICAgIHRoaXMucGFydE9mID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmaWVsZCB0eXBlJ3MgZGVmYXVsdCB2YWx1ZS5cbiAgICAgKiBAdHlwZSB7Kn1cbiAgICAgKi9cbiAgICB0aGlzLnR5cGVEZWZhdWx0ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmaWVsZCdzIGRlZmF1bHQgdmFsdWUgb24gcHJvdG90eXBlcy5cbiAgICAgKiBAdHlwZSB7Kn1cbiAgICAgKi9cbiAgICB0aGlzLmRlZmF1bHRWYWx1ZSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoaXMgZmllbGQncyB2YWx1ZSBzaG91bGQgYmUgdHJlYXRlZCBhcyBhIGxvbmcuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5sb25nID0gdXRpbC5Mb25nID8gdHlwZXMubG9uZ1t0eXBlXSAhPT0gdW5kZWZpbmVkIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoaXMgZmllbGQncyB2YWx1ZSBpcyBhIGJ1ZmZlci5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmJ5dGVzID0gdHlwZSA9PT0gXCJieXRlc1wiO1xuXG4gICAgLyoqXG4gICAgICogUmVzb2x2ZWQgdHlwZSBpZiBub3QgYSBiYXNpYyB0eXBlLlxuICAgICAqIEB0eXBlIHtUeXBlfEVudW18bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnJlc29sdmVkVHlwZSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBTaXN0ZXItZmllbGQgd2l0aGluIHRoZSBleHRlbmRlZCB0eXBlIGlmIGEgZGVjbGFyaW5nIGV4dGVuc2lvbiBmaWVsZC5cbiAgICAgKiBAdHlwZSB7RmllbGR8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLmV4dGVuc2lvbkZpZWxkID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFNpc3Rlci1maWVsZCB3aXRoaW4gdGhlIGRlY2xhcmluZyBuYW1lc3BhY2UgaWYgYW4gZXh0ZW5kZWQgZmllbGQuXG4gICAgICogQHR5cGUge0ZpZWxkfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5kZWNsYXJpbmdGaWVsZCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbGx5IHJlbWVtYmVycyB3aGV0aGVyIHRoaXMgZmllbGQgaXMgcGFja2VkLlxuICAgICAqIEB0eXBlIHtib29sZWFufG51bGx9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9wYWNrZWQgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQ29tbWVudCBmb3IgdGhpcyBmaWVsZC5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5jb21tZW50ID0gY29tbWVudDtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhpcyBmaWVsZCBpcyBwYWNrZWQuIE9ubHkgcmVsZXZhbnQgd2hlbiByZXBlYXRlZCBhbmQgd29ya2luZyB3aXRoIHByb3RvMi5cbiAqIEBuYW1lIEZpZWxkI3BhY2tlZFxuICogQHR5cGUge2Jvb2xlYW59XG4gKiBAcmVhZG9ubHlcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KEZpZWxkLnByb3RvdHlwZSwgXCJwYWNrZWRcIiwge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIGRlZmF1bHRzIHRvIHBhY2tlZD10cnVlIGlmIG5vdCBleHBsaWNpdHkgc2V0IHRvIGZhbHNlXG4gICAgICAgIGlmICh0aGlzLl9wYWNrZWQgPT09IG51bGwpXG4gICAgICAgICAgICB0aGlzLl9wYWNrZWQgPSB0aGlzLmdldE9wdGlvbihcInBhY2tlZFwiKSAhPT0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYWNrZWQ7XG4gICAgfVxufSk7XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cbkZpZWxkLnByb3RvdHlwZS5zZXRPcHRpb24gPSBmdW5jdGlvbiBzZXRPcHRpb24obmFtZSwgdmFsdWUsIGlmTm90U2V0KSB7XG4gICAgaWYgKG5hbWUgPT09IFwicGFja2VkXCIpIC8vIGNsZWFyIGNhY2hlZCBiZWZvcmUgc2V0dGluZ1xuICAgICAgICB0aGlzLl9wYWNrZWQgPSBudWxsO1xuICAgIHJldHVybiBSZWZsZWN0aW9uT2JqZWN0LnByb3RvdHlwZS5zZXRPcHRpb24uY2FsbCh0aGlzLCBuYW1lLCB2YWx1ZSwgaWZOb3RTZXQpO1xufTtcblxuLyoqXG4gKiBGaWVsZCBkZXNjcmlwdG9yLlxuICogQGludGVyZmFjZSBJRmllbGRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbcnVsZT1cIm9wdGlvbmFsXCJdIEZpZWxkIHJ1bGVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0eXBlIEZpZWxkIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpZCBGaWVsZCBpZFxuICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZywqPn0gW29wdGlvbnNdIEZpZWxkIG9wdGlvbnNcbiAqL1xuXG4vKipcbiAqIEV4dGVuc2lvbiBmaWVsZCBkZXNjcmlwdG9yLlxuICogQGludGVyZmFjZSBJRXh0ZW5zaW9uRmllbGRcbiAqIEBleHRlbmRzIElGaWVsZFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGV4dGVuZCBFeHRlbmRlZCB0eXBlXG4gKi9cblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIGZpZWxkIHRvIGEgZmllbGQgZGVzY3JpcHRvci5cbiAqIEBwYXJhbSB7SVRvSlNPTk9wdGlvbnN9IFt0b0pTT05PcHRpb25zXSBKU09OIGNvbnZlcnNpb24gb3B0aW9uc1xuICogQHJldHVybnMge0lGaWVsZH0gRmllbGQgZGVzY3JpcHRvclxuICovXG5GaWVsZC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKHRvSlNPTk9wdGlvbnMpIHtcbiAgICB2YXIga2VlcENvbW1lbnRzID0gdG9KU09OT3B0aW9ucyA/IEJvb2xlYW4odG9KU09OT3B0aW9ucy5rZWVwQ29tbWVudHMpIDogZmFsc2U7XG4gICAgcmV0dXJuIHV0aWwudG9PYmplY3QoW1xuICAgICAgICBcInJ1bGVcIiAgICAsIHRoaXMucnVsZSAhPT0gXCJvcHRpb25hbFwiICYmIHRoaXMucnVsZSB8fCB1bmRlZmluZWQsXG4gICAgICAgIFwidHlwZVwiICAgICwgdGhpcy50eXBlLFxuICAgICAgICBcImlkXCIgICAgICAsIHRoaXMuaWQsXG4gICAgICAgIFwiZXh0ZW5kXCIgICwgdGhpcy5leHRlbmQsXG4gICAgICAgIFwib3B0aW9uc1wiICwgdGhpcy5vcHRpb25zLFxuICAgICAgICBcImNvbW1lbnRcIiAsIGtlZXBDb21tZW50cyA/IHRoaXMuY29tbWVudCA6IHVuZGVmaW5lZFxuICAgIF0pO1xufTtcblxuLyoqXG4gKiBSZXNvbHZlcyB0aGlzIGZpZWxkJ3MgdHlwZSByZWZlcmVuY2VzLlxuICogQHJldHVybnMge0ZpZWxkfSBgdGhpc2BcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBhbnkgcmVmZXJlbmNlIGNhbm5vdCBiZSByZXNvbHZlZFxuICovXG5GaWVsZC5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uIHJlc29sdmUoKSB7XG5cbiAgICBpZiAodGhpcy5yZXNvbHZlZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAoKHRoaXMudHlwZURlZmF1bHQgPSB0eXBlcy5kZWZhdWx0c1t0aGlzLnR5cGVdKSA9PT0gdW5kZWZpbmVkKSB7IC8vIGlmIG5vdCBhIGJhc2ljIHR5cGUsIHJlc29sdmUgaXRcbiAgICAgICAgdGhpcy5yZXNvbHZlZFR5cGUgPSAodGhpcy5kZWNsYXJpbmdGaWVsZCA/IHRoaXMuZGVjbGFyaW5nRmllbGQucGFyZW50IDogdGhpcy5wYXJlbnQpLmxvb2t1cFR5cGVPckVudW0odGhpcy50eXBlKTtcbiAgICAgICAgaWYgKHRoaXMucmVzb2x2ZWRUeXBlIGluc3RhbmNlb2YgVHlwZSlcbiAgICAgICAgICAgIHRoaXMudHlwZURlZmF1bHQgPSBudWxsO1xuICAgICAgICBlbHNlIC8vIGluc3RhbmNlb2YgRW51bVxuICAgICAgICAgICAgdGhpcy50eXBlRGVmYXVsdCA9IHRoaXMucmVzb2x2ZWRUeXBlLnZhbHVlc1tPYmplY3Qua2V5cyh0aGlzLnJlc29sdmVkVHlwZS52YWx1ZXMpWzBdXTsgLy8gZmlyc3QgZGVmaW5lZFxuICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5wcm90bzNfb3B0aW9uYWwpIHtcbiAgICAgICAgLy8gcHJvdG8zIHNjYWxhciB2YWx1ZSBtYXJrZWQgb3B0aW9uYWw7IHNob3VsZCBkZWZhdWx0IHRvIG51bGxcbiAgICAgICAgdGhpcy50eXBlRGVmYXVsdCA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gdXNlIGV4cGxpY2l0bHkgc2V0IGRlZmF1bHQgdmFsdWUgaWYgcHJlc2VudFxuICAgIGlmICh0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zW1wiZGVmYXVsdFwiXSAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMudHlwZURlZmF1bHQgPSB0aGlzLm9wdGlvbnNbXCJkZWZhdWx0XCJdO1xuICAgICAgICBpZiAodGhpcy5yZXNvbHZlZFR5cGUgaW5zdGFuY2VvZiBFbnVtICYmIHR5cGVvZiB0aGlzLnR5cGVEZWZhdWx0ID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgdGhpcy50eXBlRGVmYXVsdCA9IHRoaXMucmVzb2x2ZWRUeXBlLnZhbHVlc1t0aGlzLnR5cGVEZWZhdWx0XTtcbiAgICB9XG5cbiAgICAvLyByZW1vdmUgdW5uZWNlc3Nhcnkgb3B0aW9uc1xuICAgIGlmICh0aGlzLm9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wYWNrZWQgPT09IHRydWUgfHwgdGhpcy5vcHRpb25zLnBhY2tlZCAhPT0gdW5kZWZpbmVkICYmIHRoaXMucmVzb2x2ZWRUeXBlICYmICEodGhpcy5yZXNvbHZlZFR5cGUgaW5zdGFuY2VvZiBFbnVtKSlcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm9wdGlvbnMucGFja2VkO1xuICAgICAgICBpZiAoIU9iamVjdC5rZXlzKHRoaXMub3B0aW9ucykubGVuZ3RoKVxuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8vIGNvbnZlcnQgdG8gaW50ZXJuYWwgZGF0YSB0eXBlIGlmIG5lY2Vzc3NhcnlcbiAgICBpZiAodGhpcy5sb25nKSB7XG4gICAgICAgIHRoaXMudHlwZURlZmF1bHQgPSB1dGlsLkxvbmcuZnJvbU51bWJlcih0aGlzLnR5cGVEZWZhdWx0LCB0aGlzLnR5cGUuY2hhckF0KDApID09PSBcInVcIik7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKE9iamVjdC5mcmVlemUpXG4gICAgICAgICAgICBPYmplY3QuZnJlZXplKHRoaXMudHlwZURlZmF1bHQpOyAvLyBsb25nIGluc3RhbmNlcyBhcmUgbWVhbnQgdG8gYmUgaW1tdXRhYmxlIGFueXdheSAoaS5lLiB1c2Ugc21hbGwgaW50IGNhY2hlIHRoYXQgZXZlbiByZXF1aXJlcyBpdClcblxuICAgIH0gZWxzZSBpZiAodGhpcy5ieXRlcyAmJiB0eXBlb2YgdGhpcy50eXBlRGVmYXVsdCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB2YXIgYnVmO1xuICAgICAgICBpZiAodXRpbC5iYXNlNjQudGVzdCh0aGlzLnR5cGVEZWZhdWx0KSlcbiAgICAgICAgICAgIHV0aWwuYmFzZTY0LmRlY29kZSh0aGlzLnR5cGVEZWZhdWx0LCBidWYgPSB1dGlsLm5ld0J1ZmZlcih1dGlsLmJhc2U2NC5sZW5ndGgodGhpcy50eXBlRGVmYXVsdCkpLCAwKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdXRpbC51dGY4LndyaXRlKHRoaXMudHlwZURlZmF1bHQsIGJ1ZiA9IHV0aWwubmV3QnVmZmVyKHV0aWwudXRmOC5sZW5ndGgodGhpcy50eXBlRGVmYXVsdCkpLCAwKTtcbiAgICAgICAgdGhpcy50eXBlRGVmYXVsdCA9IGJ1ZjtcbiAgICB9XG5cbiAgICAvLyB0YWtlIHNwZWNpYWwgY2FyZSBvZiBtYXBzIGFuZCByZXBlYXRlZCBmaWVsZHNcbiAgICBpZiAodGhpcy5tYXApXG4gICAgICAgIHRoaXMuZGVmYXVsdFZhbHVlID0gdXRpbC5lbXB0eU9iamVjdDtcbiAgICBlbHNlIGlmICh0aGlzLnJlcGVhdGVkKVxuICAgICAgICB0aGlzLmRlZmF1bHRWYWx1ZSA9IHV0aWwuZW1wdHlBcnJheTtcbiAgICBlbHNlXG4gICAgICAgIHRoaXMuZGVmYXVsdFZhbHVlID0gdGhpcy50eXBlRGVmYXVsdDtcblxuICAgIC8vIGVuc3VyZSBwcm9wZXIgdmFsdWUgb24gcHJvdG90eXBlXG4gICAgaWYgKHRoaXMucGFyZW50IGluc3RhbmNlb2YgVHlwZSlcbiAgICAgICAgdGhpcy5wYXJlbnQuY3Rvci5wcm90b3R5cGVbdGhpcy5uYW1lXSA9IHRoaXMuZGVmYXVsdFZhbHVlO1xuXG4gICAgcmV0dXJuIFJlZmxlY3Rpb25PYmplY3QucHJvdG90eXBlLnJlc29sdmUuY2FsbCh0aGlzKTtcbn07XG5cbi8qKlxuICogRGVjb3JhdG9yIGZ1bmN0aW9uIGFzIHJldHVybmVkIGJ5IHtAbGluayBGaWVsZC5kfSBhbmQge0BsaW5rIE1hcEZpZWxkLmR9IChUeXBlU2NyaXB0KS5cbiAqIEB0eXBlZGVmIEZpZWxkRGVjb3JhdG9yXG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcGFyYW0ge09iamVjdH0gcHJvdG90eXBlIFRhcmdldCBwcm90b3R5cGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZE5hbWUgRmllbGQgbmFtZVxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuXG4vKipcbiAqIEZpZWxkIGRlY29yYXRvciAoVHlwZVNjcmlwdCkuXG4gKiBAbmFtZSBGaWVsZC5kXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBmaWVsZElkIEZpZWxkIGlkXG4gKiBAcGFyYW0ge1wiZG91YmxlXCJ8XCJmbG9hdFwifFwiaW50MzJcInxcInVpbnQzMlwifFwic2ludDMyXCJ8XCJmaXhlZDMyXCJ8XCJzZml4ZWQzMlwifFwiaW50NjRcInxcInVpbnQ2NFwifFwic2ludDY0XCJ8XCJmaXhlZDY0XCJ8XCJzZml4ZWQ2NFwifFwic3RyaW5nXCJ8XCJib29sXCJ8XCJieXRlc1wifE9iamVjdH0gZmllbGRUeXBlIEZpZWxkIHR5cGVcbiAqIEBwYXJhbSB7XCJvcHRpb25hbFwifFwicmVxdWlyZWRcInxcInJlcGVhdGVkXCJ9IFtmaWVsZFJ1bGU9XCJvcHRpb25hbFwiXSBGaWVsZCBydWxlXG4gKiBAcGFyYW0ge1R9IFtkZWZhdWx0VmFsdWVdIERlZmF1bHQgdmFsdWVcbiAqIEByZXR1cm5zIHtGaWVsZERlY29yYXRvcn0gRGVjb3JhdG9yIGZ1bmN0aW9uXG4gKiBAdGVtcGxhdGUgVCBleHRlbmRzIG51bWJlciB8IG51bWJlcltdIHwgTG9uZyB8IExvbmdbXSB8IHN0cmluZyB8IHN0cmluZ1tdIHwgYm9vbGVhbiB8IGJvb2xlYW5bXSB8IFVpbnQ4QXJyYXkgfCBVaW50OEFycmF5W10gfCBCdWZmZXIgfCBCdWZmZXJbXVxuICovXG5GaWVsZC5kID0gZnVuY3Rpb24gZGVjb3JhdGVGaWVsZChmaWVsZElkLCBmaWVsZFR5cGUsIGZpZWxkUnVsZSwgZGVmYXVsdFZhbHVlKSB7XG5cbiAgICAvLyBzdWJtZXNzYWdlOiBkZWNvcmF0ZSB0aGUgc3VibWVzc2FnZSBhbmQgdXNlIGl0cyBuYW1lIGFzIHRoZSB0eXBlXG4gICAgaWYgKHR5cGVvZiBmaWVsZFR5cGUgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgZmllbGRUeXBlID0gdXRpbC5kZWNvcmF0ZVR5cGUoZmllbGRUeXBlKS5uYW1lO1xuXG4gICAgLy8gZW51bSByZWZlcmVuY2U6IGNyZWF0ZSBhIHJlZmxlY3RlZCBjb3B5IG9mIHRoZSBlbnVtIGFuZCBrZWVwIHJldXNlaW5nIGl0XG4gICAgZWxzZSBpZiAoZmllbGRUeXBlICYmIHR5cGVvZiBmaWVsZFR5cGUgPT09IFwib2JqZWN0XCIpXG4gICAgICAgIGZpZWxkVHlwZSA9IHV0aWwuZGVjb3JhdGVFbnVtKGZpZWxkVHlwZSkubmFtZTtcblxuICAgIHJldHVybiBmdW5jdGlvbiBmaWVsZERlY29yYXRvcihwcm90b3R5cGUsIGZpZWxkTmFtZSkge1xuICAgICAgICB1dGlsLmRlY29yYXRlVHlwZShwcm90b3R5cGUuY29uc3RydWN0b3IpXG4gICAgICAgICAgICAuYWRkKG5ldyBGaWVsZChmaWVsZE5hbWUsIGZpZWxkSWQsIGZpZWxkVHlwZSwgZmllbGRSdWxlLCB7IFwiZGVmYXVsdFwiOiBkZWZhdWx0VmFsdWUgfSkpO1xuICAgIH07XG59O1xuXG4vKipcbiAqIEZpZWxkIGRlY29yYXRvciAoVHlwZVNjcmlwdCkuXG4gKiBAbmFtZSBGaWVsZC5kXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBmaWVsZElkIEZpZWxkIGlkXG4gKiBAcGFyYW0ge0NvbnN0cnVjdG9yPFQ+fHN0cmluZ30gZmllbGRUeXBlIEZpZWxkIHR5cGVcbiAqIEBwYXJhbSB7XCJvcHRpb25hbFwifFwicmVxdWlyZWRcInxcInJlcGVhdGVkXCJ9IFtmaWVsZFJ1bGU9XCJvcHRpb25hbFwiXSBGaWVsZCBydWxlXG4gKiBAcmV0dXJucyB7RmllbGREZWNvcmF0b3J9IERlY29yYXRvciBmdW5jdGlvblxuICogQHRlbXBsYXRlIFQgZXh0ZW5kcyBNZXNzYWdlPFQ+XG4gKiBAdmFyaWF0aW9uIDJcbiAqL1xuLy8gbGlrZSBGaWVsZC5kIGJ1dCB3aXRob3V0IGEgZGVmYXVsdCB2YWx1ZVxuXG4vLyBTZXRzIHVwIGN5Y2xpYyBkZXBlbmRlbmNpZXMgKGNhbGxlZCBpbiBpbmRleC1saWdodClcbkZpZWxkLl9jb25maWd1cmUgPSBmdW5jdGlvbiBjb25maWd1cmUoVHlwZV8pIHtcbiAgICBUeXBlID0gVHlwZV87XG59O1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJGaWVsZCIsIlJlZmxlY3Rpb25PYmplY3QiLCJyZXF1aXJlIiwicHJvdG90eXBlIiwiT2JqZWN0IiwiY3JlYXRlIiwiY29uc3RydWN0b3IiLCJjbGFzc05hbWUiLCJFbnVtIiwidHlwZXMiLCJ1dGlsIiwiVHlwZSIsInJ1bGVSZSIsImZyb21KU09OIiwibmFtZSIsImpzb24iLCJpZCIsInR5cGUiLCJydWxlIiwiZXh0ZW5kIiwib3B0aW9ucyIsImNvbW1lbnQiLCJpc09iamVjdCIsInVuZGVmaW5lZCIsImNhbGwiLCJpc0ludGVnZXIiLCJUeXBlRXJyb3IiLCJpc1N0cmluZyIsInRlc3QiLCJ0b1N0cmluZyIsInRvTG93ZXJDYXNlIiwicmVxdWlyZWQiLCJvcHRpb25hbCIsInJlcGVhdGVkIiwibWFwIiwibWVzc2FnZSIsInBhcnRPZiIsInR5cGVEZWZhdWx0IiwiZGVmYXVsdFZhbHVlIiwibG9uZyIsIkxvbmciLCJieXRlcyIsInJlc29sdmVkVHlwZSIsImV4dGVuc2lvbkZpZWxkIiwiZGVjbGFyaW5nRmllbGQiLCJfcGFja2VkIiwiZGVmaW5lUHJvcGVydHkiLCJnZXQiLCJnZXRPcHRpb24iLCJzZXRPcHRpb24iLCJ2YWx1ZSIsImlmTm90U2V0IiwidG9KU09OIiwidG9KU09OT3B0aW9ucyIsImtlZXBDb21tZW50cyIsIkJvb2xlYW4iLCJ0b09iamVjdCIsInJlc29sdmUiLCJyZXNvbHZlZCIsImRlZmF1bHRzIiwicGFyZW50IiwibG9va3VwVHlwZU9yRW51bSIsInZhbHVlcyIsImtleXMiLCJwcm90bzNfb3B0aW9uYWwiLCJwYWNrZWQiLCJsZW5ndGgiLCJmcm9tTnVtYmVyIiwiY2hhckF0IiwiZnJlZXplIiwiYnVmIiwiYmFzZTY0IiwiZGVjb2RlIiwibmV3QnVmZmVyIiwidXRmOCIsIndyaXRlIiwiZW1wdHlPYmplY3QiLCJlbXB0eUFycmF5IiwiY3RvciIsImQiLCJkZWNvcmF0ZUZpZWxkIiwiZmllbGRJZCIsImZpZWxkVHlwZSIsImZpZWxkUnVsZSIsImRlY29yYXRlVHlwZSIsImRlY29yYXRlRW51bSIsImZpZWxkRGVjb3JhdG9yIiwiZmllbGROYW1lIiwiYWRkIiwiX2NvbmZpZ3VyZSIsImNvbmZpZ3VyZSIsIlR5cGVfIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/protobufjs/src/field.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/src/index-light.js":
/*!*****************************************************!*\
  !*** ../node_modules/protobufjs/src/index-light.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar protobuf = module.exports = __webpack_require__(/*! ./index-minimal */ \"(ssr)/../node_modules/protobufjs/src/index-minimal.js\");\nprotobuf.build = \"light\";\n/**\n * A node-style callback as used by {@link load} and {@link Root#load}.\n * @typedef LoadCallback\n * @type {function}\n * @param {Error|null} error Error, if any, otherwise `null`\n * @param {Root} [root] Root, if there hasn't been an error\n * @returns {undefined}\n */ /**\n * Loads one or multiple .proto or preprocessed .json files into a common root namespace and calls the callback.\n * @param {string|string[]} filename One or multiple files to load\n * @param {Root} root Root namespace, defaults to create a new one if omitted.\n * @param {LoadCallback} callback Callback function\n * @returns {undefined}\n * @see {@link Root#load}\n */ function load(filename, root, callback) {\n    if (typeof root === \"function\") {\n        callback = root;\n        root = new protobuf.Root();\n    } else if (!root) root = new protobuf.Root();\n    return root.load(filename, callback);\n}\n/**\n * Loads one or multiple .proto or preprocessed .json files into a common root namespace and calls the callback.\n * @name load\n * @function\n * @param {string|string[]} filename One or multiple files to load\n * @param {LoadCallback} callback Callback function\n * @returns {undefined}\n * @see {@link Root#load}\n * @variation 2\n */ // function load(filename:string, callback:LoadCallback):undefined\n/**\n * Loads one or multiple .proto or preprocessed .json files into a common root namespace and returns a promise.\n * @name load\n * @function\n * @param {string|string[]} filename One or multiple files to load\n * @param {Root} [root] Root namespace, defaults to create a new one if omitted.\n * @returns {Promise<Root>} Promise\n * @see {@link Root#load}\n * @variation 3\n */ // function load(filename:string, [root:Root]):Promise<Root>\nprotobuf.load = load;\n/**\n * Synchronously loads one or multiple .proto or preprocessed .json files into a common root namespace (node only).\n * @param {string|string[]} filename One or multiple files to load\n * @param {Root} [root] Root namespace, defaults to create a new one if omitted.\n * @returns {Root} Root namespace\n * @throws {Error} If synchronous fetching is not supported (i.e. in browsers) or if a file's syntax is invalid\n * @see {@link Root#loadSync}\n */ function loadSync(filename, root) {\n    if (!root) root = new protobuf.Root();\n    return root.loadSync(filename);\n}\nprotobuf.loadSync = loadSync;\n// Serialization\nprotobuf.encoder = __webpack_require__(/*! ./encoder */ \"(ssr)/../node_modules/protobufjs/src/encoder.js\");\nprotobuf.decoder = __webpack_require__(/*! ./decoder */ \"(ssr)/../node_modules/protobufjs/src/decoder.js\");\nprotobuf.verifier = __webpack_require__(/*! ./verifier */ \"(ssr)/../node_modules/protobufjs/src/verifier.js\");\nprotobuf.converter = __webpack_require__(/*! ./converter */ \"(ssr)/../node_modules/protobufjs/src/converter.js\");\n// Reflection\nprotobuf.ReflectionObject = __webpack_require__(/*! ./object */ \"(ssr)/../node_modules/protobufjs/src/object.js\");\nprotobuf.Namespace = __webpack_require__(/*! ./namespace */ \"(ssr)/../node_modules/protobufjs/src/namespace.js\");\nprotobuf.Root = __webpack_require__(/*! ./root */ \"(ssr)/../node_modules/protobufjs/src/root.js\");\nprotobuf.Enum = __webpack_require__(/*! ./enum */ \"(ssr)/../node_modules/protobufjs/src/enum.js\");\nprotobuf.Type = __webpack_require__(/*! ./type */ \"(ssr)/../node_modules/protobufjs/src/type.js\");\nprotobuf.Field = __webpack_require__(/*! ./field */ \"(ssr)/../node_modules/protobufjs/src/field.js\");\nprotobuf.OneOf = __webpack_require__(/*! ./oneof */ \"(ssr)/../node_modules/protobufjs/src/oneof.js\");\nprotobuf.MapField = __webpack_require__(/*! ./mapfield */ \"(ssr)/../node_modules/protobufjs/src/mapfield.js\");\nprotobuf.Service = __webpack_require__(/*! ./service */ \"(ssr)/../node_modules/protobufjs/src/service.js\");\nprotobuf.Method = __webpack_require__(/*! ./method */ \"(ssr)/../node_modules/protobufjs/src/method.js\");\n// Runtime\nprotobuf.Message = __webpack_require__(/*! ./message */ \"(ssr)/../node_modules/protobufjs/src/message.js\");\nprotobuf.wrappers = __webpack_require__(/*! ./wrappers */ \"(ssr)/../node_modules/protobufjs/src/wrappers.js\");\n// Utility\nprotobuf.types = __webpack_require__(/*! ./types */ \"(ssr)/../node_modules/protobufjs/src/types.js\");\nprotobuf.util = __webpack_require__(/*! ./util */ \"(ssr)/../node_modules/protobufjs/src/util.js\");\n// Set up possibly cyclic reflection dependencies\nprotobuf.ReflectionObject._configure(protobuf.Root);\nprotobuf.Namespace._configure(protobuf.Type, protobuf.Service, protobuf.Enum);\nprotobuf.Root._configure(protobuf.Type);\nprotobuf.Field._configure(protobuf.Type);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL2luZGV4LWxpZ2h0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsV0FBV0Msb0hBQTJDO0FBRTFERCxTQUFTSSxLQUFLLEdBQUc7QUFFakI7Ozs7Ozs7Q0FPQyxHQUVEOzs7Ozs7O0NBT0MsR0FDRCxTQUFTQyxLQUFLQyxRQUFRLEVBQUVDLElBQUksRUFBRUMsUUFBUTtJQUNsQyxJQUFJLE9BQU9ELFNBQVMsWUFBWTtRQUM1QkMsV0FBV0Q7UUFDWEEsT0FBTyxJQUFJUCxTQUFTUyxJQUFJO0lBQzVCLE9BQU8sSUFBSSxDQUFDRixNQUNSQSxPQUFPLElBQUlQLFNBQVNTLElBQUk7SUFDNUIsT0FBT0YsS0FBS0YsSUFBSSxDQUFDQyxVQUFVRTtBQUMvQjtBQUVBOzs7Ozs7Ozs7Q0FTQyxHQUNELGtFQUFrRTtBQUVsRTs7Ozs7Ozs7O0NBU0MsR0FDRCw0REFBNEQ7QUFFNURSLFNBQVNLLElBQUksR0FBR0E7QUFFaEI7Ozs7Ozs7Q0FPQyxHQUNELFNBQVNLLFNBQVNKLFFBQVEsRUFBRUMsSUFBSTtJQUM1QixJQUFJLENBQUNBLE1BQ0RBLE9BQU8sSUFBSVAsU0FBU1MsSUFBSTtJQUM1QixPQUFPRixLQUFLRyxRQUFRLENBQUNKO0FBQ3pCO0FBRUFOLFNBQVNVLFFBQVEsR0FBR0E7QUFFcEIsZ0JBQWdCO0FBQ2hCVixTQUFTVyxPQUFPLEdBQVlSLG1CQUFPQSxDQUFDLGtFQUFXO0FBQy9DSCxTQUFTWSxPQUFPLEdBQVlULG1CQUFPQSxDQUFDLGtFQUFXO0FBQy9DSCxTQUFTYSxRQUFRLEdBQVdWLG1CQUFPQSxDQUFDLG9FQUFZO0FBQ2hESCxTQUFTYyxTQUFTLEdBQVVYLG1CQUFPQSxDQUFDLHNFQUFhO0FBRWpELGFBQWE7QUFDYkgsU0FBU2UsZ0JBQWdCLEdBQUdaLG1CQUFPQSxDQUFDLGdFQUFVO0FBQzlDSCxTQUFTZ0IsU0FBUyxHQUFVYixtQkFBT0EsQ0FBQyxzRUFBYTtBQUNqREgsU0FBU1MsSUFBSSxHQUFlTixtQkFBT0EsQ0FBQyw0REFBUTtBQUM1Q0gsU0FBU2lCLElBQUksR0FBZWQsbUJBQU9BLENBQUMsNERBQVE7QUFDNUNILFNBQVNrQixJQUFJLEdBQWVmLG1CQUFPQSxDQUFDLDREQUFRO0FBQzVDSCxTQUFTbUIsS0FBSyxHQUFjaEIsbUJBQU9BLENBQUMsOERBQVM7QUFDN0NILFNBQVNvQixLQUFLLEdBQWNqQixtQkFBT0EsQ0FBQyw4REFBUztBQUM3Q0gsU0FBU3FCLFFBQVEsR0FBV2xCLG1CQUFPQSxDQUFDLG9FQUFZO0FBQ2hESCxTQUFTc0IsT0FBTyxHQUFZbkIsbUJBQU9BLENBQUMsa0VBQVc7QUFDL0NILFNBQVN1QixNQUFNLEdBQWFwQixtQkFBT0EsQ0FBQyxnRUFBVTtBQUU5QyxVQUFVO0FBQ1ZILFNBQVN3QixPQUFPLEdBQVlyQixtQkFBT0EsQ0FBQyxrRUFBVztBQUMvQ0gsU0FBU3lCLFFBQVEsR0FBV3RCLG1CQUFPQSxDQUFDLG9FQUFZO0FBRWhELFVBQVU7QUFDVkgsU0FBUzBCLEtBQUssR0FBY3ZCLG1CQUFPQSxDQUFDLDhEQUFTO0FBQzdDSCxTQUFTMkIsSUFBSSxHQUFleEIsbUJBQU9BLENBQUMsNERBQVE7QUFFNUMsaURBQWlEO0FBQ2pESCxTQUFTZSxnQkFBZ0IsQ0FBQ2EsVUFBVSxDQUFDNUIsU0FBU1MsSUFBSTtBQUNsRFQsU0FBU2dCLFNBQVMsQ0FBQ1ksVUFBVSxDQUFDNUIsU0FBU2tCLElBQUksRUFBRWxCLFNBQVNzQixPQUFPLEVBQUV0QixTQUFTaUIsSUFBSTtBQUM1RWpCLFNBQVNTLElBQUksQ0FBQ21CLFVBQVUsQ0FBQzVCLFNBQVNrQixJQUFJO0FBQ3RDbEIsU0FBU21CLEtBQUssQ0FBQ1MsVUFBVSxDQUFDNUIsU0FBU2tCLElBQUkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL2luZGV4LWxpZ2h0LmpzPzY2OGIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgcHJvdG9idWYgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2luZGV4LW1pbmltYWxcIik7XG5cbnByb3RvYnVmLmJ1aWxkID0gXCJsaWdodFwiO1xuXG4vKipcbiAqIEEgbm9kZS1zdHlsZSBjYWxsYmFjayBhcyB1c2VkIGJ5IHtAbGluayBsb2FkfSBhbmQge0BsaW5rIFJvb3QjbG9hZH0uXG4gKiBAdHlwZWRlZiBMb2FkQ2FsbGJhY2tcbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEBwYXJhbSB7RXJyb3J8bnVsbH0gZXJyb3IgRXJyb3IsIGlmIGFueSwgb3RoZXJ3aXNlIGBudWxsYFxuICogQHBhcmFtIHtSb290fSBbcm9vdF0gUm9vdCwgaWYgdGhlcmUgaGFzbid0IGJlZW4gYW4gZXJyb3JcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cblxuLyoqXG4gKiBMb2FkcyBvbmUgb3IgbXVsdGlwbGUgLnByb3RvIG9yIHByZXByb2Nlc3NlZCAuanNvbiBmaWxlcyBpbnRvIGEgY29tbW9uIHJvb3QgbmFtZXNwYWNlIGFuZCBjYWxscyB0aGUgY2FsbGJhY2suXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gZmlsZW5hbWUgT25lIG9yIG11bHRpcGxlIGZpbGVzIHRvIGxvYWRcbiAqIEBwYXJhbSB7Um9vdH0gcm9vdCBSb290IG5hbWVzcGFjZSwgZGVmYXVsdHMgdG8gY3JlYXRlIGEgbmV3IG9uZSBpZiBvbWl0dGVkLlxuICogQHBhcmFtIHtMb2FkQ2FsbGJhY2t9IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICogQHNlZSB7QGxpbmsgUm9vdCNsb2FkfVxuICovXG5mdW5jdGlvbiBsb2FkKGZpbGVuYW1lLCByb290LCBjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2Ygcm9vdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNhbGxiYWNrID0gcm9vdDtcbiAgICAgICAgcm9vdCA9IG5ldyBwcm90b2J1Zi5Sb290KCk7XG4gICAgfSBlbHNlIGlmICghcm9vdClcbiAgICAgICAgcm9vdCA9IG5ldyBwcm90b2J1Zi5Sb290KCk7XG4gICAgcmV0dXJuIHJvb3QubG9hZChmaWxlbmFtZSwgY2FsbGJhY2spO1xufVxuXG4vKipcbiAqIExvYWRzIG9uZSBvciBtdWx0aXBsZSAucHJvdG8gb3IgcHJlcHJvY2Vzc2VkIC5qc29uIGZpbGVzIGludG8gYSBjb21tb24gcm9vdCBuYW1lc3BhY2UgYW5kIGNhbGxzIHRoZSBjYWxsYmFjay5cbiAqIEBuYW1lIGxvYWRcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IGZpbGVuYW1lIE9uZSBvciBtdWx0aXBsZSBmaWxlcyB0byBsb2FkXG4gKiBAcGFyYW0ge0xvYWRDYWxsYmFja30gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiBAc2VlIHtAbGluayBSb290I2xvYWR9XG4gKiBAdmFyaWF0aW9uIDJcbiAqL1xuLy8gZnVuY3Rpb24gbG9hZChmaWxlbmFtZTpzdHJpbmcsIGNhbGxiYWNrOkxvYWRDYWxsYmFjayk6dW5kZWZpbmVkXG5cbi8qKlxuICogTG9hZHMgb25lIG9yIG11bHRpcGxlIC5wcm90byBvciBwcmVwcm9jZXNzZWQgLmpzb24gZmlsZXMgaW50byBhIGNvbW1vbiByb290IG5hbWVzcGFjZSBhbmQgcmV0dXJucyBhIHByb21pc2UuXG4gKiBAbmFtZSBsb2FkXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBmaWxlbmFtZSBPbmUgb3IgbXVsdGlwbGUgZmlsZXMgdG8gbG9hZFxuICogQHBhcmFtIHtSb290fSBbcm9vdF0gUm9vdCBuYW1lc3BhY2UsIGRlZmF1bHRzIHRvIGNyZWF0ZSBhIG5ldyBvbmUgaWYgb21pdHRlZC5cbiAqIEByZXR1cm5zIHtQcm9taXNlPFJvb3Q+fSBQcm9taXNlXG4gKiBAc2VlIHtAbGluayBSb290I2xvYWR9XG4gKiBAdmFyaWF0aW9uIDNcbiAqL1xuLy8gZnVuY3Rpb24gbG9hZChmaWxlbmFtZTpzdHJpbmcsIFtyb290OlJvb3RdKTpQcm9taXNlPFJvb3Q+XG5cbnByb3RvYnVmLmxvYWQgPSBsb2FkO1xuXG4vKipcbiAqIFN5bmNocm9ub3VzbHkgbG9hZHMgb25lIG9yIG11bHRpcGxlIC5wcm90byBvciBwcmVwcm9jZXNzZWQgLmpzb24gZmlsZXMgaW50byBhIGNvbW1vbiByb290IG5hbWVzcGFjZSAobm9kZSBvbmx5KS5cbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBmaWxlbmFtZSBPbmUgb3IgbXVsdGlwbGUgZmlsZXMgdG8gbG9hZFxuICogQHBhcmFtIHtSb290fSBbcm9vdF0gUm9vdCBuYW1lc3BhY2UsIGRlZmF1bHRzIHRvIGNyZWF0ZSBhIG5ldyBvbmUgaWYgb21pdHRlZC5cbiAqIEByZXR1cm5zIHtSb290fSBSb290IG5hbWVzcGFjZVxuICogQHRocm93cyB7RXJyb3J9IElmIHN5bmNocm9ub3VzIGZldGNoaW5nIGlzIG5vdCBzdXBwb3J0ZWQgKGkuZS4gaW4gYnJvd3NlcnMpIG9yIGlmIGEgZmlsZSdzIHN5bnRheCBpcyBpbnZhbGlkXG4gKiBAc2VlIHtAbGluayBSb290I2xvYWRTeW5jfVxuICovXG5mdW5jdGlvbiBsb2FkU3luYyhmaWxlbmFtZSwgcm9vdCkge1xuICAgIGlmICghcm9vdClcbiAgICAgICAgcm9vdCA9IG5ldyBwcm90b2J1Zi5Sb290KCk7XG4gICAgcmV0dXJuIHJvb3QubG9hZFN5bmMoZmlsZW5hbWUpO1xufVxuXG5wcm90b2J1Zi5sb2FkU3luYyA9IGxvYWRTeW5jO1xuXG4vLyBTZXJpYWxpemF0aW9uXG5wcm90b2J1Zi5lbmNvZGVyICAgICAgICAgID0gcmVxdWlyZShcIi4vZW5jb2RlclwiKTtcbnByb3RvYnVmLmRlY29kZXIgICAgICAgICAgPSByZXF1aXJlKFwiLi9kZWNvZGVyXCIpO1xucHJvdG9idWYudmVyaWZpZXIgICAgICAgICA9IHJlcXVpcmUoXCIuL3ZlcmlmaWVyXCIpO1xucHJvdG9idWYuY29udmVydGVyICAgICAgICA9IHJlcXVpcmUoXCIuL2NvbnZlcnRlclwiKTtcblxuLy8gUmVmbGVjdGlvblxucHJvdG9idWYuUmVmbGVjdGlvbk9iamVjdCA9IHJlcXVpcmUoXCIuL29iamVjdFwiKTtcbnByb3RvYnVmLk5hbWVzcGFjZSAgICAgICAgPSByZXF1aXJlKFwiLi9uYW1lc3BhY2VcIik7XG5wcm90b2J1Zi5Sb290ICAgICAgICAgICAgID0gcmVxdWlyZShcIi4vcm9vdFwiKTtcbnByb3RvYnVmLkVudW0gICAgICAgICAgICAgPSByZXF1aXJlKFwiLi9lbnVtXCIpO1xucHJvdG9idWYuVHlwZSAgICAgICAgICAgICA9IHJlcXVpcmUoXCIuL3R5cGVcIik7XG5wcm90b2J1Zi5GaWVsZCAgICAgICAgICAgID0gcmVxdWlyZShcIi4vZmllbGRcIik7XG5wcm90b2J1Zi5PbmVPZiAgICAgICAgICAgID0gcmVxdWlyZShcIi4vb25lb2ZcIik7XG5wcm90b2J1Zi5NYXBGaWVsZCAgICAgICAgID0gcmVxdWlyZShcIi4vbWFwZmllbGRcIik7XG5wcm90b2J1Zi5TZXJ2aWNlICAgICAgICAgID0gcmVxdWlyZShcIi4vc2VydmljZVwiKTtcbnByb3RvYnVmLk1ldGhvZCAgICAgICAgICAgPSByZXF1aXJlKFwiLi9tZXRob2RcIik7XG5cbi8vIFJ1bnRpbWVcbnByb3RvYnVmLk1lc3NhZ2UgICAgICAgICAgPSByZXF1aXJlKFwiLi9tZXNzYWdlXCIpO1xucHJvdG9idWYud3JhcHBlcnMgICAgICAgICA9IHJlcXVpcmUoXCIuL3dyYXBwZXJzXCIpO1xuXG4vLyBVdGlsaXR5XG5wcm90b2J1Zi50eXBlcyAgICAgICAgICAgID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5wcm90b2J1Zi51dGlsICAgICAgICAgICAgID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcblxuLy8gU2V0IHVwIHBvc3NpYmx5IGN5Y2xpYyByZWZsZWN0aW9uIGRlcGVuZGVuY2llc1xucHJvdG9idWYuUmVmbGVjdGlvbk9iamVjdC5fY29uZmlndXJlKHByb3RvYnVmLlJvb3QpO1xucHJvdG9idWYuTmFtZXNwYWNlLl9jb25maWd1cmUocHJvdG9idWYuVHlwZSwgcHJvdG9idWYuU2VydmljZSwgcHJvdG9idWYuRW51bSk7XG5wcm90b2J1Zi5Sb290Ll9jb25maWd1cmUocHJvdG9idWYuVHlwZSk7XG5wcm90b2J1Zi5GaWVsZC5fY29uZmlndXJlKHByb3RvYnVmLlR5cGUpO1xuIl0sIm5hbWVzIjpbInByb3RvYnVmIiwibW9kdWxlIiwiZXhwb3J0cyIsInJlcXVpcmUiLCJidWlsZCIsImxvYWQiLCJmaWxlbmFtZSIsInJvb3QiLCJjYWxsYmFjayIsIlJvb3QiLCJsb2FkU3luYyIsImVuY29kZXIiLCJkZWNvZGVyIiwidmVyaWZpZXIiLCJjb252ZXJ0ZXIiLCJSZWZsZWN0aW9uT2JqZWN0IiwiTmFtZXNwYWNlIiwiRW51bSIsIlR5cGUiLCJGaWVsZCIsIk9uZU9mIiwiTWFwRmllbGQiLCJTZXJ2aWNlIiwiTWV0aG9kIiwiTWVzc2FnZSIsIndyYXBwZXJzIiwidHlwZXMiLCJ1dGlsIiwiX2NvbmZpZ3VyZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/protobufjs/src/index-light.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/src/index-minimal.js":
/*!*******************************************************!*\
  !*** ../node_modules/protobufjs/src/index-minimal.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar protobuf = exports;\n/**\n * Build type, one of `\"full\"`, `\"light\"` or `\"minimal\"`.\n * @name build\n * @type {string}\n * @const\n */ protobuf.build = \"minimal\";\n// Serialization\nprotobuf.Writer = __webpack_require__(/*! ./writer */ \"(ssr)/../node_modules/protobufjs/src/writer.js\");\nprotobuf.BufferWriter = __webpack_require__(/*! ./writer_buffer */ \"(ssr)/../node_modules/protobufjs/src/writer_buffer.js\");\nprotobuf.Reader = __webpack_require__(/*! ./reader */ \"(ssr)/../node_modules/protobufjs/src/reader.js\");\nprotobuf.BufferReader = __webpack_require__(/*! ./reader_buffer */ \"(ssr)/../node_modules/protobufjs/src/reader_buffer.js\");\n// Utility\nprotobuf.util = __webpack_require__(/*! ./util/minimal */ \"(ssr)/../node_modules/protobufjs/src/util/minimal.js\");\nprotobuf.rpc = __webpack_require__(/*! ./rpc */ \"(ssr)/../node_modules/protobufjs/src/rpc.js\");\nprotobuf.roots = __webpack_require__(/*! ./roots */ \"(ssr)/../node_modules/protobufjs/src/roots.js\");\nprotobuf.configure = configure;\n/* istanbul ignore next */ /**\n * Reconfigures the library according to the environment.\n * @returns {undefined}\n */ function configure() {\n    protobuf.util._configure();\n    protobuf.Writer._configure(protobuf.BufferWriter);\n    protobuf.Reader._configure(protobuf.BufferReader);\n}\n// Set up buffer utility according to the environment\nconfigure();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL2luZGV4LW1pbmltYWwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxXQUFXQztBQUVmOzs7OztDQUtDLEdBQ0RELFNBQVNFLEtBQUssR0FBRztBQUVqQixnQkFBZ0I7QUFDaEJGLFNBQVNHLE1BQU0sR0FBU0MsbUJBQU9BLENBQUMsZ0VBQVU7QUFDMUNKLFNBQVNLLFlBQVksR0FBR0QsbUJBQU9BLENBQUMsOEVBQWlCO0FBQ2pESixTQUFTTSxNQUFNLEdBQVNGLG1CQUFPQSxDQUFDLGdFQUFVO0FBQzFDSixTQUFTTyxZQUFZLEdBQUdILG1CQUFPQSxDQUFDLDhFQUFpQjtBQUVqRCxVQUFVO0FBQ1ZKLFNBQVNRLElBQUksR0FBV0osbUJBQU9BLENBQUMsNEVBQWdCO0FBQ2hESixTQUFTUyxHQUFHLEdBQVlMLG1CQUFPQSxDQUFDLDBEQUFPO0FBQ3ZDSixTQUFTVSxLQUFLLEdBQVVOLG1CQUFPQSxDQUFDLDhEQUFTO0FBQ3pDSixTQUFTVyxTQUFTLEdBQU1BO0FBRXhCLHdCQUF3QixHQUN4Qjs7O0NBR0MsR0FDRCxTQUFTQTtJQUNMWCxTQUFTUSxJQUFJLENBQUNJLFVBQVU7SUFDeEJaLFNBQVNHLE1BQU0sQ0FBQ1MsVUFBVSxDQUFDWixTQUFTSyxZQUFZO0lBQ2hETCxTQUFTTSxNQUFNLENBQUNNLFVBQVUsQ0FBQ1osU0FBU08sWUFBWTtBQUNwRDtBQUVBLHFEQUFxRDtBQUNyREkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL2luZGV4LW1pbmltYWwuanM/M2RhNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBwcm90b2J1ZiA9IGV4cG9ydHM7XG5cbi8qKlxuICogQnVpbGQgdHlwZSwgb25lIG9mIGBcImZ1bGxcImAsIGBcImxpZ2h0XCJgIG9yIGBcIm1pbmltYWxcImAuXG4gKiBAbmFtZSBidWlsZFxuICogQHR5cGUge3N0cmluZ31cbiAqIEBjb25zdFxuICovXG5wcm90b2J1Zi5idWlsZCA9IFwibWluaW1hbFwiO1xuXG4vLyBTZXJpYWxpemF0aW9uXG5wcm90b2J1Zi5Xcml0ZXIgICAgICAgPSByZXF1aXJlKFwiLi93cml0ZXJcIik7XG5wcm90b2J1Zi5CdWZmZXJXcml0ZXIgPSByZXF1aXJlKFwiLi93cml0ZXJfYnVmZmVyXCIpO1xucHJvdG9idWYuUmVhZGVyICAgICAgID0gcmVxdWlyZShcIi4vcmVhZGVyXCIpO1xucHJvdG9idWYuQnVmZmVyUmVhZGVyID0gcmVxdWlyZShcIi4vcmVhZGVyX2J1ZmZlclwiKTtcblxuLy8gVXRpbGl0eVxucHJvdG9idWYudXRpbCAgICAgICAgID0gcmVxdWlyZShcIi4vdXRpbC9taW5pbWFsXCIpO1xucHJvdG9idWYucnBjICAgICAgICAgID0gcmVxdWlyZShcIi4vcnBjXCIpO1xucHJvdG9idWYucm9vdHMgICAgICAgID0gcmVxdWlyZShcIi4vcm9vdHNcIik7XG5wcm90b2J1Zi5jb25maWd1cmUgICAgPSBjb25maWd1cmU7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4vKipcbiAqIFJlY29uZmlndXJlcyB0aGUgbGlicmFyeSBhY2NvcmRpbmcgdG8gdGhlIGVudmlyb25tZW50LlxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuZnVuY3Rpb24gY29uZmlndXJlKCkge1xuICAgIHByb3RvYnVmLnV0aWwuX2NvbmZpZ3VyZSgpO1xuICAgIHByb3RvYnVmLldyaXRlci5fY29uZmlndXJlKHByb3RvYnVmLkJ1ZmZlcldyaXRlcik7XG4gICAgcHJvdG9idWYuUmVhZGVyLl9jb25maWd1cmUocHJvdG9idWYuQnVmZmVyUmVhZGVyKTtcbn1cblxuLy8gU2V0IHVwIGJ1ZmZlciB1dGlsaXR5IGFjY29yZGluZyB0byB0aGUgZW52aXJvbm1lbnRcbmNvbmZpZ3VyZSgpO1xuIl0sIm5hbWVzIjpbInByb3RvYnVmIiwiZXhwb3J0cyIsImJ1aWxkIiwiV3JpdGVyIiwicmVxdWlyZSIsIkJ1ZmZlcldyaXRlciIsIlJlYWRlciIsIkJ1ZmZlclJlYWRlciIsInV0aWwiLCJycGMiLCJyb290cyIsImNvbmZpZ3VyZSIsIl9jb25maWd1cmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/protobufjs/src/index-minimal.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/src/index.js":
/*!***********************************************!*\
  !*** ../node_modules/protobufjs/src/index.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar protobuf = module.exports = __webpack_require__(/*! ./index-light */ \"(ssr)/../node_modules/protobufjs/src/index-light.js\");\nprotobuf.build = \"full\";\n// Parser\nprotobuf.tokenize = __webpack_require__(/*! ./tokenize */ \"(ssr)/../node_modules/protobufjs/src/tokenize.js\");\nprotobuf.parse = __webpack_require__(/*! ./parse */ \"(ssr)/../node_modules/protobufjs/src/parse.js\");\nprotobuf.common = __webpack_require__(/*! ./common */ \"(ssr)/../node_modules/protobufjs/src/common.js\");\n// Configure parser\nprotobuf.Root._configure(protobuf.Type, protobuf.parse, protobuf.common);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsV0FBV0MsZ0hBQXlDO0FBRXhERCxTQUFTSSxLQUFLLEdBQUc7QUFFakIsU0FBUztBQUNUSixTQUFTSyxRQUFRLEdBQVdGLG1CQUFPQSxDQUFDLG9FQUFZO0FBQ2hESCxTQUFTTSxLQUFLLEdBQWNILG1CQUFPQSxDQUFDLDhEQUFTO0FBQzdDSCxTQUFTTyxNQUFNLEdBQWFKLG1CQUFPQSxDQUFDLGdFQUFVO0FBRTlDLG1CQUFtQjtBQUNuQkgsU0FBU1EsSUFBSSxDQUFDQyxVQUFVLENBQUNULFNBQVNVLElBQUksRUFBRVYsU0FBU00sS0FBSyxFQUFFTixTQUFTTyxNQUFNIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9pbmRleC5qcz8xNzMyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIHByb3RvYnVmID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9pbmRleC1saWdodFwiKTtcblxucHJvdG9idWYuYnVpbGQgPSBcImZ1bGxcIjtcblxuLy8gUGFyc2VyXG5wcm90b2J1Zi50b2tlbml6ZSAgICAgICAgID0gcmVxdWlyZShcIi4vdG9rZW5pemVcIik7XG5wcm90b2J1Zi5wYXJzZSAgICAgICAgICAgID0gcmVxdWlyZShcIi4vcGFyc2VcIik7XG5wcm90b2J1Zi5jb21tb24gICAgICAgICAgID0gcmVxdWlyZShcIi4vY29tbW9uXCIpO1xuXG4vLyBDb25maWd1cmUgcGFyc2VyXG5wcm90b2J1Zi5Sb290Ll9jb25maWd1cmUocHJvdG9idWYuVHlwZSwgcHJvdG9idWYucGFyc2UsIHByb3RvYnVmLmNvbW1vbik7XG4iXSwibmFtZXMiOlsicHJvdG9idWYiLCJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSIsImJ1aWxkIiwidG9rZW5pemUiLCJwYXJzZSIsImNvbW1vbiIsIlJvb3QiLCJfY29uZmlndXJlIiwiVHlwZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/protobufjs/src/index.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/src/mapfield.js":
/*!**************************************************!*\
  !*** ../node_modules/protobufjs/src/mapfield.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = MapField;\n// extends Field\nvar Field = __webpack_require__(/*! ./field */ \"(ssr)/../node_modules/protobufjs/src/field.js\");\n((MapField.prototype = Object.create(Field.prototype)).constructor = MapField).className = \"MapField\";\nvar types = __webpack_require__(/*! ./types */ \"(ssr)/../node_modules/protobufjs/src/types.js\"), util = __webpack_require__(/*! ./util */ \"(ssr)/../node_modules/protobufjs/src/util.js\");\n/**\n * Constructs a new map field instance.\n * @classdesc Reflected map field.\n * @extends FieldBase\n * @constructor\n * @param {string} name Unique name within its namespace\n * @param {number} id Unique id within its namespace\n * @param {string} keyType Key type\n * @param {string} type Value type\n * @param {Object.<string,*>} [options] Declared options\n * @param {string} [comment] Comment associated with this field\n */ function MapField(name, id, keyType, type, options, comment) {\n    Field.call(this, name, id, type, undefined, undefined, options, comment);\n    /* istanbul ignore if */ if (!util.isString(keyType)) throw TypeError(\"keyType must be a string\");\n    /**\n     * Key type.\n     * @type {string}\n     */ this.keyType = keyType; // toJSON, marker\n    /**\n     * Resolved key type if not a basic type.\n     * @type {ReflectionObject|null}\n     */ this.resolvedKeyType = null;\n    // Overrides Field#map\n    this.map = true;\n}\n/**\n * Map field descriptor.\n * @interface IMapField\n * @extends {IField}\n * @property {string} keyType Key type\n */ /**\n * Extension map field descriptor.\n * @interface IExtensionMapField\n * @extends IMapField\n * @property {string} extend Extended type\n */ /**\n * Constructs a map field from a map field descriptor.\n * @param {string} name Field name\n * @param {IMapField} json Map field descriptor\n * @returns {MapField} Created map field\n * @throws {TypeError} If arguments are invalid\n */ MapField.fromJSON = function fromJSON(name, json) {\n    return new MapField(name, json.id, json.keyType, json.type, json.options, json.comment);\n};\n/**\n * Converts this map field to a map field descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IMapField} Map field descriptor\n */ MapField.prototype.toJSON = function toJSON(toJSONOptions) {\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n    return util.toObject([\n        \"keyType\",\n        this.keyType,\n        \"type\",\n        this.type,\n        \"id\",\n        this.id,\n        \"extend\",\n        this.extend,\n        \"options\",\n        this.options,\n        \"comment\",\n        keepComments ? this.comment : undefined\n    ]);\n};\n/**\n * @override\n */ MapField.prototype.resolve = function resolve() {\n    if (this.resolved) return this;\n    // Besides a value type, map fields have a key type that may be \"any scalar type except for floating point types and bytes\"\n    if (types.mapKey[this.keyType] === undefined) throw Error(\"invalid key type: \" + this.keyType);\n    return Field.prototype.resolve.call(this);\n};\n/**\n * Map field decorator (TypeScript).\n * @name MapField.d\n * @function\n * @param {number} fieldId Field id\n * @param {\"int32\"|\"uint32\"|\"sint32\"|\"fixed32\"|\"sfixed32\"|\"int64\"|\"uint64\"|\"sint64\"|\"fixed64\"|\"sfixed64\"|\"bool\"|\"string\"} fieldKeyType Field key type\n * @param {\"double\"|\"float\"|\"int32\"|\"uint32\"|\"sint32\"|\"fixed32\"|\"sfixed32\"|\"int64\"|\"uint64\"|\"sint64\"|\"fixed64\"|\"sfixed64\"|\"bool\"|\"string\"|\"bytes\"|Object|Constructor<{}>} fieldValueType Field value type\n * @returns {FieldDecorator} Decorator function\n * @template T extends { [key: string]: number | Long | string | boolean | Uint8Array | Buffer | number[] | Message<{}> }\n */ MapField.d = function decorateMapField(fieldId, fieldKeyType, fieldValueType) {\n    // submessage value: decorate the submessage and use its name as the type\n    if (typeof fieldValueType === \"function\") fieldValueType = util.decorateType(fieldValueType).name;\n    else if (fieldValueType && typeof fieldValueType === \"object\") fieldValueType = util.decorateEnum(fieldValueType).name;\n    return function mapFieldDecorator(prototype, fieldName) {\n        util.decorateType(prototype.constructor).add(new MapField(fieldName, fieldId, fieldKeyType, fieldValueType));\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL21hcGZpZWxkLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLE9BQU9DLE9BQU8sR0FBR0M7QUFFakIsZ0JBQWdCO0FBQ2hCLElBQUlDLFFBQVFDLG1CQUFPQSxDQUFDLDhEQUFTO0FBQzVCLEVBQUNGLFNBQVNHLFNBQVMsR0FBR0MsT0FBT0MsTUFBTSxDQUFDSixNQUFNRSxTQUFTLEdBQUdHLFdBQVcsR0FBR04sUUFBTyxFQUFHTyxTQUFTLEdBQUc7QUFFM0YsSUFBSUMsUUFBVU4sbUJBQU9BLENBQUMsOERBQVMsR0FDM0JPLE9BQVVQLG1CQUFPQSxDQUFDLDREQUFRO0FBRTlCOzs7Ozs7Ozs7OztDQVdDLEdBQ0QsU0FBU0YsU0FBU1UsSUFBSSxFQUFFQyxFQUFFLEVBQUVDLE9BQU8sRUFBRUMsSUFBSSxFQUFFQyxPQUFPLEVBQUVDLE9BQU87SUFDdkRkLE1BQU1lLElBQUksQ0FBQyxJQUFJLEVBQUVOLE1BQU1DLElBQUlFLE1BQU1JLFdBQVdBLFdBQVdILFNBQVNDO0lBRWhFLHNCQUFzQixHQUN0QixJQUFJLENBQUNOLEtBQUtTLFFBQVEsQ0FBQ04sVUFDZixNQUFNTyxVQUFVO0lBRXBCOzs7S0FHQyxHQUNELElBQUksQ0FBQ1AsT0FBTyxHQUFHQSxTQUFTLGlCQUFpQjtJQUV6Qzs7O0tBR0MsR0FDRCxJQUFJLENBQUNRLGVBQWUsR0FBRztJQUV2QixzQkFBc0I7SUFDdEIsSUFBSSxDQUFDQyxHQUFHLEdBQUc7QUFDZjtBQUVBOzs7OztDQUtDLEdBRUQ7Ozs7O0NBS0MsR0FFRDs7Ozs7O0NBTUMsR0FDRHJCLFNBQVNzQixRQUFRLEdBQUcsU0FBU0EsU0FBU1osSUFBSSxFQUFFYSxJQUFJO0lBQzVDLE9BQU8sSUFBSXZCLFNBQVNVLE1BQU1hLEtBQUtaLEVBQUUsRUFBRVksS0FBS1gsT0FBTyxFQUFFVyxLQUFLVixJQUFJLEVBQUVVLEtBQUtULE9BQU8sRUFBRVMsS0FBS1IsT0FBTztBQUMxRjtBQUVBOzs7O0NBSUMsR0FDRGYsU0FBU0csU0FBUyxDQUFDcUIsTUFBTSxHQUFHLFNBQVNBLE9BQU9DLGFBQWE7SUFDckQsSUFBSUMsZUFBZUQsZ0JBQWdCRSxRQUFRRixjQUFjQyxZQUFZLElBQUk7SUFDekUsT0FBT2pCLEtBQUttQixRQUFRLENBQUM7UUFDakI7UUFBWSxJQUFJLENBQUNoQixPQUFPO1FBQ3hCO1FBQVksSUFBSSxDQUFDQyxJQUFJO1FBQ3JCO1FBQVksSUFBSSxDQUFDRixFQUFFO1FBQ25CO1FBQVksSUFBSSxDQUFDa0IsTUFBTTtRQUN2QjtRQUFZLElBQUksQ0FBQ2YsT0FBTztRQUN4QjtRQUFZWSxlQUFlLElBQUksQ0FBQ1gsT0FBTyxHQUFHRTtLQUM3QztBQUNMO0FBRUE7O0NBRUMsR0FDRGpCLFNBQVNHLFNBQVMsQ0FBQzJCLE9BQU8sR0FBRyxTQUFTQTtJQUNsQyxJQUFJLElBQUksQ0FBQ0MsUUFBUSxFQUNiLE9BQU8sSUFBSTtJQUVmLDJIQUEySDtJQUMzSCxJQUFJdkIsTUFBTXdCLE1BQU0sQ0FBQyxJQUFJLENBQUNwQixPQUFPLENBQUMsS0FBS0ssV0FDL0IsTUFBTWdCLE1BQU0sdUJBQXVCLElBQUksQ0FBQ3JCLE9BQU87SUFFbkQsT0FBT1gsTUFBTUUsU0FBUyxDQUFDMkIsT0FBTyxDQUFDZCxJQUFJLENBQUMsSUFBSTtBQUM1QztBQUVBOzs7Ozs7Ozs7Q0FTQyxHQUNEaEIsU0FBU2tDLENBQUMsR0FBRyxTQUFTQyxpQkFBaUJDLE9BQU8sRUFBRUMsWUFBWSxFQUFFQyxjQUFjO0lBRXhFLHlFQUF5RTtJQUN6RSxJQUFJLE9BQU9BLG1CQUFtQixZQUMxQkEsaUJBQWlCN0IsS0FBSzhCLFlBQVksQ0FBQ0QsZ0JBQWdCNUIsSUFBSTtTQUd0RCxJQUFJNEIsa0JBQWtCLE9BQU9BLG1CQUFtQixVQUNqREEsaUJBQWlCN0IsS0FBSytCLFlBQVksQ0FBQ0YsZ0JBQWdCNUIsSUFBSTtJQUUzRCxPQUFPLFNBQVMrQixrQkFBa0J0QyxTQUFTLEVBQUV1QyxTQUFTO1FBQ2xEakMsS0FBSzhCLFlBQVksQ0FBQ3BDLFVBQVVHLFdBQVcsRUFDbENxQyxHQUFHLENBQUMsSUFBSTNDLFNBQVMwQyxXQUFXTixTQUFTQyxjQUFjQztJQUM1RDtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9tYXBmaWVsZC5qcz9mNjE4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBNYXBGaWVsZDtcblxuLy8gZXh0ZW5kcyBGaWVsZFxudmFyIEZpZWxkID0gcmVxdWlyZShcIi4vZmllbGRcIik7XG4oKE1hcEZpZWxkLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRmllbGQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBNYXBGaWVsZCkuY2xhc3NOYW1lID0gXCJNYXBGaWVsZFwiO1xuXG52YXIgdHlwZXMgICA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpLFxuICAgIHV0aWwgICAgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgbWFwIGZpZWxkIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBSZWZsZWN0ZWQgbWFwIGZpZWxkLlxuICogQGV4dGVuZHMgRmllbGRCYXNlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFVuaXF1ZSBuYW1lIHdpdGhpbiBpdHMgbmFtZXNwYWNlXG4gKiBAcGFyYW0ge251bWJlcn0gaWQgVW5pcXVlIGlkIHdpdGhpbiBpdHMgbmFtZXNwYWNlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5VHlwZSBLZXkgdHlwZVxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVmFsdWUgdHlwZVxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gW29wdGlvbnNdIERlY2xhcmVkIG9wdGlvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29tbWVudF0gQ29tbWVudCBhc3NvY2lhdGVkIHdpdGggdGhpcyBmaWVsZFxuICovXG5mdW5jdGlvbiBNYXBGaWVsZChuYW1lLCBpZCwga2V5VHlwZSwgdHlwZSwgb3B0aW9ucywgY29tbWVudCkge1xuICAgIEZpZWxkLmNhbGwodGhpcywgbmFtZSwgaWQsIHR5cGUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBvcHRpb25zLCBjb21tZW50KTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghdXRpbC5pc1N0cmluZyhrZXlUeXBlKSlcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwia2V5VHlwZSBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuXG4gICAgLyoqXG4gICAgICogS2V5IHR5cGUuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmtleVR5cGUgPSBrZXlUeXBlOyAvLyB0b0pTT04sIG1hcmtlclxuXG4gICAgLyoqXG4gICAgICogUmVzb2x2ZWQga2V5IHR5cGUgaWYgbm90IGEgYmFzaWMgdHlwZS5cbiAgICAgKiBAdHlwZSB7UmVmbGVjdGlvbk9iamVjdHxudWxsfVxuICAgICAqL1xuICAgIHRoaXMucmVzb2x2ZWRLZXlUeXBlID0gbnVsbDtcblxuICAgIC8vIE92ZXJyaWRlcyBGaWVsZCNtYXBcbiAgICB0aGlzLm1hcCA9IHRydWU7XG59XG5cbi8qKlxuICogTWFwIGZpZWxkIGRlc2NyaXB0b3IuXG4gKiBAaW50ZXJmYWNlIElNYXBGaWVsZFxuICogQGV4dGVuZHMge0lGaWVsZH1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBrZXlUeXBlIEtleSB0eXBlXG4gKi9cblxuLyoqXG4gKiBFeHRlbnNpb24gbWFwIGZpZWxkIGRlc2NyaXB0b3IuXG4gKiBAaW50ZXJmYWNlIElFeHRlbnNpb25NYXBGaWVsZFxuICogQGV4dGVuZHMgSU1hcEZpZWxkXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZXh0ZW5kIEV4dGVuZGVkIHR5cGVcbiAqL1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBtYXAgZmllbGQgZnJvbSBhIG1hcCBmaWVsZCBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgRmllbGQgbmFtZVxuICogQHBhcmFtIHtJTWFwRmllbGR9IGpzb24gTWFwIGZpZWxkIGRlc2NyaXB0b3JcbiAqIEByZXR1cm5zIHtNYXBGaWVsZH0gQ3JlYXRlZCBtYXAgZmllbGRcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYXJndW1lbnRzIGFyZSBpbnZhbGlkXG4gKi9cbk1hcEZpZWxkLmZyb21KU09OID0gZnVuY3Rpb24gZnJvbUpTT04obmFtZSwganNvbikge1xuICAgIHJldHVybiBuZXcgTWFwRmllbGQobmFtZSwganNvbi5pZCwganNvbi5rZXlUeXBlLCBqc29uLnR5cGUsIGpzb24ub3B0aW9ucywganNvbi5jb21tZW50KTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBtYXAgZmllbGQgdG8gYSBtYXAgZmllbGQgZGVzY3JpcHRvci5cbiAqIEBwYXJhbSB7SVRvSlNPTk9wdGlvbnN9IFt0b0pTT05PcHRpb25zXSBKU09OIGNvbnZlcnNpb24gb3B0aW9uc1xuICogQHJldHVybnMge0lNYXBGaWVsZH0gTWFwIGZpZWxkIGRlc2NyaXB0b3JcbiAqL1xuTWFwRmllbGQucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTih0b0pTT05PcHRpb25zKSB7XG4gICAgdmFyIGtlZXBDb21tZW50cyA9IHRvSlNPTk9wdGlvbnMgPyBCb29sZWFuKHRvSlNPTk9wdGlvbnMua2VlcENvbW1lbnRzKSA6IGZhbHNlO1xuICAgIHJldHVybiB1dGlsLnRvT2JqZWN0KFtcbiAgICAgICAgXCJrZXlUeXBlXCIgLCB0aGlzLmtleVR5cGUsXG4gICAgICAgIFwidHlwZVwiICAgICwgdGhpcy50eXBlLFxuICAgICAgICBcImlkXCIgICAgICAsIHRoaXMuaWQsXG4gICAgICAgIFwiZXh0ZW5kXCIgICwgdGhpcy5leHRlbmQsXG4gICAgICAgIFwib3B0aW9uc1wiICwgdGhpcy5vcHRpb25zLFxuICAgICAgICBcImNvbW1lbnRcIiAsIGtlZXBDb21tZW50cyA/IHRoaXMuY29tbWVudCA6IHVuZGVmaW5lZFxuICAgIF0pO1xufTtcblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuTWFwRmllbGQucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiByZXNvbHZlKCkge1xuICAgIGlmICh0aGlzLnJlc29sdmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIC8vIEJlc2lkZXMgYSB2YWx1ZSB0eXBlLCBtYXAgZmllbGRzIGhhdmUgYSBrZXkgdHlwZSB0aGF0IG1heSBiZSBcImFueSBzY2FsYXIgdHlwZSBleGNlcHQgZm9yIGZsb2F0aW5nIHBvaW50IHR5cGVzIGFuZCBieXRlc1wiXG4gICAgaWYgKHR5cGVzLm1hcEtleVt0aGlzLmtleVR5cGVdID09PSB1bmRlZmluZWQpXG4gICAgICAgIHRocm93IEVycm9yKFwiaW52YWxpZCBrZXkgdHlwZTogXCIgKyB0aGlzLmtleVR5cGUpO1xuXG4gICAgcmV0dXJuIEZpZWxkLnByb3RvdHlwZS5yZXNvbHZlLmNhbGwodGhpcyk7XG59O1xuXG4vKipcbiAqIE1hcCBmaWVsZCBkZWNvcmF0b3IgKFR5cGVTY3JpcHQpLlxuICogQG5hbWUgTWFwRmllbGQuZFxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gZmllbGRJZCBGaWVsZCBpZFxuICogQHBhcmFtIHtcImludDMyXCJ8XCJ1aW50MzJcInxcInNpbnQzMlwifFwiZml4ZWQzMlwifFwic2ZpeGVkMzJcInxcImludDY0XCJ8XCJ1aW50NjRcInxcInNpbnQ2NFwifFwiZml4ZWQ2NFwifFwic2ZpeGVkNjRcInxcImJvb2xcInxcInN0cmluZ1wifSBmaWVsZEtleVR5cGUgRmllbGQga2V5IHR5cGVcbiAqIEBwYXJhbSB7XCJkb3VibGVcInxcImZsb2F0XCJ8XCJpbnQzMlwifFwidWludDMyXCJ8XCJzaW50MzJcInxcImZpeGVkMzJcInxcInNmaXhlZDMyXCJ8XCJpbnQ2NFwifFwidWludDY0XCJ8XCJzaW50NjRcInxcImZpeGVkNjRcInxcInNmaXhlZDY0XCJ8XCJib29sXCJ8XCJzdHJpbmdcInxcImJ5dGVzXCJ8T2JqZWN0fENvbnN0cnVjdG9yPHt9Pn0gZmllbGRWYWx1ZVR5cGUgRmllbGQgdmFsdWUgdHlwZVxuICogQHJldHVybnMge0ZpZWxkRGVjb3JhdG9yfSBEZWNvcmF0b3IgZnVuY3Rpb25cbiAqIEB0ZW1wbGF0ZSBUIGV4dGVuZHMgeyBba2V5OiBzdHJpbmddOiBudW1iZXIgfCBMb25nIHwgc3RyaW5nIHwgYm9vbGVhbiB8IFVpbnQ4QXJyYXkgfCBCdWZmZXIgfCBudW1iZXJbXSB8IE1lc3NhZ2U8e30+IH1cbiAqL1xuTWFwRmllbGQuZCA9IGZ1bmN0aW9uIGRlY29yYXRlTWFwRmllbGQoZmllbGRJZCwgZmllbGRLZXlUeXBlLCBmaWVsZFZhbHVlVHlwZSkge1xuXG4gICAgLy8gc3VibWVzc2FnZSB2YWx1ZTogZGVjb3JhdGUgdGhlIHN1Ym1lc3NhZ2UgYW5kIHVzZSBpdHMgbmFtZSBhcyB0aGUgdHlwZVxuICAgIGlmICh0eXBlb2YgZmllbGRWYWx1ZVR5cGUgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgZmllbGRWYWx1ZVR5cGUgPSB1dGlsLmRlY29yYXRlVHlwZShmaWVsZFZhbHVlVHlwZSkubmFtZTtcblxuICAgIC8vIGVudW0gcmVmZXJlbmNlIHZhbHVlOiBjcmVhdGUgYSByZWZsZWN0ZWQgY29weSBvZiB0aGUgZW51bSBhbmQga2VlcCByZXVzZWluZyBpdFxuICAgIGVsc2UgaWYgKGZpZWxkVmFsdWVUeXBlICYmIHR5cGVvZiBmaWVsZFZhbHVlVHlwZSA9PT0gXCJvYmplY3RcIilcbiAgICAgICAgZmllbGRWYWx1ZVR5cGUgPSB1dGlsLmRlY29yYXRlRW51bShmaWVsZFZhbHVlVHlwZSkubmFtZTtcblxuICAgIHJldHVybiBmdW5jdGlvbiBtYXBGaWVsZERlY29yYXRvcihwcm90b3R5cGUsIGZpZWxkTmFtZSkge1xuICAgICAgICB1dGlsLmRlY29yYXRlVHlwZShwcm90b3R5cGUuY29uc3RydWN0b3IpXG4gICAgICAgICAgICAuYWRkKG5ldyBNYXBGaWVsZChmaWVsZE5hbWUsIGZpZWxkSWQsIGZpZWxkS2V5VHlwZSwgZmllbGRWYWx1ZVR5cGUpKTtcbiAgICB9O1xufTtcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwiTWFwRmllbGQiLCJGaWVsZCIsInJlcXVpcmUiLCJwcm90b3R5cGUiLCJPYmplY3QiLCJjcmVhdGUiLCJjb25zdHJ1Y3RvciIsImNsYXNzTmFtZSIsInR5cGVzIiwidXRpbCIsIm5hbWUiLCJpZCIsImtleVR5cGUiLCJ0eXBlIiwib3B0aW9ucyIsImNvbW1lbnQiLCJjYWxsIiwidW5kZWZpbmVkIiwiaXNTdHJpbmciLCJUeXBlRXJyb3IiLCJyZXNvbHZlZEtleVR5cGUiLCJtYXAiLCJmcm9tSlNPTiIsImpzb24iLCJ0b0pTT04iLCJ0b0pTT05PcHRpb25zIiwia2VlcENvbW1lbnRzIiwiQm9vbGVhbiIsInRvT2JqZWN0IiwiZXh0ZW5kIiwicmVzb2x2ZSIsInJlc29sdmVkIiwibWFwS2V5IiwiRXJyb3IiLCJkIiwiZGVjb3JhdGVNYXBGaWVsZCIsImZpZWxkSWQiLCJmaWVsZEtleVR5cGUiLCJmaWVsZFZhbHVlVHlwZSIsImRlY29yYXRlVHlwZSIsImRlY29yYXRlRW51bSIsIm1hcEZpZWxkRGVjb3JhdG9yIiwiZmllbGROYW1lIiwiYWRkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/protobufjs/src/mapfield.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/src/message.js":
/*!*************************************************!*\
  !*** ../node_modules/protobufjs/src/message.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = Message;\nvar util = __webpack_require__(/*! ./util/minimal */ \"(ssr)/../node_modules/protobufjs/src/util/minimal.js\");\n/**\n * Constructs a new message instance.\n * @classdesc Abstract runtime message.\n * @constructor\n * @param {Properties<T>} [properties] Properties to set\n * @template T extends object = object\n */ function Message(properties) {\n    // not used internally\n    if (properties) for(var keys = Object.keys(properties), i = 0; i < keys.length; ++i)this[keys[i]] = properties[keys[i]];\n}\n/**\n * Reference to the reflected type.\n * @name Message.$type\n * @type {Type}\n * @readonly\n */ /**\n * Reference to the reflected type.\n * @name Message#$type\n * @type {Type}\n * @readonly\n */ /*eslint-disable valid-jsdoc*/ /**\n * Creates a new message of this type using the specified properties.\n * @param {Object.<string,*>} [properties] Properties to set\n * @returns {Message<T>} Message instance\n * @template T extends Message<T>\n * @this Constructor<T>\n */ Message.create = function create(properties) {\n    return this.$type.create(properties);\n};\n/**\n * Encodes a message of this type.\n * @param {T|Object.<string,*>} message Message to encode\n * @param {Writer} [writer] Writer to use\n * @returns {Writer} Writer\n * @template T extends Message<T>\n * @this Constructor<T>\n */ Message.encode = function encode(message, writer) {\n    return this.$type.encode(message, writer);\n};\n/**\n * Encodes a message of this type preceeded by its length as a varint.\n * @param {T|Object.<string,*>} message Message to encode\n * @param {Writer} [writer] Writer to use\n * @returns {Writer} Writer\n * @template T extends Message<T>\n * @this Constructor<T>\n */ Message.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.$type.encodeDelimited(message, writer);\n};\n/**\n * Decodes a message of this type.\n * @name Message.decode\n * @function\n * @param {Reader|Uint8Array} reader Reader or buffer to decode\n * @returns {T} Decoded message\n * @template T extends Message<T>\n * @this Constructor<T>\n */ Message.decode = function decode(reader) {\n    return this.$type.decode(reader);\n};\n/**\n * Decodes a message of this type preceeded by its length as a varint.\n * @name Message.decodeDelimited\n * @function\n * @param {Reader|Uint8Array} reader Reader or buffer to decode\n * @returns {T} Decoded message\n * @template T extends Message<T>\n * @this Constructor<T>\n */ Message.decodeDelimited = function decodeDelimited(reader) {\n    return this.$type.decodeDelimited(reader);\n};\n/**\n * Verifies a message of this type.\n * @name Message.verify\n * @function\n * @param {Object.<string,*>} message Plain object to verify\n * @returns {string|null} `null` if valid, otherwise the reason why it is not\n */ Message.verify = function verify(message) {\n    return this.$type.verify(message);\n};\n/**\n * Creates a new message of this type from a plain object. Also converts values to their respective internal types.\n * @param {Object.<string,*>} object Plain object\n * @returns {T} Message instance\n * @template T extends Message<T>\n * @this Constructor<T>\n */ Message.fromObject = function fromObject(object) {\n    return this.$type.fromObject(object);\n};\n/**\n * Creates a plain object from a message of this type. Also converts values to other types if specified.\n * @param {T} message Message instance\n * @param {IConversionOptions} [options] Conversion options\n * @returns {Object.<string,*>} Plain object\n * @template T extends Message<T>\n * @this Constructor<T>\n */ Message.toObject = function toObject(message, options) {\n    return this.$type.toObject(message, options);\n};\n/**\n * Converts this message to JSON.\n * @returns {Object.<string,*>} JSON object\n */ Message.prototype.toJSON = function toJSON() {\n    return this.$type.toObject(this, util.toJSONOptions);\n}; /*eslint-enable valid-jsdoc*/ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL21lc3NhZ2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsT0FBT0MsT0FBTyxHQUFHQztBQUVqQixJQUFJQyxPQUFPQyxtQkFBT0EsQ0FBQyw0RUFBZ0I7QUFFbkM7Ozs7OztDQU1DLEdBQ0QsU0FBU0YsUUFBUUcsVUFBVTtJQUN2QixzQkFBc0I7SUFDdEIsSUFBSUEsWUFDQSxJQUFLLElBQUlDLE9BQU9DLE9BQU9ELElBQUksQ0FBQ0QsYUFBYUcsSUFBSSxHQUFHQSxJQUFJRixLQUFLRyxNQUFNLEVBQUUsRUFBRUQsRUFDL0QsSUFBSSxDQUFDRixJQUFJLENBQUNFLEVBQUUsQ0FBQyxHQUFHSCxVQUFVLENBQUNDLElBQUksQ0FBQ0UsRUFBRSxDQUFDO0FBQy9DO0FBRUE7Ozs7O0NBS0MsR0FFRDs7Ozs7Q0FLQyxHQUVELDRCQUE0QixHQUU1Qjs7Ozs7O0NBTUMsR0FDRE4sUUFBUVEsTUFBTSxHQUFHLFNBQVNBLE9BQU9MLFVBQVU7SUFDdkMsT0FBTyxJQUFJLENBQUNNLEtBQUssQ0FBQ0QsTUFBTSxDQUFDTDtBQUM3QjtBQUVBOzs7Ozs7O0NBT0MsR0FDREgsUUFBUVUsTUFBTSxHQUFHLFNBQVNBLE9BQU9DLE9BQU8sRUFBRUMsTUFBTTtJQUM1QyxPQUFPLElBQUksQ0FBQ0gsS0FBSyxDQUFDQyxNQUFNLENBQUNDLFNBQVNDO0FBQ3RDO0FBRUE7Ozs7Ozs7Q0FPQyxHQUNEWixRQUFRYSxlQUFlLEdBQUcsU0FBU0EsZ0JBQWdCRixPQUFPLEVBQUVDLE1BQU07SUFDOUQsT0FBTyxJQUFJLENBQUNILEtBQUssQ0FBQ0ksZUFBZSxDQUFDRixTQUFTQztBQUMvQztBQUVBOzs7Ozs7OztDQVFDLEdBQ0RaLFFBQVFjLE1BQU0sR0FBRyxTQUFTQSxPQUFPQyxNQUFNO0lBQ25DLE9BQU8sSUFBSSxDQUFDTixLQUFLLENBQUNLLE1BQU0sQ0FBQ0M7QUFDN0I7QUFFQTs7Ozs7Ozs7Q0FRQyxHQUNEZixRQUFRZ0IsZUFBZSxHQUFHLFNBQVNBLGdCQUFnQkQsTUFBTTtJQUNyRCxPQUFPLElBQUksQ0FBQ04sS0FBSyxDQUFDTyxlQUFlLENBQUNEO0FBQ3RDO0FBRUE7Ozs7OztDQU1DLEdBQ0RmLFFBQVFpQixNQUFNLEdBQUcsU0FBU0EsT0FBT04sT0FBTztJQUNwQyxPQUFPLElBQUksQ0FBQ0YsS0FBSyxDQUFDUSxNQUFNLENBQUNOO0FBQzdCO0FBRUE7Ozs7OztDQU1DLEdBQ0RYLFFBQVFrQixVQUFVLEdBQUcsU0FBU0EsV0FBV0MsTUFBTTtJQUMzQyxPQUFPLElBQUksQ0FBQ1YsS0FBSyxDQUFDUyxVQUFVLENBQUNDO0FBQ2pDO0FBRUE7Ozs7Ozs7Q0FPQyxHQUNEbkIsUUFBUW9CLFFBQVEsR0FBRyxTQUFTQSxTQUFTVCxPQUFPLEVBQUVVLE9BQU87SUFDakQsT0FBTyxJQUFJLENBQUNaLEtBQUssQ0FBQ1csUUFBUSxDQUFDVCxTQUFTVTtBQUN4QztBQUVBOzs7Q0FHQyxHQUNEckIsUUFBUXNCLFNBQVMsQ0FBQ0MsTUFBTSxHQUFHLFNBQVNBO0lBQ2hDLE9BQU8sSUFBSSxDQUFDZCxLQUFLLENBQUNXLFFBQVEsQ0FBQyxJQUFJLEVBQUVuQixLQUFLdUIsYUFBYTtBQUN2RCxHQUVBLDJCQUEyQiIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvbWVzc2FnZS5qcz84MmNkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBNZXNzYWdlO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWwvbWluaW1hbFwiKTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IG1lc3NhZ2UgaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIEFic3RyYWN0IHJ1bnRpbWUgbWVzc2FnZS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtQcm9wZXJ0aWVzPFQ+fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAqIEB0ZW1wbGF0ZSBUIGV4dGVuZHMgb2JqZWN0ID0gb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIE1lc3NhZ2UocHJvcGVydGllcykge1xuICAgIC8vIG5vdCB1c2VkIGludGVybmFsbHlcbiAgICBpZiAocHJvcGVydGllcylcbiAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbn1cblxuLyoqXG4gKiBSZWZlcmVuY2UgdG8gdGhlIHJlZmxlY3RlZCB0eXBlLlxuICogQG5hbWUgTWVzc2FnZS4kdHlwZVxuICogQHR5cGUge1R5cGV9XG4gKiBAcmVhZG9ubHlcbiAqL1xuXG4vKipcbiAqIFJlZmVyZW5jZSB0byB0aGUgcmVmbGVjdGVkIHR5cGUuXG4gKiBAbmFtZSBNZXNzYWdlIyR0eXBlXG4gKiBAdHlwZSB7VHlwZX1cbiAqIEByZWFkb25seVxuICovXG5cbi8qZXNsaW50LWRpc2FibGUgdmFsaWQtanNkb2MqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbWVzc2FnZSBvZiB0aGlzIHR5cGUgdXNpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gKiBAcmV0dXJucyB7TWVzc2FnZTxUPn0gTWVzc2FnZSBpbnN0YW5jZVxuICogQHRlbXBsYXRlIFQgZXh0ZW5kcyBNZXNzYWdlPFQ+XG4gKiBAdGhpcyBDb25zdHJ1Y3RvcjxUPlxuICovXG5NZXNzYWdlLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgcmV0dXJuIHRoaXMuJHR5cGUuY3JlYXRlKHByb3BlcnRpZXMpO1xufTtcblxuLyoqXG4gKiBFbmNvZGVzIGEgbWVzc2FnZSBvZiB0aGlzIHR5cGUuXG4gKiBAcGFyYW0ge1R8T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgTWVzc2FnZSB0byBlbmNvZGVcbiAqIEBwYXJhbSB7V3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gdXNlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBXcml0ZXJcbiAqIEB0ZW1wbGF0ZSBUIGV4dGVuZHMgTWVzc2FnZTxUPlxuICogQHRoaXMgQ29uc3RydWN0b3I8VD5cbiAqL1xuTWVzc2FnZS5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuJHR5cGUuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcik7XG59O1xuXG4vKipcbiAqIEVuY29kZXMgYSBtZXNzYWdlIG9mIHRoaXMgdHlwZSBwcmVjZWVkZWQgYnkgaXRzIGxlbmd0aCBhcyBhIHZhcmludC5cbiAqIEBwYXJhbSB7VHxPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBNZXNzYWdlIHRvIGVuY29kZVxuICogQHBhcmFtIHtXcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byB1c2VcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IFdyaXRlclxuICogQHRlbXBsYXRlIFQgZXh0ZW5kcyBNZXNzYWdlPFQ+XG4gKiBAdGhpcyBDb25zdHJ1Y3RvcjxUPlxuICovXG5NZXNzYWdlLmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICByZXR1cm4gdGhpcy4kdHlwZS5lbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKTtcbn07XG5cbi8qKlxuICogRGVjb2RlcyBhIG1lc3NhZ2Ugb2YgdGhpcyB0eXBlLlxuICogQG5hbWUgTWVzc2FnZS5kZWNvZGVcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtSZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlXG4gKiBAcmV0dXJucyB7VH0gRGVjb2RlZCBtZXNzYWdlXG4gKiBAdGVtcGxhdGUgVCBleHRlbmRzIE1lc3NhZ2U8VD5cbiAqIEB0aGlzIENvbnN0cnVjdG9yPFQ+XG4gKi9cbk1lc3NhZ2UuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlcikge1xuICAgIHJldHVybiB0aGlzLiR0eXBlLmRlY29kZShyZWFkZXIpO1xufTtcblxuLyoqXG4gKiBEZWNvZGVzIGEgbWVzc2FnZSBvZiB0aGlzIHR5cGUgcHJlY2VlZGVkIGJ5IGl0cyBsZW5ndGggYXMgYSB2YXJpbnQuXG4gKiBAbmFtZSBNZXNzYWdlLmRlY29kZURlbGltaXRlZFxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge1JlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGVcbiAqIEByZXR1cm5zIHtUfSBEZWNvZGVkIG1lc3NhZ2VcbiAqIEB0ZW1wbGF0ZSBUIGV4dGVuZHMgTWVzc2FnZTxUPlxuICogQHRoaXMgQ29uc3RydWN0b3I8VD5cbiAqL1xuTWVzc2FnZS5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuJHR5cGUuZGVjb2RlRGVsaW1pdGVkKHJlYWRlcik7XG59O1xuXG4vKipcbiAqIFZlcmlmaWVzIGEgbWVzc2FnZSBvZiB0aGlzIHR5cGUuXG4gKiBAbmFtZSBNZXNzYWdlLnZlcmlmeVxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIFBsYWluIG9iamVjdCB0byB2ZXJpZnlcbiAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gYG51bGxgIGlmIHZhbGlkLCBvdGhlcndpc2UgdGhlIHJlYXNvbiB3aHkgaXQgaXMgbm90XG4gKi9cbk1lc3NhZ2UudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy4kdHlwZS52ZXJpZnkobWVzc2FnZSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbWVzc2FnZSBvZiB0aGlzIHR5cGUgZnJvbSBhIHBsYWluIG9iamVjdC4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gdGhlaXIgcmVzcGVjdGl2ZSBpbnRlcm5hbCB0eXBlcy5cbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9iamVjdCBQbGFpbiBvYmplY3RcbiAqIEByZXR1cm5zIHtUfSBNZXNzYWdlIGluc3RhbmNlXG4gKiBAdGVtcGxhdGUgVCBleHRlbmRzIE1lc3NhZ2U8VD5cbiAqIEB0aGlzIENvbnN0cnVjdG9yPFQ+XG4gKi9cbk1lc3NhZ2UuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgcmV0dXJuIHRoaXMuJHR5cGUuZnJvbU9iamVjdChvYmplY3QpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgcGxhaW4gb2JqZWN0IGZyb20gYSBtZXNzYWdlIG9mIHRoaXMgdHlwZS4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gb3RoZXIgdHlwZXMgaWYgc3BlY2lmaWVkLlxuICogQHBhcmFtIHtUfSBtZXNzYWdlIE1lc3NhZ2UgaW5zdGFuY2VcbiAqIEBwYXJhbSB7SUNvbnZlcnNpb25PcHRpb25zfSBbb3B0aW9uc10gQ29udmVyc2lvbiBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IFBsYWluIG9iamVjdFxuICogQHRlbXBsYXRlIFQgZXh0ZW5kcyBNZXNzYWdlPFQ+XG4gKiBAdGhpcyBDb25zdHJ1Y3RvcjxUPlxuICovXG5NZXNzYWdlLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLiR0eXBlLnRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIG1lc3NhZ2UgdG8gSlNPTi5cbiAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gSlNPTiBvYmplY3RcbiAqL1xuTWVzc2FnZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLiR0eXBlLnRvT2JqZWN0KHRoaXMsIHV0aWwudG9KU09OT3B0aW9ucyk7XG59O1xuXG4vKmVzbGludC1lbmFibGUgdmFsaWQtanNkb2MqLyJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwiTWVzc2FnZSIsInV0aWwiLCJyZXF1aXJlIiwicHJvcGVydGllcyIsImtleXMiLCJPYmplY3QiLCJpIiwibGVuZ3RoIiwiY3JlYXRlIiwiJHR5cGUiLCJlbmNvZGUiLCJtZXNzYWdlIiwid3JpdGVyIiwiZW5jb2RlRGVsaW1pdGVkIiwiZGVjb2RlIiwicmVhZGVyIiwiZGVjb2RlRGVsaW1pdGVkIiwidmVyaWZ5IiwiZnJvbU9iamVjdCIsIm9iamVjdCIsInRvT2JqZWN0Iiwib3B0aW9ucyIsInByb3RvdHlwZSIsInRvSlNPTiIsInRvSlNPTk9wdGlvbnMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/protobufjs/src/message.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/src/method.js":
/*!************************************************!*\
  !*** ../node_modules/protobufjs/src/method.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = Method;\n// extends ReflectionObject\nvar ReflectionObject = __webpack_require__(/*! ./object */ \"(ssr)/../node_modules/protobufjs/src/object.js\");\n((Method.prototype = Object.create(ReflectionObject.prototype)).constructor = Method).className = \"Method\";\nvar util = __webpack_require__(/*! ./util */ \"(ssr)/../node_modules/protobufjs/src/util.js\");\n/**\n * Constructs a new service method instance.\n * @classdesc Reflected service method.\n * @extends ReflectionObject\n * @constructor\n * @param {string} name Method name\n * @param {string|undefined} type Method type, usually `\"rpc\"`\n * @param {string} requestType Request message type\n * @param {string} responseType Response message type\n * @param {boolean|Object.<string,*>} [requestStream] Whether the request is streamed\n * @param {boolean|Object.<string,*>} [responseStream] Whether the response is streamed\n * @param {Object.<string,*>} [options] Declared options\n * @param {string} [comment] The comment for this method\n * @param {Object.<string,*>} [parsedOptions] Declared options, properly parsed into an object\n */ function Method(name, type, requestType, responseType, requestStream, responseStream, options, comment, parsedOptions) {\n    /* istanbul ignore next */ if (util.isObject(requestStream)) {\n        options = requestStream;\n        requestStream = responseStream = undefined;\n    } else if (util.isObject(responseStream)) {\n        options = responseStream;\n        responseStream = undefined;\n    }\n    /* istanbul ignore if */ if (!(type === undefined || util.isString(type))) throw TypeError(\"type must be a string\");\n    /* istanbul ignore if */ if (!util.isString(requestType)) throw TypeError(\"requestType must be a string\");\n    /* istanbul ignore if */ if (!util.isString(responseType)) throw TypeError(\"responseType must be a string\");\n    ReflectionObject.call(this, name, options);\n    /**\n     * Method type.\n     * @type {string}\n     */ this.type = type || \"rpc\"; // toJSON\n    /**\n     * Request type.\n     * @type {string}\n     */ this.requestType = requestType; // toJSON, marker\n    /**\n     * Whether requests are streamed or not.\n     * @type {boolean|undefined}\n     */ this.requestStream = requestStream ? true : undefined; // toJSON\n    /**\n     * Response type.\n     * @type {string}\n     */ this.responseType = responseType; // toJSON\n    /**\n     * Whether responses are streamed or not.\n     * @type {boolean|undefined}\n     */ this.responseStream = responseStream ? true : undefined; // toJSON\n    /**\n     * Resolved request type.\n     * @type {Type|null}\n     */ this.resolvedRequestType = null;\n    /**\n     * Resolved response type.\n     * @type {Type|null}\n     */ this.resolvedResponseType = null;\n    /**\n     * Comment for this method\n     * @type {string|null}\n     */ this.comment = comment;\n    /**\n     * Options properly parsed into an object\n     */ this.parsedOptions = parsedOptions;\n}\n/**\n * Method descriptor.\n * @interface IMethod\n * @property {string} [type=\"rpc\"] Method type\n * @property {string} requestType Request type\n * @property {string} responseType Response type\n * @property {boolean} [requestStream=false] Whether requests are streamed\n * @property {boolean} [responseStream=false] Whether responses are streamed\n * @property {Object.<string,*>} [options] Method options\n * @property {string} comment Method comments\n * @property {Object.<string,*>} [parsedOptions] Method options properly parsed into an object\n */ /**\n * Constructs a method from a method descriptor.\n * @param {string} name Method name\n * @param {IMethod} json Method descriptor\n * @returns {Method} Created method\n * @throws {TypeError} If arguments are invalid\n */ Method.fromJSON = function fromJSON(name, json) {\n    return new Method(name, json.type, json.requestType, json.responseType, json.requestStream, json.responseStream, json.options, json.comment, json.parsedOptions);\n};\n/**\n * Converts this method to a method descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IMethod} Method descriptor\n */ Method.prototype.toJSON = function toJSON(toJSONOptions) {\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n    return util.toObject([\n        \"type\",\n        this.type !== \"rpc\" && /* istanbul ignore next */ this.type || undefined,\n        \"requestType\",\n        this.requestType,\n        \"requestStream\",\n        this.requestStream,\n        \"responseType\",\n        this.responseType,\n        \"responseStream\",\n        this.responseStream,\n        \"options\",\n        this.options,\n        \"comment\",\n        keepComments ? this.comment : undefined,\n        \"parsedOptions\",\n        this.parsedOptions\n    ]);\n};\n/**\n * @override\n */ Method.prototype.resolve = function resolve() {\n    /* istanbul ignore if */ if (this.resolved) return this;\n    this.resolvedRequestType = this.parent.lookupType(this.requestType);\n    this.resolvedResponseType = this.parent.lookupType(this.responseType);\n    return ReflectionObject.prototype.resolve.call(this);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL21ldGhvZC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSxPQUFPQyxPQUFPLEdBQUdDO0FBRWpCLDJCQUEyQjtBQUMzQixJQUFJQyxtQkFBbUJDLG1CQUFPQSxDQUFDLGdFQUFVO0FBQ3hDLEVBQUNGLE9BQU9HLFNBQVMsR0FBR0MsT0FBT0MsTUFBTSxDQUFDSixpQkFBaUJFLFNBQVMsR0FBR0csV0FBVyxHQUFHTixNQUFLLEVBQUdPLFNBQVMsR0FBRztBQUVsRyxJQUFJQyxPQUFPTixtQkFBT0EsQ0FBQyw0REFBUTtBQUUzQjs7Ozs7Ozs7Ozs7Ozs7Q0FjQyxHQUNELFNBQVNGLE9BQU9TLElBQUksRUFBRUMsSUFBSSxFQUFFQyxXQUFXLEVBQUVDLFlBQVksRUFBRUMsYUFBYSxFQUFFQyxjQUFjLEVBQUVDLE9BQU8sRUFBRUMsT0FBTyxFQUFFQyxhQUFhO0lBRWpILHdCQUF3QixHQUN4QixJQUFJVCxLQUFLVSxRQUFRLENBQUNMLGdCQUFnQjtRQUM5QkUsVUFBVUY7UUFDVkEsZ0JBQWdCQyxpQkFBaUJLO0lBQ3JDLE9BQU8sSUFBSVgsS0FBS1UsUUFBUSxDQUFDSixpQkFBaUI7UUFDdENDLFVBQVVEO1FBQ1ZBLGlCQUFpQks7SUFDckI7SUFFQSxzQkFBc0IsR0FDdEIsSUFBSSxDQUFFVCxDQUFBQSxTQUFTUyxhQUFhWCxLQUFLWSxRQUFRLENBQUNWLEtBQUksR0FDMUMsTUFBTVcsVUFBVTtJQUVwQixzQkFBc0IsR0FDdEIsSUFBSSxDQUFDYixLQUFLWSxRQUFRLENBQUNULGNBQ2YsTUFBTVUsVUFBVTtJQUVwQixzQkFBc0IsR0FDdEIsSUFBSSxDQUFDYixLQUFLWSxRQUFRLENBQUNSLGVBQ2YsTUFBTVMsVUFBVTtJQUVwQnBCLGlCQUFpQnFCLElBQUksQ0FBQyxJQUFJLEVBQUViLE1BQU1NO0lBRWxDOzs7S0FHQyxHQUNELElBQUksQ0FBQ0wsSUFBSSxHQUFHQSxRQUFRLE9BQU8sU0FBUztJQUVwQzs7O0tBR0MsR0FDRCxJQUFJLENBQUNDLFdBQVcsR0FBR0EsYUFBYSxpQkFBaUI7SUFFakQ7OztLQUdDLEdBQ0QsSUFBSSxDQUFDRSxhQUFhLEdBQUdBLGdCQUFnQixPQUFPTSxXQUFXLFNBQVM7SUFFaEU7OztLQUdDLEdBQ0QsSUFBSSxDQUFDUCxZQUFZLEdBQUdBLGNBQWMsU0FBUztJQUUzQzs7O0tBR0MsR0FDRCxJQUFJLENBQUNFLGNBQWMsR0FBR0EsaUJBQWlCLE9BQU9LLFdBQVcsU0FBUztJQUVsRTs7O0tBR0MsR0FDRCxJQUFJLENBQUNJLG1CQUFtQixHQUFHO0lBRTNCOzs7S0FHQyxHQUNELElBQUksQ0FBQ0Msb0JBQW9CLEdBQUc7SUFFNUI7OztLQUdDLEdBQ0QsSUFBSSxDQUFDUixPQUFPLEdBQUdBO0lBRWY7O0tBRUMsR0FDRCxJQUFJLENBQUNDLGFBQWEsR0FBR0E7QUFDekI7QUFFQTs7Ozs7Ozs7Ozs7Q0FXQyxHQUVEOzs7Ozs7Q0FNQyxHQUNEakIsT0FBT3lCLFFBQVEsR0FBRyxTQUFTQSxTQUFTaEIsSUFBSSxFQUFFaUIsSUFBSTtJQUMxQyxPQUFPLElBQUkxQixPQUFPUyxNQUFNaUIsS0FBS2hCLElBQUksRUFBRWdCLEtBQUtmLFdBQVcsRUFBRWUsS0FBS2QsWUFBWSxFQUFFYyxLQUFLYixhQUFhLEVBQUVhLEtBQUtaLGNBQWMsRUFBRVksS0FBS1gsT0FBTyxFQUFFVyxLQUFLVixPQUFPLEVBQUVVLEtBQUtULGFBQWE7QUFDbks7QUFFQTs7OztDQUlDLEdBQ0RqQixPQUFPRyxTQUFTLENBQUN3QixNQUFNLEdBQUcsU0FBU0EsT0FBT0MsYUFBYTtJQUNuRCxJQUFJQyxlQUFlRCxnQkFBZ0JFLFFBQVFGLGNBQWNDLFlBQVksSUFBSTtJQUN6RSxPQUFPckIsS0FBS3VCLFFBQVEsQ0FBQztRQUNqQjtRQUFtQixJQUFJLENBQUNyQixJQUFJLEtBQUssU0FBUyx3QkFBd0IsR0FBRyxJQUFJLENBQUNBLElBQUksSUFBSVM7UUFDbEY7UUFBbUIsSUFBSSxDQUFDUixXQUFXO1FBQ25DO1FBQW1CLElBQUksQ0FBQ0UsYUFBYTtRQUNyQztRQUFtQixJQUFJLENBQUNELFlBQVk7UUFDcEM7UUFBbUIsSUFBSSxDQUFDRSxjQUFjO1FBQ3RDO1FBQW1CLElBQUksQ0FBQ0MsT0FBTztRQUMvQjtRQUFtQmMsZUFBZSxJQUFJLENBQUNiLE9BQU8sR0FBR0c7UUFDakQ7UUFBbUIsSUFBSSxDQUFDRixhQUFhO0tBQ3hDO0FBQ0w7QUFFQTs7Q0FFQyxHQUNEakIsT0FBT0csU0FBUyxDQUFDNkIsT0FBTyxHQUFHLFNBQVNBO0lBRWhDLHNCQUFzQixHQUN0QixJQUFJLElBQUksQ0FBQ0MsUUFBUSxFQUNiLE9BQU8sSUFBSTtJQUVmLElBQUksQ0FBQ1YsbUJBQW1CLEdBQUcsSUFBSSxDQUFDVyxNQUFNLENBQUNDLFVBQVUsQ0FBQyxJQUFJLENBQUN4QixXQUFXO0lBQ2xFLElBQUksQ0FBQ2Esb0JBQW9CLEdBQUcsSUFBSSxDQUFDVSxNQUFNLENBQUNDLFVBQVUsQ0FBQyxJQUFJLENBQUN2QixZQUFZO0lBRXBFLE9BQU9YLGlCQUFpQkUsU0FBUyxDQUFDNkIsT0FBTyxDQUFDVixJQUFJLENBQUMsSUFBSTtBQUN2RCIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvbWV0aG9kLmpzPzE1NDUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IE1ldGhvZDtcblxuLy8gZXh0ZW5kcyBSZWZsZWN0aW9uT2JqZWN0XG52YXIgUmVmbGVjdGlvbk9iamVjdCA9IHJlcXVpcmUoXCIuL29iamVjdFwiKTtcbigoTWV0aG9kLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUmVmbGVjdGlvbk9iamVjdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IE1ldGhvZCkuY2xhc3NOYW1lID0gXCJNZXRob2RcIjtcblxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgc2VydmljZSBtZXRob2QgaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIFJlZmxlY3RlZCBzZXJ2aWNlIG1ldGhvZC5cbiAqIEBleHRlbmRzIFJlZmxlY3Rpb25PYmplY3RcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTWV0aG9kIG5hbWVcbiAqIEBwYXJhbSB7c3RyaW5nfHVuZGVmaW5lZH0gdHlwZSBNZXRob2QgdHlwZSwgdXN1YWxseSBgXCJycGNcImBcbiAqIEBwYXJhbSB7c3RyaW5nfSByZXF1ZXN0VHlwZSBSZXF1ZXN0IG1lc3NhZ2UgdHlwZVxuICogQHBhcmFtIHtzdHJpbmd9IHJlc3BvbnNlVHlwZSBSZXNwb25zZSBtZXNzYWdlIHR5cGVcbiAqIEBwYXJhbSB7Ym9vbGVhbnxPYmplY3QuPHN0cmluZywqPn0gW3JlcXVlc3RTdHJlYW1dIFdoZXRoZXIgdGhlIHJlcXVlc3QgaXMgc3RyZWFtZWRcbiAqIEBwYXJhbSB7Ym9vbGVhbnxPYmplY3QuPHN0cmluZywqPn0gW3Jlc3BvbnNlU3RyZWFtXSBXaGV0aGVyIHRoZSByZXNwb25zZSBpcyBzdHJlYW1lZFxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gW29wdGlvbnNdIERlY2xhcmVkIG9wdGlvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29tbWVudF0gVGhlIGNvbW1lbnQgZm9yIHRoaXMgbWV0aG9kXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBbcGFyc2VkT3B0aW9uc10gRGVjbGFyZWQgb3B0aW9ucywgcHJvcGVybHkgcGFyc2VkIGludG8gYW4gb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIE1ldGhvZChuYW1lLCB0eXBlLCByZXF1ZXN0VHlwZSwgcmVzcG9uc2VUeXBlLCByZXF1ZXN0U3RyZWFtLCByZXNwb25zZVN0cmVhbSwgb3B0aW9ucywgY29tbWVudCwgcGFyc2VkT3B0aW9ucykge1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAodXRpbC5pc09iamVjdChyZXF1ZXN0U3RyZWFtKSkge1xuICAgICAgICBvcHRpb25zID0gcmVxdWVzdFN0cmVhbTtcbiAgICAgICAgcmVxdWVzdFN0cmVhbSA9IHJlc3BvbnNlU3RyZWFtID0gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSBpZiAodXRpbC5pc09iamVjdChyZXNwb25zZVN0cmVhbSkpIHtcbiAgICAgICAgb3B0aW9ucyA9IHJlc3BvbnNlU3RyZWFtO1xuICAgICAgICByZXNwb25zZVN0cmVhbSA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoISh0eXBlID09PSB1bmRlZmluZWQgfHwgdXRpbC5pc1N0cmluZyh0eXBlKSkpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcInR5cGUgbXVzdCBiZSBhIHN0cmluZ1wiKTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghdXRpbC5pc1N0cmluZyhyZXF1ZXN0VHlwZSkpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcInJlcXVlc3RUeXBlIG11c3QgYmUgYSBzdHJpbmdcIik7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIXV0aWwuaXNTdHJpbmcocmVzcG9uc2VUeXBlKSlcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwicmVzcG9uc2VUeXBlIG11c3QgYmUgYSBzdHJpbmdcIik7XG5cbiAgICBSZWZsZWN0aW9uT2JqZWN0LmNhbGwodGhpcywgbmFtZSwgb3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdHlwZS5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMudHlwZSA9IHR5cGUgfHwgXCJycGNcIjsgLy8gdG9KU09OXG5cbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0IHR5cGUuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnJlcXVlc3RUeXBlID0gcmVxdWVzdFR5cGU7IC8vIHRvSlNPTiwgbWFya2VyXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHJlcXVlc3RzIGFyZSBzdHJlYW1lZCBvciBub3QuXG4gICAgICogQHR5cGUge2Jvb2xlYW58dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMucmVxdWVzdFN0cmVhbSA9IHJlcXVlc3RTdHJlYW0gPyB0cnVlIDogdW5kZWZpbmVkOyAvLyB0b0pTT05cblxuICAgIC8qKlxuICAgICAqIFJlc3BvbnNlIHR5cGUuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnJlc3BvbnNlVHlwZSA9IHJlc3BvbnNlVHlwZTsgLy8gdG9KU09OXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHJlc3BvbnNlcyBhcmUgc3RyZWFtZWQgb3Igbm90LlxuICAgICAqIEB0eXBlIHtib29sZWFufHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnJlc3BvbnNlU3RyZWFtID0gcmVzcG9uc2VTdHJlYW0gPyB0cnVlIDogdW5kZWZpbmVkOyAvLyB0b0pTT05cblxuICAgIC8qKlxuICAgICAqIFJlc29sdmVkIHJlcXVlc3QgdHlwZS5cbiAgICAgKiBAdHlwZSB7VHlwZXxudWxsfVxuICAgICAqL1xuICAgIHRoaXMucmVzb2x2ZWRSZXF1ZXN0VHlwZSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlZCByZXNwb25zZSB0eXBlLlxuICAgICAqIEB0eXBlIHtUeXBlfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5yZXNvbHZlZFJlc3BvbnNlVHlwZSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBDb21tZW50IGZvciB0aGlzIG1ldGhvZFxuICAgICAqIEB0eXBlIHtzdHJpbmd8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLmNvbW1lbnQgPSBjb21tZW50O1xuXG4gICAgLyoqXG4gICAgICogT3B0aW9ucyBwcm9wZXJseSBwYXJzZWQgaW50byBhbiBvYmplY3RcbiAgICAgKi9cbiAgICB0aGlzLnBhcnNlZE9wdGlvbnMgPSBwYXJzZWRPcHRpb25zO1xufVxuXG4vKipcbiAqIE1ldGhvZCBkZXNjcmlwdG9yLlxuICogQGludGVyZmFjZSBJTWV0aG9kXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3R5cGU9XCJycGNcIl0gTWV0aG9kIHR5cGVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSByZXF1ZXN0VHlwZSBSZXF1ZXN0IHR5cGVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSByZXNwb25zZVR5cGUgUmVzcG9uc2UgdHlwZVxuICogQHByb3BlcnR5IHtib29sZWFufSBbcmVxdWVzdFN0cmVhbT1mYWxzZV0gV2hldGhlciByZXF1ZXN0cyBhcmUgc3RyZWFtZWRcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3Jlc3BvbnNlU3RyZWFtPWZhbHNlXSBXaGV0aGVyIHJlc3BvbnNlcyBhcmUgc3RyZWFtZWRcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsKj59IFtvcHRpb25zXSBNZXRob2Qgb3B0aW9uc1xuICogQHByb3BlcnR5IHtzdHJpbmd9IGNvbW1lbnQgTWV0aG9kIGNvbW1lbnRzXG4gKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLCo+fSBbcGFyc2VkT3B0aW9uc10gTWV0aG9kIG9wdGlvbnMgcHJvcGVybHkgcGFyc2VkIGludG8gYW4gb2JqZWN0XG4gKi9cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbWV0aG9kIGZyb20gYSBtZXRob2QgZGVzY3JpcHRvci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE1ldGhvZCBuYW1lXG4gKiBAcGFyYW0ge0lNZXRob2R9IGpzb24gTWV0aG9kIGRlc2NyaXB0b3JcbiAqIEByZXR1cm5zIHtNZXRob2R9IENyZWF0ZWQgbWV0aG9kXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGFyZ3VtZW50cyBhcmUgaW52YWxpZFxuICovXG5NZXRob2QuZnJvbUpTT04gPSBmdW5jdGlvbiBmcm9tSlNPTihuYW1lLCBqc29uKSB7XG4gICAgcmV0dXJuIG5ldyBNZXRob2QobmFtZSwganNvbi50eXBlLCBqc29uLnJlcXVlc3RUeXBlLCBqc29uLnJlc3BvbnNlVHlwZSwganNvbi5yZXF1ZXN0U3RyZWFtLCBqc29uLnJlc3BvbnNlU3RyZWFtLCBqc29uLm9wdGlvbnMsIGpzb24uY29tbWVudCwganNvbi5wYXJzZWRPcHRpb25zKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBtZXRob2QgdG8gYSBtZXRob2QgZGVzY3JpcHRvci5cbiAqIEBwYXJhbSB7SVRvSlNPTk9wdGlvbnN9IFt0b0pTT05PcHRpb25zXSBKU09OIGNvbnZlcnNpb24gb3B0aW9uc1xuICogQHJldHVybnMge0lNZXRob2R9IE1ldGhvZCBkZXNjcmlwdG9yXG4gKi9cbk1ldGhvZC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKHRvSlNPTk9wdGlvbnMpIHtcbiAgICB2YXIga2VlcENvbW1lbnRzID0gdG9KU09OT3B0aW9ucyA/IEJvb2xlYW4odG9KU09OT3B0aW9ucy5rZWVwQ29tbWVudHMpIDogZmFsc2U7XG4gICAgcmV0dXJuIHV0aWwudG9PYmplY3QoW1xuICAgICAgICBcInR5cGVcIiAgICAgICAgICAgLCB0aGlzLnR5cGUgIT09IFwicnBjXCIgJiYgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gdGhpcy50eXBlIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgXCJyZXF1ZXN0VHlwZVwiICAgICwgdGhpcy5yZXF1ZXN0VHlwZSxcbiAgICAgICAgXCJyZXF1ZXN0U3RyZWFtXCIgICwgdGhpcy5yZXF1ZXN0U3RyZWFtLFxuICAgICAgICBcInJlc3BvbnNlVHlwZVwiICAgLCB0aGlzLnJlc3BvbnNlVHlwZSxcbiAgICAgICAgXCJyZXNwb25zZVN0cmVhbVwiICwgdGhpcy5yZXNwb25zZVN0cmVhbSxcbiAgICAgICAgXCJvcHRpb25zXCIgICAgICAgICwgdGhpcy5vcHRpb25zLFxuICAgICAgICBcImNvbW1lbnRcIiAgICAgICAgLCBrZWVwQ29tbWVudHMgPyB0aGlzLmNvbW1lbnQgOiB1bmRlZmluZWQsXG4gICAgICAgIFwicGFyc2VkT3B0aW9uc1wiICAsIHRoaXMucGFyc2VkT3B0aW9ucyxcbiAgICBdKTtcbn07XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cbk1ldGhvZC5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uIHJlc29sdmUoKSB7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAodGhpcy5yZXNvbHZlZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB0aGlzLnJlc29sdmVkUmVxdWVzdFR5cGUgPSB0aGlzLnBhcmVudC5sb29rdXBUeXBlKHRoaXMucmVxdWVzdFR5cGUpO1xuICAgIHRoaXMucmVzb2x2ZWRSZXNwb25zZVR5cGUgPSB0aGlzLnBhcmVudC5sb29rdXBUeXBlKHRoaXMucmVzcG9uc2VUeXBlKTtcblxuICAgIHJldHVybiBSZWZsZWN0aW9uT2JqZWN0LnByb3RvdHlwZS5yZXNvbHZlLmNhbGwodGhpcyk7XG59O1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJNZXRob2QiLCJSZWZsZWN0aW9uT2JqZWN0IiwicmVxdWlyZSIsInByb3RvdHlwZSIsIk9iamVjdCIsImNyZWF0ZSIsImNvbnN0cnVjdG9yIiwiY2xhc3NOYW1lIiwidXRpbCIsIm5hbWUiLCJ0eXBlIiwicmVxdWVzdFR5cGUiLCJyZXNwb25zZVR5cGUiLCJyZXF1ZXN0U3RyZWFtIiwicmVzcG9uc2VTdHJlYW0iLCJvcHRpb25zIiwiY29tbWVudCIsInBhcnNlZE9wdGlvbnMiLCJpc09iamVjdCIsInVuZGVmaW5lZCIsImlzU3RyaW5nIiwiVHlwZUVycm9yIiwiY2FsbCIsInJlc29sdmVkUmVxdWVzdFR5cGUiLCJyZXNvbHZlZFJlc3BvbnNlVHlwZSIsImZyb21KU09OIiwianNvbiIsInRvSlNPTiIsInRvSlNPTk9wdGlvbnMiLCJrZWVwQ29tbWVudHMiLCJCb29sZWFuIiwidG9PYmplY3QiLCJyZXNvbHZlIiwicmVzb2x2ZWQiLCJwYXJlbnQiLCJsb29rdXBUeXBlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/protobufjs/src/method.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/src/namespace.js":
/*!***************************************************!*\
  !*** ../node_modules/protobufjs/src/namespace.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = Namespace;\n// extends ReflectionObject\nvar ReflectionObject = __webpack_require__(/*! ./object */ \"(ssr)/../node_modules/protobufjs/src/object.js\");\n((Namespace.prototype = Object.create(ReflectionObject.prototype)).constructor = Namespace).className = \"Namespace\";\nvar Field = __webpack_require__(/*! ./field */ \"(ssr)/../node_modules/protobufjs/src/field.js\"), util = __webpack_require__(/*! ./util */ \"(ssr)/../node_modules/protobufjs/src/util.js\"), OneOf = __webpack_require__(/*! ./oneof */ \"(ssr)/../node_modules/protobufjs/src/oneof.js\");\nvar Type, Service, Enum;\n/**\n * Constructs a new namespace instance.\n * @name Namespace\n * @classdesc Reflected namespace.\n * @extends NamespaceBase\n * @constructor\n * @param {string} name Namespace name\n * @param {Object.<string,*>} [options] Declared options\n */ /**\n * Constructs a namespace from JSON.\n * @memberof Namespace\n * @function\n * @param {string} name Namespace name\n * @param {Object.<string,*>} json JSON object\n * @returns {Namespace} Created namespace\n * @throws {TypeError} If arguments are invalid\n */ Namespace.fromJSON = function fromJSON(name, json) {\n    return new Namespace(name, json.options).addJSON(json.nested);\n};\n/**\n * Converts an array of reflection objects to JSON.\n * @memberof Namespace\n * @param {ReflectionObject[]} array Object array\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {Object.<string,*>|undefined} JSON object or `undefined` when array is empty\n */ function arrayToJSON(array, toJSONOptions) {\n    if (!(array && array.length)) return undefined;\n    var obj = {};\n    for(var i = 0; i < array.length; ++i)obj[array[i].name] = array[i].toJSON(toJSONOptions);\n    return obj;\n}\nNamespace.arrayToJSON = arrayToJSON;\n/**\n * Tests if the specified id is reserved.\n * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names\n * @param {number} id Id to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */ Namespace.isReservedId = function isReservedId(reserved, id) {\n    if (reserved) {\n        for(var i = 0; i < reserved.length; ++i)if (typeof reserved[i] !== \"string\" && reserved[i][0] <= id && reserved[i][1] > id) return true;\n    }\n    return false;\n};\n/**\n * Tests if the specified name is reserved.\n * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names\n * @param {string} name Name to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */ Namespace.isReservedName = function isReservedName(reserved, name) {\n    if (reserved) {\n        for(var i = 0; i < reserved.length; ++i)if (reserved[i] === name) return true;\n    }\n    return false;\n};\n/**\n * Not an actual constructor. Use {@link Namespace} instead.\n * @classdesc Base class of all reflection objects containing nested objects. This is not an actual class but here for the sake of having consistent type definitions.\n * @exports NamespaceBase\n * @extends ReflectionObject\n * @abstract\n * @constructor\n * @param {string} name Namespace name\n * @param {Object.<string,*>} [options] Declared options\n * @see {@link Namespace}\n */ function Namespace(name, options) {\n    ReflectionObject.call(this, name, options);\n    /**\n     * Nested objects by name.\n     * @type {Object.<string,ReflectionObject>|undefined}\n     */ this.nested = undefined; // toJSON\n    /**\n     * Cached nested objects as an array.\n     * @type {ReflectionObject[]|null}\n     * @private\n     */ this._nestedArray = null;\n}\nfunction clearCache(namespace) {\n    namespace._nestedArray = null;\n    return namespace;\n}\n/**\n * Nested objects of this namespace as an array for iteration.\n * @name NamespaceBase#nestedArray\n * @type {ReflectionObject[]}\n * @readonly\n */ Object.defineProperty(Namespace.prototype, \"nestedArray\", {\n    get: function() {\n        return this._nestedArray || (this._nestedArray = util.toArray(this.nested));\n    }\n});\n/**\n * Namespace descriptor.\n * @interface INamespace\n * @property {Object.<string,*>} [options] Namespace options\n * @property {Object.<string,AnyNestedObject>} [nested] Nested object descriptors\n */ /**\n * Any extension field descriptor.\n * @typedef AnyExtensionField\n * @type {IExtensionField|IExtensionMapField}\n */ /**\n * Any nested object descriptor.\n * @typedef AnyNestedObject\n * @type {IEnum|IType|IService|AnyExtensionField|INamespace|IOneOf}\n */ /**\n * Converts this namespace to a namespace descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {INamespace} Namespace descriptor\n */ Namespace.prototype.toJSON = function toJSON(toJSONOptions) {\n    return util.toObject([\n        \"options\",\n        this.options,\n        \"nested\",\n        arrayToJSON(this.nestedArray, toJSONOptions)\n    ]);\n};\n/**\n * Adds nested objects to this namespace from nested object descriptors.\n * @param {Object.<string,AnyNestedObject>} nestedJson Any nested object descriptors\n * @returns {Namespace} `this`\n */ Namespace.prototype.addJSON = function addJSON(nestedJson) {\n    var ns = this;\n    /* istanbul ignore else */ if (nestedJson) {\n        for(var names = Object.keys(nestedJson), i = 0, nested; i < names.length; ++i){\n            nested = nestedJson[names[i]];\n            ns.add((nested.fields !== undefined ? Type.fromJSON : nested.values !== undefined ? Enum.fromJSON : nested.methods !== undefined ? Service.fromJSON : nested.id !== undefined ? Field.fromJSON : Namespace.fromJSON)(names[i], nested));\n        }\n    }\n    return this;\n};\n/**\n * Gets the nested object of the specified name.\n * @param {string} name Nested object name\n * @returns {ReflectionObject|null} The reflection object or `null` if it doesn't exist\n */ Namespace.prototype.get = function get(name) {\n    return this.nested && this.nested[name] || null;\n};\n/**\n * Gets the values of the nested {@link Enum|enum} of the specified name.\n * This methods differs from {@link Namespace#get|get} in that it returns an enum's values directly and throws instead of returning `null`.\n * @param {string} name Nested enum name\n * @returns {Object.<string,number>} Enum values\n * @throws {Error} If there is no such enum\n */ Namespace.prototype.getEnum = function getEnum(name) {\n    if (this.nested && this.nested[name] instanceof Enum) return this.nested[name].values;\n    throw Error(\"no such enum: \" + name);\n};\n/**\n * Adds a nested object to this namespace.\n * @param {ReflectionObject} object Nested object to add\n * @returns {Namespace} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If there is already a nested object with this name\n */ Namespace.prototype.add = function add(object) {\n    if (!(object instanceof Field && object.extend !== undefined || object instanceof Type || object instanceof OneOf || object instanceof Enum || object instanceof Service || object instanceof Namespace)) throw TypeError(\"object must be a valid nested object\");\n    if (!this.nested) this.nested = {};\n    else {\n        var prev = this.get(object.name);\n        if (prev) {\n            if (prev instanceof Namespace && object instanceof Namespace && !(prev instanceof Type || prev instanceof Service)) {\n                // replace plain namespace but keep existing nested elements and options\n                var nested = prev.nestedArray;\n                for(var i = 0; i < nested.length; ++i)object.add(nested[i]);\n                this.remove(prev);\n                if (!this.nested) this.nested = {};\n                object.setOptions(prev.options, true);\n            } else throw Error(\"duplicate name '\" + object.name + \"' in \" + this);\n        }\n    }\n    this.nested[object.name] = object;\n    object.onAdd(this);\n    return clearCache(this);\n};\n/**\n * Removes a nested object from this namespace.\n * @param {ReflectionObject} object Nested object to remove\n * @returns {Namespace} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If `object` is not a member of this namespace\n */ Namespace.prototype.remove = function remove(object) {\n    if (!(object instanceof ReflectionObject)) throw TypeError(\"object must be a ReflectionObject\");\n    if (object.parent !== this) throw Error(object + \" is not a member of \" + this);\n    delete this.nested[object.name];\n    if (!Object.keys(this.nested).length) this.nested = undefined;\n    object.onRemove(this);\n    return clearCache(this);\n};\n/**\n * Defines additial namespaces within this one if not yet existing.\n * @param {string|string[]} path Path to create\n * @param {*} [json] Nested types to create from JSON\n * @returns {Namespace} Pointer to the last namespace created or `this` if path is empty\n */ Namespace.prototype.define = function define(path, json) {\n    if (util.isString(path)) path = path.split(\".\");\n    else if (!Array.isArray(path)) throw TypeError(\"illegal path\");\n    if (path && path.length && path[0] === \"\") throw Error(\"path must be relative\");\n    var ptr = this;\n    while(path.length > 0){\n        var part = path.shift();\n        if (ptr.nested && ptr.nested[part]) {\n            ptr = ptr.nested[part];\n            if (!(ptr instanceof Namespace)) throw Error(\"path conflicts with non-namespace objects\");\n        } else ptr.add(ptr = new Namespace(part));\n    }\n    if (json) ptr.addJSON(json);\n    return ptr;\n};\n/**\n * Resolves this namespace's and all its nested objects' type references. Useful to validate a reflection tree, but comes at a cost.\n * @returns {Namespace} `this`\n */ Namespace.prototype.resolveAll = function resolveAll() {\n    var nested = this.nestedArray, i = 0;\n    while(i < nested.length)if (nested[i] instanceof Namespace) nested[i++].resolveAll();\n    else nested[i++].resolve();\n    return this.resolve();\n};\n/**\n * Recursively looks up the reflection object matching the specified path in the scope of this namespace.\n * @param {string|string[]} path Path to look up\n * @param {*|Array.<*>} filterTypes Filter types, any combination of the constructors of `protobuf.Type`, `protobuf.Enum`, `protobuf.Service` etc.\n * @param {boolean} [parentAlreadyChecked=false] If known, whether the parent has already been checked\n * @returns {ReflectionObject|null} Looked up object or `null` if none could be found\n */ Namespace.prototype.lookup = function lookup(path, filterTypes, parentAlreadyChecked) {\n    /* istanbul ignore next */ if (typeof filterTypes === \"boolean\") {\n        parentAlreadyChecked = filterTypes;\n        filterTypes = undefined;\n    } else if (filterTypes && !Array.isArray(filterTypes)) filterTypes = [\n        filterTypes\n    ];\n    if (util.isString(path) && path.length) {\n        if (path === \".\") return this.root;\n        path = path.split(\".\");\n    } else if (!path.length) return this;\n    // Start at root if path is absolute\n    if (path[0] === \"\") return this.root.lookup(path.slice(1), filterTypes);\n    // Test if the first part matches any nested object, and if so, traverse if path contains more\n    var found = this.get(path[0]);\n    if (found) {\n        if (path.length === 1) {\n            if (!filterTypes || filterTypes.indexOf(found.constructor) > -1) return found;\n        } else if (found instanceof Namespace && (found = found.lookup(path.slice(1), filterTypes, true))) return found;\n    // Otherwise try each nested namespace\n    } else for(var i = 0; i < this.nestedArray.length; ++i)if (this._nestedArray[i] instanceof Namespace && (found = this._nestedArray[i].lookup(path, filterTypes, true))) return found;\n    // If there hasn't been a match, try again at the parent\n    if (this.parent === null || parentAlreadyChecked) return null;\n    return this.parent.lookup(path, filterTypes);\n};\n/**\n * Looks up the reflection object at the specified path, relative to this namespace.\n * @name NamespaceBase#lookup\n * @function\n * @param {string|string[]} path Path to look up\n * @param {boolean} [parentAlreadyChecked=false] Whether the parent has already been checked\n * @returns {ReflectionObject|null} Looked up object or `null` if none could be found\n * @variation 2\n */ // lookup(path: string, [parentAlreadyChecked: boolean])\n/**\n * Looks up the {@link Type|type} at the specified path, relative to this namespace.\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\n * @param {string|string[]} path Path to look up\n * @returns {Type} Looked up type\n * @throws {Error} If `path` does not point to a type\n */ Namespace.prototype.lookupType = function lookupType(path) {\n    var found = this.lookup(path, [\n        Type\n    ]);\n    if (!found) throw Error(\"no such type: \" + path);\n    return found;\n};\n/**\n * Looks up the values of the {@link Enum|enum} at the specified path, relative to this namespace.\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\n * @param {string|string[]} path Path to look up\n * @returns {Enum} Looked up enum\n * @throws {Error} If `path` does not point to an enum\n */ Namespace.prototype.lookupEnum = function lookupEnum(path) {\n    var found = this.lookup(path, [\n        Enum\n    ]);\n    if (!found) throw Error(\"no such Enum '\" + path + \"' in \" + this);\n    return found;\n};\n/**\n * Looks up the {@link Type|type} or {@link Enum|enum} at the specified path, relative to this namespace.\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\n * @param {string|string[]} path Path to look up\n * @returns {Type} Looked up type or enum\n * @throws {Error} If `path` does not point to a type or enum\n */ Namespace.prototype.lookupTypeOrEnum = function lookupTypeOrEnum(path) {\n    var found = this.lookup(path, [\n        Type,\n        Enum\n    ]);\n    if (!found) throw Error(\"no such Type or Enum '\" + path + \"' in \" + this);\n    return found;\n};\n/**\n * Looks up the {@link Service|service} at the specified path, relative to this namespace.\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\n * @param {string|string[]} path Path to look up\n * @returns {Service} Looked up service\n * @throws {Error} If `path` does not point to a service\n */ Namespace.prototype.lookupService = function lookupService(path) {\n    var found = this.lookup(path, [\n        Service\n    ]);\n    if (!found) throw Error(\"no such Service '\" + path + \"' in \" + this);\n    return found;\n};\n// Sets up cyclic dependencies (called in index-light)\nNamespace._configure = function(Type_, Service_, Enum_) {\n    Type = Type_;\n    Service = Service_;\n    Enum = Enum_;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL25hbWVzcGFjZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSxPQUFPQyxPQUFPLEdBQUdDO0FBRWpCLDJCQUEyQjtBQUMzQixJQUFJQyxtQkFBbUJDLG1CQUFPQSxDQUFDLGdFQUFVO0FBQ3hDLEVBQUNGLFVBQVVHLFNBQVMsR0FBR0MsT0FBT0MsTUFBTSxDQUFDSixpQkFBaUJFLFNBQVMsR0FBR0csV0FBVyxHQUFHTixTQUFRLEVBQUdPLFNBQVMsR0FBRztBQUV4RyxJQUFJQyxRQUFXTixtQkFBT0EsQ0FBQyw4REFBUyxHQUM1Qk8sT0FBV1AsbUJBQU9BLENBQUMsNERBQVEsR0FDM0JRLFFBQVdSLG1CQUFPQSxDQUFDLDhEQUFTO0FBRWhDLElBQUlTLE1BQ0FDLFNBQ0FDO0FBRUo7Ozs7Ozs7O0NBUUMsR0FFRDs7Ozs7Ozs7Q0FRQyxHQUNEYixVQUFVYyxRQUFRLEdBQUcsU0FBU0EsU0FBU0MsSUFBSSxFQUFFQyxJQUFJO0lBQzdDLE9BQU8sSUFBSWhCLFVBQVVlLE1BQU1DLEtBQUtDLE9BQU8sRUFBRUMsT0FBTyxDQUFDRixLQUFLRyxNQUFNO0FBQ2hFO0FBRUE7Ozs7OztDQU1DLEdBQ0QsU0FBU0MsWUFBWUMsS0FBSyxFQUFFQyxhQUFhO0lBQ3JDLElBQUksQ0FBRUQsQ0FBQUEsU0FBU0EsTUFBTUUsTUFBTSxHQUN2QixPQUFPQztJQUNYLElBQUlDLE1BQU0sQ0FBQztJQUNYLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJTCxNQUFNRSxNQUFNLEVBQUUsRUFBRUcsRUFDaENELEdBQUcsQ0FBQ0osS0FBSyxDQUFDSyxFQUFFLENBQUNYLElBQUksQ0FBQyxHQUFHTSxLQUFLLENBQUNLLEVBQUUsQ0FBQ0MsTUFBTSxDQUFDTDtJQUN6QyxPQUFPRztBQUNYO0FBRUF6QixVQUFVb0IsV0FBVyxHQUFHQTtBQUV4Qjs7Ozs7Q0FLQyxHQUNEcEIsVUFBVTRCLFlBQVksR0FBRyxTQUFTQSxhQUFhQyxR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YnVmanMvc3JjL25hbWVzcGFjZS5qcz80MjA4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBOYW1lc3BhY2U7XG5cbi8vIGV4dGVuZHMgUmVmbGVjdGlvbk9iamVjdFxudmFyIFJlZmxlY3Rpb25PYmplY3QgPSByZXF1aXJlKFwiLi9vYmplY3RcIik7XG4oKE5hbWVzcGFjZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFJlZmxlY3Rpb25PYmplY3QucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBOYW1lc3BhY2UpLmNsYXNzTmFtZSA9IFwiTmFtZXNwYWNlXCI7XG5cbnZhciBGaWVsZCAgICA9IHJlcXVpcmUoXCIuL2ZpZWxkXCIpLFxuICAgIHV0aWwgICAgID0gcmVxdWlyZShcIi4vdXRpbFwiKSxcbiAgICBPbmVPZiAgICA9IHJlcXVpcmUoXCIuL29uZW9mXCIpO1xuXG52YXIgVHlwZSwgICAgLy8gY3ljbGljXG4gICAgU2VydmljZSxcbiAgICBFbnVtO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgbmFtZXNwYWNlIGluc3RhbmNlLlxuICogQG5hbWUgTmFtZXNwYWNlXG4gKiBAY2xhc3NkZXNjIFJlZmxlY3RlZCBuYW1lc3BhY2UuXG4gKiBAZXh0ZW5kcyBOYW1lc3BhY2VCYXNlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWVzcGFjZSBuYW1lXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBbb3B0aW9uc10gRGVjbGFyZWQgb3B0aW9uc1xuICovXG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5hbWVzcGFjZSBmcm9tIEpTT04uXG4gKiBAbWVtYmVyb2YgTmFtZXNwYWNlXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWVzcGFjZSBuYW1lXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBqc29uIEpTT04gb2JqZWN0XG4gKiBAcmV0dXJucyB7TmFtZXNwYWNlfSBDcmVhdGVkIG5hbWVzcGFjZVxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBhcmd1bWVudHMgYXJlIGludmFsaWRcbiAqL1xuTmFtZXNwYWNlLmZyb21KU09OID0gZnVuY3Rpb24gZnJvbUpTT04obmFtZSwganNvbikge1xuICAgIHJldHVybiBuZXcgTmFtZXNwYWNlKG5hbWUsIGpzb24ub3B0aW9ucykuYWRkSlNPTihqc29uLm5lc3RlZCk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIGFycmF5IG9mIHJlZmxlY3Rpb24gb2JqZWN0cyB0byBKU09OLlxuICogQG1lbWJlcm9mIE5hbWVzcGFjZVxuICogQHBhcmFtIHtSZWZsZWN0aW9uT2JqZWN0W119IGFycmF5IE9iamVjdCBhcnJheVxuICogQHBhcmFtIHtJVG9KU09OT3B0aW9uc30gW3RvSlNPTk9wdGlvbnNdIEpTT04gY29udmVyc2lvbiBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj58dW5kZWZpbmVkfSBKU09OIG9iamVjdCBvciBgdW5kZWZpbmVkYCB3aGVuIGFycmF5IGlzIGVtcHR5XG4gKi9cbmZ1bmN0aW9uIGFycmF5VG9KU09OKGFycmF5LCB0b0pTT05PcHRpb25zKSB7XG4gICAgaWYgKCEoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSlcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB2YXIgb2JqID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7ICsraSlcbiAgICAgICAgb2JqW2FycmF5W2ldLm5hbWVdID0gYXJyYXlbaV0udG9KU09OKHRvSlNPTk9wdGlvbnMpO1xuICAgIHJldHVybiBvYmo7XG59XG5cbk5hbWVzcGFjZS5hcnJheVRvSlNPTiA9IGFycmF5VG9KU09OO1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoZSBzcGVjaWZpZWQgaWQgaXMgcmVzZXJ2ZWQuXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXJbXXxzdHJpbmc+fHVuZGVmaW5lZH0gcmVzZXJ2ZWQgQXJyYXkgb2YgcmVzZXJ2ZWQgcmFuZ2VzIGFuZCBuYW1lc1xuICogQHBhcmFtIHtudW1iZXJ9IGlkIElkIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgcmVzZXJ2ZWQsIG90aGVyd2lzZSBgZmFsc2VgXG4gKi9cbk5hbWVzcGFjZS5pc1Jlc2VydmVkSWQgPSBmdW5jdGlvbiBpc1Jlc2VydmVkSWQocmVzZXJ2ZWQsIGlkKSB7XG4gICAgaWYgKHJlc2VydmVkKVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc2VydmVkLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgaWYgKHR5cGVvZiByZXNlcnZlZFtpXSAhPT0gXCJzdHJpbmdcIiAmJiByZXNlcnZlZFtpXVswXSA8PSBpZCAmJiByZXNlcnZlZFtpXVsxXSA+IGlkKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCBuYW1lIGlzIHJlc2VydmVkLlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyW118c3RyaW5nPnx1bmRlZmluZWR9IHJlc2VydmVkIEFycmF5IG9mIHJlc2VydmVkIHJhbmdlcyBhbmQgbmFtZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiByZXNlcnZlZCwgb3RoZXJ3aXNlIGBmYWxzZWBcbiAqL1xuTmFtZXNwYWNlLmlzUmVzZXJ2ZWROYW1lID0gZnVuY3Rpb24gaXNSZXNlcnZlZE5hbWUocmVzZXJ2ZWQsIG5hbWUpIHtcbiAgICBpZiAocmVzZXJ2ZWQpXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzZXJ2ZWQubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICBpZiAocmVzZXJ2ZWRbaV0gPT09IG5hbWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBOb3QgYW4gYWN0dWFsIGNvbnN0cnVjdG9yLiBVc2Uge0BsaW5rIE5hbWVzcGFjZX0gaW5zdGVhZC5cbiAqIEBjbGFzc2Rlc2MgQmFzZSBjbGFzcyBvZiBhbGwgcmVmbGVjdGlvbiBvYmplY3RzIGNvbnRhaW5pbmcgbmVzdGVkIG9iamVjdHMuIFRoaXMgaXMgbm90IGFuIGFjdHVhbCBjbGFzcyBidXQgaGVyZSBmb3IgdGhlIHNha2Ugb2YgaGF2aW5nIGNvbnNpc3RlbnQgdHlwZSBkZWZpbml0aW9ucy5cbiAqIEBleHBvcnRzIE5hbWVzcGFjZUJhc2VcbiAqIEBleHRlbmRzIFJlZmxlY3Rpb25PYmplY3RcbiAqIEBhYnN0cmFjdFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lc3BhY2UgbmFtZVxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gW29wdGlvbnNdIERlY2xhcmVkIG9wdGlvbnNcbiAqIEBzZWUge0BsaW5rIE5hbWVzcGFjZX1cbiAqL1xuZnVuY3Rpb24gTmFtZXNwYWNlKG5hbWUsIG9wdGlvbnMpIHtcbiAgICBSZWZsZWN0aW9uT2JqZWN0LmNhbGwodGhpcywgbmFtZSwgb3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBOZXN0ZWQgb2JqZWN0cyBieSBuYW1lLlxuICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZyxSZWZsZWN0aW9uT2JqZWN0Pnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5uZXN0ZWQgPSB1bmRlZmluZWQ7IC8vIHRvSlNPTlxuXG4gICAgLyoqXG4gICAgICogQ2FjaGVkIG5lc3RlZCBvYmplY3RzIGFzIGFuIGFycmF5LlxuICAgICAqIEB0eXBlIHtSZWZsZWN0aW9uT2JqZWN0W118bnVsbH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX25lc3RlZEFycmF5ID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gY2xlYXJDYWNoZShuYW1lc3BhY2UpIHtcbiAgICBuYW1lc3BhY2UuX25lc3RlZEFycmF5ID0gbnVsbDtcbiAgICByZXR1cm4gbmFtZXNwYWNlO1xufVxuXG4vKipcbiAqIE5lc3RlZCBvYmplY3RzIG9mIHRoaXMgbmFtZXNwYWNlIGFzIGFuIGFycmF5IGZvciBpdGVyYXRpb24uXG4gKiBAbmFtZSBOYW1lc3BhY2VCYXNlI25lc3RlZEFycmF5XG4gKiBAdHlwZSB7UmVmbGVjdGlvbk9iamVjdFtdfVxuICogQHJlYWRvbmx5XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShOYW1lc3BhY2UucHJvdG90eXBlLCBcIm5lc3RlZEFycmF5XCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmVzdGVkQXJyYXkgfHwgKHRoaXMuX25lc3RlZEFycmF5ID0gdXRpbC50b0FycmF5KHRoaXMubmVzdGVkKSk7XG4gICAgfVxufSk7XG5cbi8qKlxuICogTmFtZXNwYWNlIGRlc2NyaXB0b3IuXG4gKiBAaW50ZXJmYWNlIElOYW1lc3BhY2VcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsKj59IFtvcHRpb25zXSBOYW1lc3BhY2Ugb3B0aW9uc1xuICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZyxBbnlOZXN0ZWRPYmplY3Q+fSBbbmVzdGVkXSBOZXN0ZWQgb2JqZWN0IGRlc2NyaXB0b3JzXG4gKi9cblxuLyoqXG4gKiBBbnkgZXh0ZW5zaW9uIGZpZWxkIGRlc2NyaXB0b3IuXG4gKiBAdHlwZWRlZiBBbnlFeHRlbnNpb25GaWVsZFxuICogQHR5cGUge0lFeHRlbnNpb25GaWVsZHxJRXh0ZW5zaW9uTWFwRmllbGR9XG4gKi9cblxuLyoqXG4gKiBBbnkgbmVzdGVkIG9iamVjdCBkZXNjcmlwdG9yLlxuICogQHR5cGVkZWYgQW55TmVzdGVkT2JqZWN0XG4gKiBAdHlwZSB7SUVudW18SVR5cGV8SVNlcnZpY2V8QW55RXh0ZW5zaW9uRmllbGR8SU5hbWVzcGFjZXxJT25lT2Z9XG4gKi9cblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIG5hbWVzcGFjZSB0byBhIG5hbWVzcGFjZSBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtJVG9KU09OT3B0aW9uc30gW3RvSlNPTk9wdGlvbnNdIEpTT04gY29udmVyc2lvbiBvcHRpb25zXG4gKiBAcmV0dXJucyB7SU5hbWVzcGFjZX0gTmFtZXNwYWNlIGRlc2NyaXB0b3JcbiAqL1xuTmFtZXNwYWNlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04odG9KU09OT3B0aW9ucykge1xuICAgIHJldHVybiB1dGlsLnRvT2JqZWN0KFtcbiAgICAgICAgXCJvcHRpb25zXCIgLCB0aGlzLm9wdGlvbnMsXG4gICAgICAgIFwibmVzdGVkXCIgICwgYXJyYXlUb0pTT04odGhpcy5uZXN0ZWRBcnJheSwgdG9KU09OT3B0aW9ucylcbiAgICBdKTtcbn07XG5cbi8qKlxuICogQWRkcyBuZXN0ZWQgb2JqZWN0cyB0byB0aGlzIG5hbWVzcGFjZSBmcm9tIG5lc3RlZCBvYmplY3QgZGVzY3JpcHRvcnMuXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLEFueU5lc3RlZE9iamVjdD59IG5lc3RlZEpzb24gQW55IG5lc3RlZCBvYmplY3QgZGVzY3JpcHRvcnNcbiAqIEByZXR1cm5zIHtOYW1lc3BhY2V9IGB0aGlzYFxuICovXG5OYW1lc3BhY2UucHJvdG90eXBlLmFkZEpTT04gPSBmdW5jdGlvbiBhZGRKU09OKG5lc3RlZEpzb24pIHtcbiAgICB2YXIgbnMgPSB0aGlzO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKG5lc3RlZEpzb24pIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZXMgPSBPYmplY3Qua2V5cyhuZXN0ZWRKc29uKSwgaSA9IDAsIG5lc3RlZDsgaSA8IG5hbWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBuZXN0ZWQgPSBuZXN0ZWRKc29uW25hbWVzW2ldXTtcbiAgICAgICAgICAgIG5zLmFkZCggLy8gbW9zdCB0byBsZWFzdCBsaWtlbHlcbiAgICAgICAgICAgICAgICAoIG5lc3RlZC5maWVsZHMgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gVHlwZS5mcm9tSlNPTlxuICAgICAgICAgICAgICAgIDogbmVzdGVkLnZhbHVlcyAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBFbnVtLmZyb21KU09OXG4gICAgICAgICAgICAgICAgOiBuZXN0ZWQubWV0aG9kcyAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBTZXJ2aWNlLmZyb21KU09OXG4gICAgICAgICAgICAgICAgOiBuZXN0ZWQuaWQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gRmllbGQuZnJvbUpTT05cbiAgICAgICAgICAgICAgICA6IE5hbWVzcGFjZS5mcm9tSlNPTiApKG5hbWVzW2ldLCBuZXN0ZWQpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBuZXN0ZWQgb2JqZWN0IG9mIHRoZSBzcGVjaWZpZWQgbmFtZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5lc3RlZCBvYmplY3QgbmFtZVxuICogQHJldHVybnMge1JlZmxlY3Rpb25PYmplY3R8bnVsbH0gVGhlIHJlZmxlY3Rpb24gb2JqZWN0IG9yIGBudWxsYCBpZiBpdCBkb2Vzbid0IGV4aXN0XG4gKi9cbk5hbWVzcGFjZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0KG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5uZXN0ZWQgJiYgdGhpcy5uZXN0ZWRbbmFtZV1cbiAgICAgICAgfHwgbnVsbDtcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWVzIG9mIHRoZSBuZXN0ZWQge0BsaW5rIEVudW18ZW51bX0gb2YgdGhlIHNwZWNpZmllZCBuYW1lLlxuICogVGhpcyBtZXRob2RzIGRpZmZlcnMgZnJvbSB7QGxpbmsgTmFtZXNwYWNlI2dldHxnZXR9IGluIHRoYXQgaXQgcmV0dXJucyBhbiBlbnVtJ3MgdmFsdWVzIGRpcmVjdGx5IGFuZCB0aHJvd3MgaW5zdGVhZCBvZiByZXR1cm5pbmcgYG51bGxgLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmVzdGVkIGVudW0gbmFtZVxuICogQHJldHVybnMge09iamVjdC48c3RyaW5nLG51bWJlcj59IEVudW0gdmFsdWVzXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlcmUgaXMgbm8gc3VjaCBlbnVtXG4gKi9cbk5hbWVzcGFjZS5wcm90b3R5cGUuZ2V0RW51bSA9IGZ1bmN0aW9uIGdldEVudW0obmFtZSkge1xuICAgIGlmICh0aGlzLm5lc3RlZCAmJiB0aGlzLm5lc3RlZFtuYW1lXSBpbnN0YW5jZW9mIEVudW0pXG4gICAgICAgIHJldHVybiB0aGlzLm5lc3RlZFtuYW1lXS52YWx1ZXM7XG4gICAgdGhyb3cgRXJyb3IoXCJubyBzdWNoIGVudW06IFwiICsgbmFtZSk7XG59O1xuXG4vKipcbiAqIEFkZHMgYSBuZXN0ZWQgb2JqZWN0IHRvIHRoaXMgbmFtZXNwYWNlLlxuICogQHBhcmFtIHtSZWZsZWN0aW9uT2JqZWN0fSBvYmplY3QgTmVzdGVkIG9iamVjdCB0byBhZGRcbiAqIEByZXR1cm5zIHtOYW1lc3BhY2V9IGB0aGlzYFxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBhcmd1bWVudHMgYXJlIGludmFsaWRcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGVyZSBpcyBhbHJlYWR5IGEgbmVzdGVkIG9iamVjdCB3aXRoIHRoaXMgbmFtZVxuICovXG5OYW1lc3BhY2UucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChvYmplY3QpIHtcblxuICAgIGlmICghKG9iamVjdCBpbnN0YW5jZW9mIEZpZWxkICYmIG9iamVjdC5leHRlbmQgIT09IHVuZGVmaW5lZCB8fCBvYmplY3QgaW5zdGFuY2VvZiBUeXBlICB8fCBvYmplY3QgaW5zdGFuY2VvZiBPbmVPZiB8fCBvYmplY3QgaW5zdGFuY2VvZiBFbnVtIHx8IG9iamVjdCBpbnN0YW5jZW9mIFNlcnZpY2UgfHwgb2JqZWN0IGluc3RhbmNlb2YgTmFtZXNwYWNlKSlcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwib2JqZWN0IG11c3QgYmUgYSB2YWxpZCBuZXN0ZWQgb2JqZWN0XCIpO1xuXG4gICAgaWYgKCF0aGlzLm5lc3RlZClcbiAgICAgICAgdGhpcy5uZXN0ZWQgPSB7fTtcbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIHByZXYgPSB0aGlzLmdldChvYmplY3QubmFtZSk7XG4gICAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgICAgICBpZiAocHJldiBpbnN0YW5jZW9mIE5hbWVzcGFjZSAmJiBvYmplY3QgaW5zdGFuY2VvZiBOYW1lc3BhY2UgJiYgIShwcmV2IGluc3RhbmNlb2YgVHlwZSB8fCBwcmV2IGluc3RhbmNlb2YgU2VydmljZSkpIHtcbiAgICAgICAgICAgICAgICAvLyByZXBsYWNlIHBsYWluIG5hbWVzcGFjZSBidXQga2VlcCBleGlzdGluZyBuZXN0ZWQgZWxlbWVudHMgYW5kIG9wdGlvbnNcbiAgICAgICAgICAgICAgICB2YXIgbmVzdGVkID0gcHJldi5uZXN0ZWRBcnJheTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5lc3RlZC5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmFkZChuZXN0ZWRbaV0pO1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlKHByZXYpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5uZXN0ZWQpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmVzdGVkID0ge307XG4gICAgICAgICAgICAgICAgb2JqZWN0LnNldE9wdGlvbnMocHJldi5vcHRpb25zLCB0cnVlKTtcblxuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJkdXBsaWNhdGUgbmFtZSAnXCIgKyBvYmplY3QubmFtZSArIFwiJyBpbiBcIiArIHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMubmVzdGVkW29iamVjdC5uYW1lXSA9IG9iamVjdDtcbiAgICBvYmplY3Qub25BZGQodGhpcyk7XG4gICAgcmV0dXJuIGNsZWFyQ2FjaGUodGhpcyk7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYSBuZXN0ZWQgb2JqZWN0IGZyb20gdGhpcyBuYW1lc3BhY2UuXG4gKiBAcGFyYW0ge1JlZmxlY3Rpb25PYmplY3R9IG9iamVjdCBOZXN0ZWQgb2JqZWN0IHRvIHJlbW92ZVxuICogQHJldHVybnMge05hbWVzcGFjZX0gYHRoaXNgXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGFyZ3VtZW50cyBhcmUgaW52YWxpZFxuICogQHRocm93cyB7RXJyb3J9IElmIGBvYmplY3RgIGlzIG5vdCBhIG1lbWJlciBvZiB0aGlzIG5hbWVzcGFjZVxuICovXG5OYW1lc3BhY2UucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShvYmplY3QpIHtcblxuICAgIGlmICghKG9iamVjdCBpbnN0YW5jZW9mIFJlZmxlY3Rpb25PYmplY3QpKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJvYmplY3QgbXVzdCBiZSBhIFJlZmxlY3Rpb25PYmplY3RcIik7XG4gICAgaWYgKG9iamVjdC5wYXJlbnQgIT09IHRoaXMpXG4gICAgICAgIHRocm93IEVycm9yKG9iamVjdCArIFwiIGlzIG5vdCBhIG1lbWJlciBvZiBcIiArIHRoaXMpO1xuXG4gICAgZGVsZXRlIHRoaXMubmVzdGVkW29iamVjdC5uYW1lXTtcbiAgICBpZiAoIU9iamVjdC5rZXlzKHRoaXMubmVzdGVkKS5sZW5ndGgpXG4gICAgICAgIHRoaXMubmVzdGVkID0gdW5kZWZpbmVkO1xuXG4gICAgb2JqZWN0Lm9uUmVtb3ZlKHRoaXMpO1xuICAgIHJldHVybiBjbGVhckNhY2hlKHRoaXMpO1xufTtcblxuLyoqXG4gKiBEZWZpbmVzIGFkZGl0aWFsIG5hbWVzcGFjZXMgd2l0aGluIHRoaXMgb25lIGlmIG5vdCB5ZXQgZXhpc3RpbmcuXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gcGF0aCBQYXRoIHRvIGNyZWF0ZVxuICogQHBhcmFtIHsqfSBbanNvbl0gTmVzdGVkIHR5cGVzIHRvIGNyZWF0ZSBmcm9tIEpTT05cbiAqIEByZXR1cm5zIHtOYW1lc3BhY2V9IFBvaW50ZXIgdG8gdGhlIGxhc3QgbmFtZXNwYWNlIGNyZWF0ZWQgb3IgYHRoaXNgIGlmIHBhdGggaXMgZW1wdHlcbiAqL1xuTmFtZXNwYWNlLnByb3RvdHlwZS5kZWZpbmUgPSBmdW5jdGlvbiBkZWZpbmUocGF0aCwganNvbikge1xuXG4gICAgaWYgKHV0aWwuaXNTdHJpbmcocGF0aCkpXG4gICAgICAgIHBhdGggPSBwYXRoLnNwbGl0KFwiLlwiKTtcbiAgICBlbHNlIGlmICghQXJyYXkuaXNBcnJheShwYXRoKSlcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiaWxsZWdhbCBwYXRoXCIpO1xuICAgIGlmIChwYXRoICYmIHBhdGgubGVuZ3RoICYmIHBhdGhbMF0gPT09IFwiXCIpXG4gICAgICAgIHRocm93IEVycm9yKFwicGF0aCBtdXN0IGJlIHJlbGF0aXZlXCIpO1xuXG4gICAgdmFyIHB0ciA9IHRoaXM7XG4gICAgd2hpbGUgKHBhdGgubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgcGFydCA9IHBhdGguc2hpZnQoKTtcbiAgICAgICAgaWYgKHB0ci5uZXN0ZWQgJiYgcHRyLm5lc3RlZFtwYXJ0XSkge1xuICAgICAgICAgICAgcHRyID0gcHRyLm5lc3RlZFtwYXJ0XTtcbiAgICAgICAgICAgIGlmICghKHB0ciBpbnN0YW5jZW9mIE5hbWVzcGFjZSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJwYXRoIGNvbmZsaWN0cyB3aXRoIG5vbi1uYW1lc3BhY2Ugb2JqZWN0c1wiKTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICBwdHIuYWRkKHB0ciA9IG5ldyBOYW1lc3BhY2UocGFydCkpO1xuICAgIH1cbiAgICBpZiAoanNvbilcbiAgICAgICAgcHRyLmFkZEpTT04oanNvbik7XG4gICAgcmV0dXJuIHB0cjtcbn07XG5cbi8qKlxuICogUmVzb2x2ZXMgdGhpcyBuYW1lc3BhY2UncyBhbmQgYWxsIGl0cyBuZXN0ZWQgb2JqZWN0cycgdHlwZSByZWZlcmVuY2VzLiBVc2VmdWwgdG8gdmFsaWRhdGUgYSByZWZsZWN0aW9uIHRyZWUsIGJ1dCBjb21lcyBhdCBhIGNvc3QuXG4gKiBAcmV0dXJucyB7TmFtZXNwYWNlfSBgdGhpc2BcbiAqL1xuTmFtZXNwYWNlLnByb3RvdHlwZS5yZXNvbHZlQWxsID0gZnVuY3Rpb24gcmVzb2x2ZUFsbCgpIHtcbiAgICB2YXIgbmVzdGVkID0gdGhpcy5uZXN0ZWRBcnJheSwgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBuZXN0ZWQubGVuZ3RoKVxuICAgICAgICBpZiAobmVzdGVkW2ldIGluc3RhbmNlb2YgTmFtZXNwYWNlKVxuICAgICAgICAgICAgbmVzdGVkW2krK10ucmVzb2x2ZUFsbCgpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBuZXN0ZWRbaSsrXS5yZXNvbHZlKCk7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x2ZSgpO1xufTtcblxuLyoqXG4gKiBSZWN1cnNpdmVseSBsb29rcyB1cCB0aGUgcmVmbGVjdGlvbiBvYmplY3QgbWF0Y2hpbmcgdGhlIHNwZWNpZmllZCBwYXRoIGluIHRoZSBzY29wZSBvZiB0aGlzIG5hbWVzcGFjZS5cbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBwYXRoIFBhdGggdG8gbG9vayB1cFxuICogQHBhcmFtIHsqfEFycmF5LjwqPn0gZmlsdGVyVHlwZXMgRmlsdGVyIHR5cGVzLCBhbnkgY29tYmluYXRpb24gb2YgdGhlIGNvbnN0cnVjdG9ycyBvZiBgcHJvdG9idWYuVHlwZWAsIGBwcm90b2J1Zi5FbnVtYCwgYHByb3RvYnVmLlNlcnZpY2VgIGV0Yy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3BhcmVudEFscmVhZHlDaGVja2VkPWZhbHNlXSBJZiBrbm93biwgd2hldGhlciB0aGUgcGFyZW50IGhhcyBhbHJlYWR5IGJlZW4gY2hlY2tlZFxuICogQHJldHVybnMge1JlZmxlY3Rpb25PYmplY3R8bnVsbH0gTG9va2VkIHVwIG9iamVjdCBvciBgbnVsbGAgaWYgbm9uZSBjb3VsZCBiZSBmb3VuZFxuICovXG5OYW1lc3BhY2UucHJvdG90eXBlLmxvb2t1cCA9IGZ1bmN0aW9uIGxvb2t1cChwYXRoLCBmaWx0ZXJUeXBlcywgcGFyZW50QWxyZWFkeUNoZWNrZWQpIHtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgaWYgKHR5cGVvZiBmaWx0ZXJUeXBlcyA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgcGFyZW50QWxyZWFkeUNoZWNrZWQgPSBmaWx0ZXJUeXBlcztcbiAgICAgICAgZmlsdGVyVHlwZXMgPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIGlmIChmaWx0ZXJUeXBlcyAmJiAhQXJyYXkuaXNBcnJheShmaWx0ZXJUeXBlcykpXG4gICAgICAgIGZpbHRlclR5cGVzID0gWyBmaWx0ZXJUeXBlcyBdO1xuXG4gICAgaWYgKHV0aWwuaXNTdHJpbmcocGF0aCkgJiYgcGF0aC5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHBhdGggPT09IFwiLlwiKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucm9vdDtcbiAgICAgICAgcGF0aCA9IHBhdGguc3BsaXQoXCIuXCIpO1xuICAgIH0gZWxzZSBpZiAoIXBhdGgubGVuZ3RoKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIC8vIFN0YXJ0IGF0IHJvb3QgaWYgcGF0aCBpcyBhYnNvbHV0ZVxuICAgIGlmIChwYXRoWzBdID09PSBcIlwiKVxuICAgICAgICByZXR1cm4gdGhpcy5yb290Lmxvb2t1cChwYXRoLnNsaWNlKDEpLCBmaWx0ZXJUeXBlcyk7XG5cbiAgICAvLyBUZXN0IGlmIHRoZSBmaXJzdCBwYXJ0IG1hdGNoZXMgYW55IG5lc3RlZCBvYmplY3QsIGFuZCBpZiBzbywgdHJhdmVyc2UgaWYgcGF0aCBjb250YWlucyBtb3JlXG4gICAgdmFyIGZvdW5kID0gdGhpcy5nZXQocGF0aFswXSk7XG4gICAgaWYgKGZvdW5kKSB7XG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgaWYgKCFmaWx0ZXJUeXBlcyB8fCBmaWx0ZXJUeXBlcy5pbmRleE9mKGZvdW5kLmNvbnN0cnVjdG9yKSA+IC0xKVxuICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZDtcbiAgICAgICAgfSBlbHNlIGlmIChmb3VuZCBpbnN0YW5jZW9mIE5hbWVzcGFjZSAmJiAoZm91bmQgPSBmb3VuZC5sb29rdXAocGF0aC5zbGljZSgxKSwgZmlsdGVyVHlwZXMsIHRydWUpKSlcbiAgICAgICAgICAgIHJldHVybiBmb3VuZDtcblxuICAgIC8vIE90aGVyd2lzZSB0cnkgZWFjaCBuZXN0ZWQgbmFtZXNwYWNlXG4gICAgfSBlbHNlXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5uZXN0ZWRBcnJheS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIGlmICh0aGlzLl9uZXN0ZWRBcnJheVtpXSBpbnN0YW5jZW9mIE5hbWVzcGFjZSAmJiAoZm91bmQgPSB0aGlzLl9uZXN0ZWRBcnJheVtpXS5sb29rdXAocGF0aCwgZmlsdGVyVHlwZXMsIHRydWUpKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQ7XG5cbiAgICAvLyBJZiB0aGVyZSBoYXNuJ3QgYmVlbiBhIG1hdGNoLCB0cnkgYWdhaW4gYXQgdGhlIHBhcmVudFxuICAgIGlmICh0aGlzLnBhcmVudCA9PT0gbnVsbCB8fCBwYXJlbnRBbHJlYWR5Q2hlY2tlZClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHRoaXMucGFyZW50Lmxvb2t1cChwYXRoLCBmaWx0ZXJUeXBlcyk7XG59O1xuXG4vKipcbiAqIExvb2tzIHVwIHRoZSByZWZsZWN0aW9uIG9iamVjdCBhdCB0aGUgc3BlY2lmaWVkIHBhdGgsIHJlbGF0aXZlIHRvIHRoaXMgbmFtZXNwYWNlLlxuICogQG5hbWUgTmFtZXNwYWNlQmFzZSNsb29rdXBcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IHBhdGggUGF0aCB0byBsb29rIHVwXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtwYXJlbnRBbHJlYWR5Q2hlY2tlZD1mYWxzZV0gV2hldGhlciB0aGUgcGFyZW50IGhhcyBhbHJlYWR5IGJlZW4gY2hlY2tlZFxuICogQHJldHVybnMge1JlZmxlY3Rpb25PYmplY3R8bnVsbH0gTG9va2VkIHVwIG9iamVjdCBvciBgbnVsbGAgaWYgbm9uZSBjb3VsZCBiZSBmb3VuZFxuICogQHZhcmlhdGlvbiAyXG4gKi9cbi8vIGxvb2t1cChwYXRoOiBzdHJpbmcsIFtwYXJlbnRBbHJlYWR5Q2hlY2tlZDogYm9vbGVhbl0pXG5cbi8qKlxuICogTG9va3MgdXAgdGhlIHtAbGluayBUeXBlfHR5cGV9IGF0IHRoZSBzcGVjaWZpZWQgcGF0aCwgcmVsYXRpdmUgdG8gdGhpcyBuYW1lc3BhY2UuXG4gKiBCZXNpZGVzIGl0cyBzaWduYXR1cmUsIHRoaXMgbWV0aG9kcyBkaWZmZXJzIGZyb20ge0BsaW5rIE5hbWVzcGFjZSNsb29rdXB8bG9va3VwfSBpbiB0aGF0IGl0IHRocm93cyBpbnN0ZWFkIG9mIHJldHVybmluZyBgbnVsbGAuXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gcGF0aCBQYXRoIHRvIGxvb2sgdXBcbiAqIEByZXR1cm5zIHtUeXBlfSBMb29rZWQgdXAgdHlwZVxuICogQHRocm93cyB7RXJyb3J9IElmIGBwYXRoYCBkb2VzIG5vdCBwb2ludCB0byBhIHR5cGVcbiAqL1xuTmFtZXNwYWNlLnByb3RvdHlwZS5sb29rdXBUeXBlID0gZnVuY3Rpb24gbG9va3VwVHlwZShwYXRoKSB7XG4gICAgdmFyIGZvdW5kID0gdGhpcy5sb29rdXAocGF0aCwgWyBUeXBlIF0pO1xuICAgIGlmICghZm91bmQpXG4gICAgICAgIHRocm93IEVycm9yKFwibm8gc3VjaCB0eXBlOiBcIiArIHBhdGgpO1xuICAgIHJldHVybiBmb3VuZDtcbn07XG5cbi8qKlxuICogTG9va3MgdXAgdGhlIHZhbHVlcyBvZiB0aGUge0BsaW5rIEVudW18ZW51bX0gYXQgdGhlIHNwZWNpZmllZCBwYXRoLCByZWxhdGl2ZSB0byB0aGlzIG5hbWVzcGFjZS5cbiAqIEJlc2lkZXMgaXRzIHNpZ25hdHVyZSwgdGhpcyBtZXRob2RzIGRpZmZlcnMgZnJvbSB7QGxpbmsgTmFtZXNwYWNlI2xvb2t1cHxsb29rdXB9IGluIHRoYXQgaXQgdGhyb3dzIGluc3RlYWQgb2YgcmV0dXJuaW5nIGBudWxsYC5cbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBwYXRoIFBhdGggdG8gbG9vayB1cFxuICogQHJldHVybnMge0VudW19IExvb2tlZCB1cCBlbnVtXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgYHBhdGhgIGRvZXMgbm90IHBvaW50IHRvIGFuIGVudW1cbiAqL1xuTmFtZXNwYWNlLnByb3RvdHlwZS5sb29rdXBFbnVtID0gZnVuY3Rpb24gbG9va3VwRW51bShwYXRoKSB7XG4gICAgdmFyIGZvdW5kID0gdGhpcy5sb29rdXAocGF0aCwgWyBFbnVtIF0pO1xuICAgIGlmICghZm91bmQpXG4gICAgICAgIHRocm93IEVycm9yKFwibm8gc3VjaCBFbnVtICdcIiArIHBhdGggKyBcIicgaW4gXCIgKyB0aGlzKTtcbiAgICByZXR1cm4gZm91bmQ7XG59O1xuXG4vKipcbiAqIExvb2tzIHVwIHRoZSB7QGxpbmsgVHlwZXx0eXBlfSBvciB7QGxpbmsgRW51bXxlbnVtfSBhdCB0aGUgc3BlY2lmaWVkIHBhdGgsIHJlbGF0aXZlIHRvIHRoaXMgbmFtZXNwYWNlLlxuICogQmVzaWRlcyBpdHMgc2lnbmF0dXJlLCB0aGlzIG1ldGhvZHMgZGlmZmVycyBmcm9tIHtAbGluayBOYW1lc3BhY2UjbG9va3VwfGxvb2t1cH0gaW4gdGhhdCBpdCB0aHJvd3MgaW5zdGVhZCBvZiByZXR1cm5pbmcgYG51bGxgLlxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IHBhdGggUGF0aCB0byBsb29rIHVwXG4gKiBAcmV0dXJucyB7VHlwZX0gTG9va2VkIHVwIHR5cGUgb3IgZW51bVxuICogQHRocm93cyB7RXJyb3J9IElmIGBwYXRoYCBkb2VzIG5vdCBwb2ludCB0byBhIHR5cGUgb3IgZW51bVxuICovXG5OYW1lc3BhY2UucHJvdG90eXBlLmxvb2t1cFR5cGVPckVudW0gPSBmdW5jdGlvbiBsb29rdXBUeXBlT3JFbnVtKHBhdGgpIHtcbiAgICB2YXIgZm91bmQgPSB0aGlzLmxvb2t1cChwYXRoLCBbIFR5cGUsIEVudW0gXSk7XG4gICAgaWYgKCFmb3VuZClcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJubyBzdWNoIFR5cGUgb3IgRW51bSAnXCIgKyBwYXRoICsgXCInIGluIFwiICsgdGhpcyk7XG4gICAgcmV0dXJuIGZvdW5kO1xufTtcblxuLyoqXG4gKiBMb29rcyB1cCB0aGUge0BsaW5rIFNlcnZpY2V8c2VydmljZX0gYXQgdGhlIHNwZWNpZmllZCBwYXRoLCByZWxhdGl2ZSB0byB0aGlzIG5hbWVzcGFjZS5cbiAqIEJlc2lkZXMgaXRzIHNpZ25hdHVyZSwgdGhpcyBtZXRob2RzIGRpZmZlcnMgZnJvbSB7QGxpbmsgTmFtZXNwYWNlI2xvb2t1cHxsb29rdXB9IGluIHRoYXQgaXQgdGhyb3dzIGluc3RlYWQgb2YgcmV0dXJuaW5nIGBudWxsYC5cbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBwYXRoIFBhdGggdG8gbG9vayB1cFxuICogQHJldHVybnMge1NlcnZpY2V9IExvb2tlZCB1cCBzZXJ2aWNlXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgYHBhdGhgIGRvZXMgbm90IHBvaW50IHRvIGEgc2VydmljZVxuICovXG5OYW1lc3BhY2UucHJvdG90eXBlLmxvb2t1cFNlcnZpY2UgPSBmdW5jdGlvbiBsb29rdXBTZXJ2aWNlKHBhdGgpIHtcbiAgICB2YXIgZm91bmQgPSB0aGlzLmxvb2t1cChwYXRoLCBbIFNlcnZpY2UgXSk7XG4gICAgaWYgKCFmb3VuZClcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJubyBzdWNoIFNlcnZpY2UgJ1wiICsgcGF0aCArIFwiJyBpbiBcIiArIHRoaXMpO1xuICAgIHJldHVybiBmb3VuZDtcbn07XG5cbi8vIFNldHMgdXAgY3ljbGljIGRlcGVuZGVuY2llcyAoY2FsbGVkIGluIGluZGV4LWxpZ2h0KVxuTmFtZXNwYWNlLl9jb25maWd1cmUgPSBmdW5jdGlvbihUeXBlXywgU2VydmljZV8sIEVudW1fKSB7XG4gICAgVHlwZSAgICA9IFR5cGVfO1xuICAgIFNlcnZpY2UgPSBTZXJ2aWNlXztcbiAgICBFbnVtICAgID0gRW51bV87XG59O1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJOYW1lc3BhY2UiLCJSZWZsZWN0aW9uT2JqZWN0IiwicmVxdWlyZSIsInByb3RvdHlwZSIsIk9iamVjdCIsImNyZWF0ZSIsImNvbnN0cnVjdG9yIiwiY2xhc3NOYW1lIiwiRmllbGQiLCJ1dGlsIiwiT25lT2YiLCJUeXBlIiwiU2VydmljZSIsIkVudW0iLCJmcm9tSlNPTiIsIm5hbWUiLCJqc29uIiwib3B0aW9ucyIsImFkZEpTT04iLCJuZXN0ZWQiLCJhcnJheVRvSlNPTiIsImFycmF5IiwidG9KU09OT3B0aW9ucyIsImxlbmd0aCIsInVuZGVmaW5lZCIsIm9iaiIsImkiLCJ0b0pTT04iLCJpc1Jlc2VydmVkSWQiLCJyZXNlcnZlZCIsImlkIiwiaXNSZXNlcnZlZE5hbWUiLCJjYWxsIiwiX25lc3RlZEFycmF5IiwiY2xlYXJDYWNoZSIsIm5hbWVzcGFjZSIsImRlZmluZVByb3BlcnR5IiwiZ2V0IiwidG9BcnJheSIsInRvT2JqZWN0IiwibmVzdGVkQXJyYXkiLCJuZXN0ZWRKc29uIiwibnMiLCJuYW1lcyIsImtleXMiLCJhZGQiLCJmaWVsZHMiLCJ2YWx1ZXMiLCJtZXRob2RzIiwiZ2V0RW51bSIsIkVycm9yIiwib2JqZWN0IiwiZXh0ZW5kIiwiVHlwZUVycm9yIiwicHJldiIsInJlbW92ZSIsInNldE9wdGlvbnMiLCJvbkFkZCIsInBhcmVudCIsIm9uUmVtb3ZlIiwiZGVmaW5lIiwicGF0aCIsImlzU3RyaW5nIiwic3BsaXQiLCJBcnJheSIsImlzQXJyYXkiLCJwdHIiLCJwYXJ0Iiwic2hpZnQiLCJyZXNvbHZlQWxsIiwicmVzb2x2ZSIsImxvb2t1cCIsImZpbHRlclR5cGVzIiwicGFyZW50QWxyZWFkeUNoZWNrZWQiLCJyb290Iiwic2xpY2UiLCJmb3VuZCIsImluZGV4T2YiLCJsb29rdXBUeXBlIiwibG9va3VwRW51bSIsImxvb2t1cFR5cGVPckVudW0iLCJsb29rdXBTZXJ2aWNlIiwiX2NvbmZpZ3VyZSIsIlR5cGVfIiwiU2VydmljZV8iLCJFbnVtXyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/protobufjs/src/namespace.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/src/object.js":
/*!************************************************!*\
  !*** ../node_modules/protobufjs/src/object.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = ReflectionObject;\nReflectionObject.className = \"ReflectionObject\";\nvar util = __webpack_require__(/*! ./util */ \"(ssr)/../node_modules/protobufjs/src/util.js\");\nvar Root; // cyclic\n/**\n * Constructs a new reflection object instance.\n * @classdesc Base class of all reflection objects.\n * @constructor\n * @param {string} name Object name\n * @param {Object.<string,*>} [options] Declared options\n * @abstract\n */ function ReflectionObject(name, options) {\n    if (!util.isString(name)) throw TypeError(\"name must be a string\");\n    if (options && !util.isObject(options)) throw TypeError(\"options must be an object\");\n    /**\n     * Options.\n     * @type {Object.<string,*>|undefined}\n     */ this.options = options; // toJSON\n    /**\n     * Parsed Options.\n     * @type {Array.<Object.<string,*>>|undefined}\n     */ this.parsedOptions = null;\n    /**\n     * Unique name within its namespace.\n     * @type {string}\n     */ this.name = name;\n    /**\n     * Parent namespace.\n     * @type {Namespace|null}\n     */ this.parent = null;\n    /**\n     * Whether already resolved or not.\n     * @type {boolean}\n     */ this.resolved = false;\n    /**\n     * Comment text, if any.\n     * @type {string|null}\n     */ this.comment = null;\n    /**\n     * Defining file name.\n     * @type {string|null}\n     */ this.filename = null;\n}\nObject.defineProperties(ReflectionObject.prototype, {\n    /**\n     * Reference to the root namespace.\n     * @name ReflectionObject#root\n     * @type {Root}\n     * @readonly\n     */ root: {\n        get: function() {\n            var ptr = this;\n            while(ptr.parent !== null)ptr = ptr.parent;\n            return ptr;\n        }\n    },\n    /**\n     * Full name including leading dot.\n     * @name ReflectionObject#fullName\n     * @type {string}\n     * @readonly\n     */ fullName: {\n        get: function() {\n            var path = [\n                this.name\n            ], ptr = this.parent;\n            while(ptr){\n                path.unshift(ptr.name);\n                ptr = ptr.parent;\n            }\n            return path.join(\".\");\n        }\n    }\n});\n/**\n * Converts this reflection object to its descriptor representation.\n * @returns {Object.<string,*>} Descriptor\n * @abstract\n */ ReflectionObject.prototype.toJSON = /* istanbul ignore next */ function toJSON() {\n    throw Error(); // not implemented, shouldn't happen\n};\n/**\n * Called when this object is added to a parent.\n * @param {ReflectionObject} parent Parent added to\n * @returns {undefined}\n */ ReflectionObject.prototype.onAdd = function onAdd(parent) {\n    if (this.parent && this.parent !== parent) this.parent.remove(this);\n    this.parent = parent;\n    this.resolved = false;\n    var root = parent.root;\n    if (root instanceof Root) root._handleAdd(this);\n};\n/**\n * Called when this object is removed from a parent.\n * @param {ReflectionObject} parent Parent removed from\n * @returns {undefined}\n */ ReflectionObject.prototype.onRemove = function onRemove(parent) {\n    var root = parent.root;\n    if (root instanceof Root) root._handleRemove(this);\n    this.parent = null;\n    this.resolved = false;\n};\n/**\n * Resolves this objects type references.\n * @returns {ReflectionObject} `this`\n */ ReflectionObject.prototype.resolve = function resolve() {\n    if (this.resolved) return this;\n    if (this.root instanceof Root) this.resolved = true; // only if part of a root\n    return this;\n};\n/**\n * Gets an option value.\n * @param {string} name Option name\n * @returns {*} Option value or `undefined` if not set\n */ ReflectionObject.prototype.getOption = function getOption(name) {\n    if (this.options) return this.options[name];\n    return undefined;\n};\n/**\n * Sets an option.\n * @param {string} name Option name\n * @param {*} value Option value\n * @param {boolean} [ifNotSet] Sets the option only if it isn't currently set\n * @returns {ReflectionObject} `this`\n */ ReflectionObject.prototype.setOption = function setOption(name, value, ifNotSet) {\n    if (!ifNotSet || !this.options || this.options[name] === undefined) (this.options || (this.options = {}))[name] = value;\n    return this;\n};\n/**\n * Sets a parsed option.\n * @param {string} name parsed Option name\n * @param {*} value Option value\n * @param {string} propName dot '.' delimited full path of property within the option to set. if undefined\\empty, will add a new option with that value\n * @returns {ReflectionObject} `this`\n */ ReflectionObject.prototype.setParsedOption = function setParsedOption(name, value, propName) {\n    if (!this.parsedOptions) {\n        this.parsedOptions = [];\n    }\n    var parsedOptions = this.parsedOptions;\n    if (propName) {\n        // If setting a sub property of an option then try to merge it\n        // with an existing option\n        var opt = parsedOptions.find(function(opt) {\n            return Object.prototype.hasOwnProperty.call(opt, name);\n        });\n        if (opt) {\n            // If we found an existing option - just merge the property value\n            var newValue = opt[name];\n            util.setProperty(newValue, propName, value);\n        } else {\n            // otherwise, create a new option, set it's property and add it to the list\n            opt = {};\n            opt[name] = util.setProperty({}, propName, value);\n            parsedOptions.push(opt);\n        }\n    } else {\n        // Always create a new option when setting the value of the option itself\n        var newOpt = {};\n        newOpt[name] = value;\n        parsedOptions.push(newOpt);\n    }\n    return this;\n};\n/**\n * Sets multiple options.\n * @param {Object.<string,*>} options Options to set\n * @param {boolean} [ifNotSet] Sets an option only if it isn't currently set\n * @returns {ReflectionObject} `this`\n */ ReflectionObject.prototype.setOptions = function setOptions(options, ifNotSet) {\n    if (options) for(var keys = Object.keys(options), i = 0; i < keys.length; ++i)this.setOption(keys[i], options[keys[i]], ifNotSet);\n    return this;\n};\n/**\n * Converts this instance to its string representation.\n * @returns {string} Class name[, space, full name]\n */ ReflectionObject.prototype.toString = function toString() {\n    var className = this.constructor.className, fullName = this.fullName;\n    if (fullName.length) return className + \" \" + fullName;\n    return className;\n};\n// Sets up cyclic dependencies (called in index-light)\nReflectionObject._configure = function(Root_) {\n    Root = Root_;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL29iamVjdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSxPQUFPQyxPQUFPLEdBQUdDO0FBRWpCQSxpQkFBaUJDLFNBQVMsR0FBRztBQUU3QixJQUFJQyxPQUFPQyxtQkFBT0EsQ0FBQyw0REFBUTtBQUUzQixJQUFJQyxNQUFNLFNBQVM7QUFFbkI7Ozs7Ozs7Q0FPQyxHQUNELFNBQVNKLGlCQUFpQkssSUFBSSxFQUFFQyxPQUFPO0lBRW5DLElBQUksQ0FBQ0osS0FBS0ssUUFBUSxDQUFDRixPQUNmLE1BQU1HLFVBQVU7SUFFcEIsSUFBSUYsV0FBVyxDQUFDSixLQUFLTyxRQUFRLENBQUNILFVBQzFCLE1BQU1FLFVBQVU7SUFFcEI7OztLQUdDLEdBQ0QsSUFBSSxDQUFDRixPQUFPLEdBQUdBLFNBQVMsU0FBUztJQUVqQzs7O0tBR0MsR0FDRCxJQUFJLENBQUNJLGFBQWEsR0FBRztJQUVyQjs7O0tBR0MsR0FDRCxJQUFJLENBQUNMLElBQUksR0FBR0E7SUFFWjs7O0tBR0MsR0FDRCxJQUFJLENBQUNNLE1BQU0sR0FBRztJQUVkOzs7S0FHQyxHQUNELElBQUksQ0FBQ0MsUUFBUSxHQUFHO0lBRWhCOzs7S0FHQyxHQUNELElBQUksQ0FBQ0MsT0FBTyxHQUFHO0lBRWY7OztLQUdDLEdBQ0QsSUFBSSxDQUFDQyxRQUFRLEdBQUc7QUFDcEI7QUFFQUMsT0FBT0MsZ0JBQWdCLENBQUNoQixpQkFBaUJpQixTQUFTLEVBQUU7SUFFaEQ7Ozs7O0tBS0MsR0FDREMsTUFBTTtRQUNGQyxLQUFLO1lBQ0QsSUFBSUMsTUFBTSxJQUFJO1lBQ2QsTUFBT0EsSUFBSVQsTUFBTSxLQUFLLEtBQ2xCUyxNQUFNQSxJQUFJVCxNQUFNO1lBQ3BCLE9BQU9TO1FBQ1g7SUFDSjtJQUVBOzs7OztLQUtDLEdBQ0RDLFVBQVU7UUFDTkYsS0FBSztZQUNELElBQUlHLE9BQU87Z0JBQUUsSUFBSSxDQUFDakIsSUFBSTthQUFFLEVBQ3BC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ZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9vYmplY3QuanM/MTMzNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gUmVmbGVjdGlvbk9iamVjdDtcblxuUmVmbGVjdGlvbk9iamVjdC5jbGFzc05hbWUgPSBcIlJlZmxlY3Rpb25PYmplY3RcIjtcblxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuXG52YXIgUm9vdDsgLy8gY3ljbGljXG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyByZWZsZWN0aW9uIG9iamVjdCBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgQmFzZSBjbGFzcyBvZiBhbGwgcmVmbGVjdGlvbiBvYmplY3RzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBPYmplY3QgbmFtZVxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gW29wdGlvbnNdIERlY2xhcmVkIG9wdGlvbnNcbiAqIEBhYnN0cmFjdFxuICovXG5mdW5jdGlvbiBSZWZsZWN0aW9uT2JqZWN0KG5hbWUsIG9wdGlvbnMpIHtcblxuICAgIGlmICghdXRpbC5pc1N0cmluZyhuYW1lKSlcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwibmFtZSBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuXG4gICAgaWYgKG9wdGlvbnMgJiYgIXV0aWwuaXNPYmplY3Qob3B0aW9ucykpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcIm9wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3RcIik7XG5cbiAgICAvKipcbiAgICAgKiBPcHRpb25zLlxuICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywqPnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9uczsgLy8gdG9KU09OXG5cbiAgICAvKipcbiAgICAgKiBQYXJzZWQgT3B0aW9ucy5cbiAgICAgKiBAdHlwZSB7QXJyYXkuPE9iamVjdC48c3RyaW5nLCo+Pnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5wYXJzZWRPcHRpb25zID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFVuaXF1ZSBuYW1lIHdpdGhpbiBpdHMgbmFtZXNwYWNlLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5uYW1lID0gbmFtZTtcblxuICAgIC8qKlxuICAgICAqIFBhcmVudCBuYW1lc3BhY2UuXG4gICAgICogQHR5cGUge05hbWVzcGFjZXxudWxsfVxuICAgICAqL1xuICAgIHRoaXMucGFyZW50ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgYWxyZWFkeSByZXNvbHZlZCBvciBub3QuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5yZXNvbHZlZCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQ29tbWVudCB0ZXh0LCBpZiBhbnkuXG4gICAgICogQHR5cGUge3N0cmluZ3xudWxsfVxuICAgICAqL1xuICAgIHRoaXMuY29tbWVudCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBEZWZpbmluZyBmaWxlIG5hbWUuXG4gICAgICogQHR5cGUge3N0cmluZ3xudWxsfVxuICAgICAqL1xuICAgIHRoaXMuZmlsZW5hbWUgPSBudWxsO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZWZsZWN0aW9uT2JqZWN0LnByb3RvdHlwZSwge1xuXG4gICAgLyoqXG4gICAgICogUmVmZXJlbmNlIHRvIHRoZSByb290IG5hbWVzcGFjZS5cbiAgICAgKiBAbmFtZSBSZWZsZWN0aW9uT2JqZWN0I3Jvb3RcbiAgICAgKiBAdHlwZSB7Um9vdH1cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICByb290OiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcHRyID0gdGhpcztcbiAgICAgICAgICAgIHdoaWxlIChwdHIucGFyZW50ICE9PSBudWxsKVxuICAgICAgICAgICAgICAgIHB0ciA9IHB0ci5wYXJlbnQ7XG4gICAgICAgICAgICByZXR1cm4gcHRyO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZ1bGwgbmFtZSBpbmNsdWRpbmcgbGVhZGluZyBkb3QuXG4gICAgICogQG5hbWUgUmVmbGVjdGlvbk9iamVjdCNmdWxsTmFtZVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgZnVsbE5hbWU6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBwYXRoID0gWyB0aGlzLm5hbWUgXSxcbiAgICAgICAgICAgICAgICBwdHIgPSB0aGlzLnBhcmVudDtcbiAgICAgICAgICAgIHdoaWxlIChwdHIpIHtcbiAgICAgICAgICAgICAgICBwYXRoLnVuc2hpZnQocHRyLm5hbWUpO1xuICAgICAgICAgICAgICAgIHB0ciA9IHB0ci5wYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGF0aC5qb2luKFwiLlwiKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgcmVmbGVjdGlvbiBvYmplY3QgdG8gaXRzIGRlc2NyaXB0b3IgcmVwcmVzZW50YXRpb24uXG4gKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IERlc2NyaXB0b3JcbiAqIEBhYnN0cmFjdFxuICovXG5SZWZsZWN0aW9uT2JqZWN0LnByb3RvdHlwZS50b0pTT04gPSAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgdGhyb3cgRXJyb3IoKTsgLy8gbm90IGltcGxlbWVudGVkLCBzaG91bGRuJ3QgaGFwcGVuXG59O1xuXG4vKipcbiAqIENhbGxlZCB3aGVuIHRoaXMgb2JqZWN0IGlzIGFkZGVkIHRvIGEgcGFyZW50LlxuICogQHBhcmFtIHtSZWZsZWN0aW9uT2JqZWN0fSBwYXJlbnQgUGFyZW50IGFkZGVkIHRvXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5SZWZsZWN0aW9uT2JqZWN0LnByb3RvdHlwZS5vbkFkZCA9IGZ1bmN0aW9uIG9uQWRkKHBhcmVudCkge1xuICAgIGlmICh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudCAhPT0gcGFyZW50KVxuICAgICAgICB0aGlzLnBhcmVudC5yZW1vdmUodGhpcyk7XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgdGhpcy5yZXNvbHZlZCA9IGZhbHNlO1xuICAgIHZhciByb290ID0gcGFyZW50LnJvb3Q7XG4gICAgaWYgKHJvb3QgaW5zdGFuY2VvZiBSb290KVxuICAgICAgICByb290Ll9oYW5kbGVBZGQodGhpcyk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aGVuIHRoaXMgb2JqZWN0IGlzIHJlbW92ZWQgZnJvbSBhIHBhcmVudC5cbiAqIEBwYXJhbSB7UmVmbGVjdGlvbk9iamVjdH0gcGFyZW50IFBhcmVudCByZW1vdmVkIGZyb21cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cblJlZmxlY3Rpb25PYmplY3QucHJvdG90eXBlLm9uUmVtb3ZlID0gZnVuY3Rpb24gb25SZW1vdmUocGFyZW50KSB7XG4gICAgdmFyIHJvb3QgPSBwYXJlbnQucm9vdDtcbiAgICBpZiAocm9vdCBpbnN0YW5jZW9mIFJvb3QpXG4gICAgICAgIHJvb3QuX2hhbmRsZVJlbW92ZSh0aGlzKTtcbiAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgdGhpcy5yZXNvbHZlZCA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBSZXNvbHZlcyB0aGlzIG9iamVjdHMgdHlwZSByZWZlcmVuY2VzLlxuICogQHJldHVybnMge1JlZmxlY3Rpb25PYmplY3R9IGB0aGlzYFxuICovXG5SZWZsZWN0aW9uT2JqZWN0LnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gcmVzb2x2ZSgpIHtcbiAgICBpZiAodGhpcy5yZXNvbHZlZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgaWYgKHRoaXMucm9vdCBpbnN0YW5jZW9mIFJvb3QpXG4gICAgICAgIHRoaXMucmVzb2x2ZWQgPSB0cnVlOyAvLyBvbmx5IGlmIHBhcnQgb2YgYSByb290XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEdldHMgYW4gb3B0aW9uIHZhbHVlLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgT3B0aW9uIG5hbWVcbiAqIEByZXR1cm5zIHsqfSBPcHRpb24gdmFsdWUgb3IgYHVuZGVmaW5lZGAgaWYgbm90IHNldFxuICovXG5SZWZsZWN0aW9uT2JqZWN0LnByb3RvdHlwZS5nZXRPcHRpb24gPSBmdW5jdGlvbiBnZXRPcHRpb24obmFtZSkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMpXG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNbbmFtZV07XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbi8qKlxuICogU2V0cyBhbiBvcHRpb24uXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBPcHRpb24gbmFtZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBPcHRpb24gdmFsdWVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lmTm90U2V0XSBTZXRzIHRoZSBvcHRpb24gb25seSBpZiBpdCBpc24ndCBjdXJyZW50bHkgc2V0XG4gKiBAcmV0dXJucyB7UmVmbGVjdGlvbk9iamVjdH0gYHRoaXNgXG4gKi9cblJlZmxlY3Rpb25PYmplY3QucHJvdG90eXBlLnNldE9wdGlvbiA9IGZ1bmN0aW9uIHNldE9wdGlvbihuYW1lLCB2YWx1ZSwgaWZOb3RTZXQpIHtcbiAgICBpZiAoIWlmTm90U2V0IHx8ICF0aGlzLm9wdGlvbnMgfHwgdGhpcy5vcHRpb25zW25hbWVdID09PSB1bmRlZmluZWQpXG4gICAgICAgICh0aGlzLm9wdGlvbnMgfHwgKHRoaXMub3B0aW9ucyA9IHt9KSlbbmFtZV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyBhIHBhcnNlZCBvcHRpb24uXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBwYXJzZWQgT3B0aW9uIG5hbWVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgT3B0aW9uIHZhbHVlXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcE5hbWUgZG90ICcuJyBkZWxpbWl0ZWQgZnVsbCBwYXRoIG9mIHByb3BlcnR5IHdpdGhpbiB0aGUgb3B0aW9uIHRvIHNldC4gaWYgdW5kZWZpbmVkXFxlbXB0eSwgd2lsbCBhZGQgYSBuZXcgb3B0aW9uIHdpdGggdGhhdCB2YWx1ZVxuICogQHJldHVybnMge1JlZmxlY3Rpb25PYmplY3R9IGB0aGlzYFxuICovXG5SZWZsZWN0aW9uT2JqZWN0LnByb3RvdHlwZS5zZXRQYXJzZWRPcHRpb24gPSBmdW5jdGlvbiBzZXRQYXJzZWRPcHRpb24obmFtZSwgdmFsdWUsIHByb3BOYW1lKSB7XG4gICAgaWYgKCF0aGlzLnBhcnNlZE9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5wYXJzZWRPcHRpb25zID0gW107XG4gICAgfVxuICAgIHZhciBwYXJzZWRPcHRpb25zID0gdGhpcy5wYXJzZWRPcHRpb25zO1xuICAgIGlmIChwcm9wTmFtZSkge1xuICAgICAgICAvLyBJZiBzZXR0aW5nIGEgc3ViIHByb3BlcnR5IG9mIGFuIG9wdGlvbiB0aGVuIHRyeSB0byBtZXJnZSBpdFxuICAgICAgICAvLyB3aXRoIGFuIGV4aXN0aW5nIG9wdGlvblxuICAgICAgICB2YXIgb3B0ID0gcGFyc2VkT3B0aW9ucy5maW5kKGZ1bmN0aW9uIChvcHQpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0LCBuYW1lKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChvcHQpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGZvdW5kIGFuIGV4aXN0aW5nIG9wdGlvbiAtIGp1c3QgbWVyZ2UgdGhlIHByb3BlcnR5IHZhbHVlXG4gICAgICAgICAgICB2YXIgbmV3VmFsdWUgPSBvcHRbbmFtZV07XG4gICAgICAgICAgICB1dGlsLnNldFByb3BlcnR5KG5ld1ZhbHVlLCBwcm9wTmFtZSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlLCBjcmVhdGUgYSBuZXcgb3B0aW9uLCBzZXQgaXQncyBwcm9wZXJ0eSBhbmQgYWRkIGl0IHRvIHRoZSBsaXN0XG4gICAgICAgICAgICBvcHQgPSB7fTtcbiAgICAgICAgICAgIG9wdFtuYW1lXSA9IHV0aWwuc2V0UHJvcGVydHkoe30sIHByb3BOYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICBwYXJzZWRPcHRpb25zLnB1c2gob3B0KTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEFsd2F5cyBjcmVhdGUgYSBuZXcgb3B0aW9uIHdoZW4gc2V0dGluZyB0aGUgdmFsdWUgb2YgdGhlIG9wdGlvbiBpdHNlbGZcbiAgICAgICAgdmFyIG5ld09wdCA9IHt9O1xuICAgICAgICBuZXdPcHRbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgcGFyc2VkT3B0aW9ucy5wdXNoKG5ld09wdCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIG11bHRpcGxlIG9wdGlvbnMuXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvcHRpb25zIE9wdGlvbnMgdG8gc2V0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpZk5vdFNldF0gU2V0cyBhbiBvcHRpb24gb25seSBpZiBpdCBpc24ndCBjdXJyZW50bHkgc2V0XG4gKiBAcmV0dXJucyB7UmVmbGVjdGlvbk9iamVjdH0gYHRoaXNgXG4gKi9cblJlZmxlY3Rpb25PYmplY3QucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMsIGlmTm90U2V0KSB7XG4gICAgaWYgKG9wdGlvbnMpXG4gICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhvcHRpb25zKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgdGhpcy5zZXRPcHRpb24oa2V5c1tpXSwgb3B0aW9uc1trZXlzW2ldXSwgaWZOb3RTZXQpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIGluc3RhbmNlIHRvIGl0cyBzdHJpbmcgcmVwcmVzZW50YXRpb24uXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBDbGFzcyBuYW1lWywgc3BhY2UsIGZ1bGwgbmFtZV1cbiAqL1xuUmVmbGVjdGlvbk9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICB2YXIgY2xhc3NOYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5jbGFzc05hbWUsXG4gICAgICAgIGZ1bGxOYW1lICA9IHRoaXMuZnVsbE5hbWU7XG4gICAgaWYgKGZ1bGxOYW1lLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGNsYXNzTmFtZSArIFwiIFwiICsgZnVsbE5hbWU7XG4gICAgcmV0dXJuIGNsYXNzTmFtZTtcbn07XG5cbi8vIFNldHMgdXAgY3ljbGljIGRlcGVuZGVuY2llcyAoY2FsbGVkIGluIGluZGV4LWxpZ2h0KVxuUmVmbGVjdGlvbk9iamVjdC5fY29uZmlndXJlID0gZnVuY3Rpb24oUm9vdF8pIHtcbiAgICBSb290ID0gUm9vdF87XG59O1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJSZWZsZWN0aW9uT2JqZWN0IiwiY2xhc3NOYW1lIiwidXRpbCIsInJlcXVpcmUiLCJSb290IiwibmFtZSIsIm9wdGlvbnMiLCJpc1N0cmluZyIsIlR5cGVFcnJvciIsImlzT2JqZWN0IiwicGFyc2VkT3B0aW9ucyIsInBhcmVudCIsInJlc29sdmVkIiwiY29tbWVudCIsImZpbGVuYW1lIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydGllcyIsInByb3RvdHlwZSIsInJvb3QiLCJnZXQiLCJwdHIiLCJmdWxsTmFtZSIsInBhdGgiLCJ1bnNoaWZ0Iiwiam9pbiIsInRvSlNPTiIsIkVycm9yIiwib25BZGQiLCJyZW1vdmUiLCJfaGFuZGxlQWRkIiwib25SZW1vdmUiLCJfaGFuZGxlUmVtb3ZlIiwicmVzb2x2ZSIsImdldE9wdGlvbiIsInVuZGVmaW5lZCIsInNldE9wdGlvbiIsInZhbHVlIiwiaWZOb3RTZXQiLCJzZXRQYXJzZWRPcHRpb24iLCJwcm9wTmFtZSIsIm9wdCIsImZpbmQiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJuZXdWYWx1ZSIsInNldFByb3BlcnR5IiwicHVzaCIsIm5ld09wdCIsInNldE9wdGlvbnMiLCJrZXlzIiwiaSIsImxlbmd0aCIsInRvU3RyaW5nIiwiY29uc3RydWN0b3IiLCJfY29uZmlndXJlIiwiUm9vdF8iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/protobufjs/src/object.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/src/oneof.js":
/*!***********************************************!*\
  !*** ../node_modules/protobufjs/src/oneof.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = OneOf;\n// extends ReflectionObject\nvar ReflectionObject = __webpack_require__(/*! ./object */ \"(ssr)/../node_modules/protobufjs/src/object.js\");\n((OneOf.prototype = Object.create(ReflectionObject.prototype)).constructor = OneOf).className = \"OneOf\";\nvar Field = __webpack_require__(/*! ./field */ \"(ssr)/../node_modules/protobufjs/src/field.js\"), util = __webpack_require__(/*! ./util */ \"(ssr)/../node_modules/protobufjs/src/util.js\");\n/**\n * Constructs a new oneof instance.\n * @classdesc Reflected oneof.\n * @extends ReflectionObject\n * @constructor\n * @param {string} name Oneof name\n * @param {string[]|Object.<string,*>} [fieldNames] Field names\n * @param {Object.<string,*>} [options] Declared options\n * @param {string} [comment] Comment associated with this field\n */ function OneOf(name, fieldNames, options, comment) {\n    if (!Array.isArray(fieldNames)) {\n        options = fieldNames;\n        fieldNames = undefined;\n    }\n    ReflectionObject.call(this, name, options);\n    /* istanbul ignore if */ if (!(fieldNames === undefined || Array.isArray(fieldNames))) throw TypeError(\"fieldNames must be an Array\");\n    /**\n     * Field names that belong to this oneof.\n     * @type {string[]}\n     */ this.oneof = fieldNames || []; // toJSON, marker\n    /**\n     * Fields that belong to this oneof as an array for iteration.\n     * @type {Field[]}\n     * @readonly\n     */ this.fieldsArray = []; // declared readonly for conformance, possibly not yet added to parent\n    /**\n     * Comment for this field.\n     * @type {string|null}\n     */ this.comment = comment;\n}\n/**\n * Oneof descriptor.\n * @interface IOneOf\n * @property {Array.<string>} oneof Oneof field names\n * @property {Object.<string,*>} [options] Oneof options\n */ /**\n * Constructs a oneof from a oneof descriptor.\n * @param {string} name Oneof name\n * @param {IOneOf} json Oneof descriptor\n * @returns {OneOf} Created oneof\n * @throws {TypeError} If arguments are invalid\n */ OneOf.fromJSON = function fromJSON(name, json) {\n    return new OneOf(name, json.oneof, json.options, json.comment);\n};\n/**\n * Converts this oneof to a oneof descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IOneOf} Oneof descriptor\n */ OneOf.prototype.toJSON = function toJSON(toJSONOptions) {\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n    return util.toObject([\n        \"options\",\n        this.options,\n        \"oneof\",\n        this.oneof,\n        \"comment\",\n        keepComments ? this.comment : undefined\n    ]);\n};\n/**\n * Adds the fields of the specified oneof to the parent if not already done so.\n * @param {OneOf} oneof The oneof\n * @returns {undefined}\n * @inner\n * @ignore\n */ function addFieldsToParent(oneof) {\n    if (oneof.parent) {\n        for(var i = 0; i < oneof.fieldsArray.length; ++i)if (!oneof.fieldsArray[i].parent) oneof.parent.add(oneof.fieldsArray[i]);\n    }\n}\n/**\n * Adds a field to this oneof and removes it from its current parent, if any.\n * @param {Field} field Field to add\n * @returns {OneOf} `this`\n */ OneOf.prototype.add = function add(field) {\n    /* istanbul ignore if */ if (!(field instanceof Field)) throw TypeError(\"field must be a Field\");\n    if (field.parent && field.parent !== this.parent) field.parent.remove(field);\n    this.oneof.push(field.name);\n    this.fieldsArray.push(field);\n    field.partOf = this; // field.parent remains null\n    addFieldsToParent(this);\n    return this;\n};\n/**\n * Removes a field from this oneof and puts it back to the oneof's parent.\n * @param {Field} field Field to remove\n * @returns {OneOf} `this`\n */ OneOf.prototype.remove = function remove(field) {\n    /* istanbul ignore if */ if (!(field instanceof Field)) throw TypeError(\"field must be a Field\");\n    var index = this.fieldsArray.indexOf(field);\n    /* istanbul ignore if */ if (index < 0) throw Error(field + \" is not a member of \" + this);\n    this.fieldsArray.splice(index, 1);\n    index = this.oneof.indexOf(field.name);\n    /* istanbul ignore else */ if (index > -1) this.oneof.splice(index, 1);\n    field.partOf = null;\n    return this;\n};\n/**\n * @override\n */ OneOf.prototype.onAdd = function onAdd(parent) {\n    ReflectionObject.prototype.onAdd.call(this, parent);\n    var self = this;\n    // Collect present fields\n    for(var i = 0; i < this.oneof.length; ++i){\n        var field = parent.get(this.oneof[i]);\n        if (field && !field.partOf) {\n            field.partOf = self;\n            self.fieldsArray.push(field);\n        }\n    }\n    // Add not yet present fields\n    addFieldsToParent(this);\n};\n/**\n * @override\n */ OneOf.prototype.onRemove = function onRemove(parent) {\n    for(var i = 0, field; i < this.fieldsArray.length; ++i)if ((field = this.fieldsArray[i]).parent) field.parent.remove(field);\n    ReflectionObject.prototype.onRemove.call(this, parent);\n};\n/**\n * Decorator function as returned by {@link OneOf.d} (TypeScript).\n * @typedef OneOfDecorator\n * @type {function}\n * @param {Object} prototype Target prototype\n * @param {string} oneofName OneOf name\n * @returns {undefined}\n */ /**\n * OneOf decorator (TypeScript).\n * @function\n * @param {...string} fieldNames Field names\n * @returns {OneOfDecorator} Decorator function\n * @template T extends string\n */ OneOf.d = function decorateOneOf() {\n    var fieldNames = new Array(arguments.length), index = 0;\n    while(index < arguments.length)fieldNames[index] = arguments[index++];\n    return function oneOfDecorator(prototype, oneofName) {\n        util.decorateType(prototype.constructor).add(new OneOf(oneofName, fieldNames));\n        Object.defineProperty(prototype, oneofName, {\n            get: util.oneOfGetter(fieldNames),\n            set: util.oneOfSetter(fieldNames)\n        });\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL29uZW9mLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLE9BQU9DLE9BQU8sR0FBR0M7QUFFakIsMkJBQTJCO0FBQzNCLElBQUlDLG1CQUFtQkMsbUJBQU9BLENBQUMsZ0VBQVU7QUFDeEMsRUFBQ0YsTUFBTUcsU0FBUyxHQUFHQyxPQUFPQyxNQUFNLENBQUNKLGlCQUFpQkUsU0FBUyxHQUFHRyxXQUFXLEdBQUdOLEtBQUksRUFBR08sU0FBUyxHQUFHO0FBRWhHLElBQUlDLFFBQVFOLG1CQUFPQSxDQUFDLDhEQUFTLEdBQ3pCTyxPQUFRUCxtQkFBT0EsQ0FBQyw0REFBUTtBQUU1Qjs7Ozs7Ozs7O0NBU0MsR0FDRCxTQUFTRixNQUFNVSxJQUFJLEVBQUVDLFVBQVUsRUFBRUMsT0FBTyxFQUFFQyxPQUFPO0lBQzdDLElBQUksQ0FBQ0MsTUFBTUMsT0FBTyxDQUFDSixhQUFhO1FBQzVCQyxVQUFVRDtRQUNWQSxhQUFhSztJQUNqQjtJQUNBZixpQkFBaUJnQixJQUFJLENBQUMsSUFBSSxFQUFFUCxNQUFNRTtJQUVsQyxzQkFBc0IsR0FDdEIsSUFBSSxDQUFFRCxDQUFBQSxlQUFlSyxhQUFhRixNQUFNQyxPQUFPLENBQUNKLFdBQVUsR0FDdEQsTUFBTU8sVUFBVTtJQUVwQjs7O0tBR0MsR0FDRCxJQUFJLENBQUNDLEtBQUssR0FBR1IsY0FBYyxFQUFFLEVBQUUsaUJBQWlCO0lBRWhEOzs7O0tBSUMsR0FDRCxJQUFJLENBQUNTLFdBQVcsR0FBRyxFQUFFLEVBQUUsc0VBQXNFO0lBRTdGOzs7S0FHQyxHQUNELElBQUksQ0FBQ1AsT0FBTyxHQUFHQTtBQUNuQjtBQUVBOzs7OztDQUtDLEdBRUQ7Ozs7OztDQU1DLEdBQ0RiLE1BQU1xQixRQUFRLEdBQUcsU0FBU0EsU0FBU1gsSUFBSSxFQUFFWSxJQUFJO0lBQ3pDLE9BQU8sSUFBSXRCLE1BQU1VLE1BQU1ZLEtBQUtILEtBQUssRUFBRUcsS0FBS1YsT0FBTyxF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SUFDQSw2QkFBNkI7SUFDN0JMLGtCQUFrQixJQUFJO0FBQzFCO0FBRUE7O0NBRUMsR0FDRDVCLE1BQU1HLFNBQVMsQ0FBQ3lDLFFBQVEsR0FBRyxTQUFTQSxTQUFTZixNQUFNO0lBQy9DLElBQUssSUFBSUMsSUFBSSxHQUFHRyxPQUFPSCxJQUFJLElBQUksQ0FBQ1YsV0FBVyxDQUFDVyxNQUFNLEVBQUUsRUFBRUQsRUFDbEQsSUFBSSxDQUFDRyxRQUFRLElBQUksQ0FBQ2IsV0FBVyxDQUFDVSxFQUFFLEVBQUVELE1BQU0sRUFDcENJLE1BQU1KLE1BQU0sQ0FBQ0ssTUFBTSxDQUFDRDtJQUM1QmhDLGlCQUFpQkUsU0FBUyxDQUFDeUMsUUFBUSxDQUFDM0IsSUFBSSxDQUFDLElBQUksRUFBRVk7QUFDbkQ7QUFFQTs7Ozs7OztDQU9DLEdBRUQ7Ozs7OztDQU1DLEdBQ0Q3QixNQUFNNkMsQ0FBQyxHQUFHLFNBQVNDO0lBQ2YsSUFBSW5DLGFBQWEsSUFBSUcsTUFBTWlDLFVBQVVoQixNQUFNLEdBQ3ZDTSxRQUFRO0lBQ1osTUFBT0EsUUFBUVUsVUFBVWhCLE1BQU0sQ0FDM0JwQixVQUFVLENBQUMwQixNQUFNLEdBQUdVLFNBQVMsQ0FBQ1YsUUFBUTtJQUMxQyxPQUFPLFNBQVNXLGVBQWU3QyxTQUFTLEVBQUU4QyxTQUFTO1FBQy9DeEMsS0FBS3lDLFlBQVksQ0FBQy9DLFVBQVVHLFdBQVcsRUFDbEMwQixHQUFHLENBQUMsSUFBSWhDLE1BQU1pRCxXQUFXdEM7UUFDOUJQLE9BQU8rQyxjQUFjLENBQUNoRCxXQUFXOEMsV0FBVztZQUN4Q04sS0FBS2xDLEtBQUsyQyxXQUFXLENBQUN6QztZQUN0QjBDLEtBQUs1QyxLQUFLNkMsV0FBVyxDQUFDM0M7UUFDMUI7SUFDSjtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9vbmVvZi5qcz9iZDI4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBPbmVPZjtcblxuLy8gZXh0ZW5kcyBSZWZsZWN0aW9uT2JqZWN0XG52YXIgUmVmbGVjdGlvbk9iamVjdCA9IHJlcXVpcmUoXCIuL29iamVjdFwiKTtcbigoT25lT2YucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShSZWZsZWN0aW9uT2JqZWN0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gT25lT2YpLmNsYXNzTmFtZSA9IFwiT25lT2ZcIjtcblxudmFyIEZpZWxkID0gcmVxdWlyZShcIi4vZmllbGRcIiksXG4gICAgdXRpbCAgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgb25lb2YgaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIFJlZmxlY3RlZCBvbmVvZi5cbiAqIEBleHRlbmRzIFJlZmxlY3Rpb25PYmplY3RcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgT25lb2YgbmFtZVxuICogQHBhcmFtIHtzdHJpbmdbXXxPYmplY3QuPHN0cmluZywqPn0gW2ZpZWxkTmFtZXNdIEZpZWxkIG5hbWVzXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBbb3B0aW9uc10gRGVjbGFyZWQgb3B0aW9uc1xuICogQHBhcmFtIHtzdHJpbmd9IFtjb21tZW50XSBDb21tZW50IGFzc29jaWF0ZWQgd2l0aCB0aGlzIGZpZWxkXG4gKi9cbmZ1bmN0aW9uIE9uZU9mKG5hbWUsIGZpZWxkTmFtZXMsIG9wdGlvbnMsIGNvbW1lbnQpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZmllbGROYW1lcykpIHtcbiAgICAgICAgb3B0aW9ucyA9IGZpZWxkTmFtZXM7XG4gICAgICAgIGZpZWxkTmFtZXMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIFJlZmxlY3Rpb25PYmplY3QuY2FsbCh0aGlzLCBuYW1lLCBvcHRpb25zKTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghKGZpZWxkTmFtZXMgPT09IHVuZGVmaW5lZCB8fCBBcnJheS5pc0FycmF5KGZpZWxkTmFtZXMpKSlcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiZmllbGROYW1lcyBtdXN0IGJlIGFuIEFycmF5XCIpO1xuXG4gICAgLyoqXG4gICAgICogRmllbGQgbmFtZXMgdGhhdCBiZWxvbmcgdG8gdGhpcyBvbmVvZi5cbiAgICAgKiBAdHlwZSB7c3RyaW5nW119XG4gICAgICovXG4gICAgdGhpcy5vbmVvZiA9IGZpZWxkTmFtZXMgfHwgW107IC8vIHRvSlNPTiwgbWFya2VyXG5cbiAgICAvKipcbiAgICAgKiBGaWVsZHMgdGhhdCBiZWxvbmcgdG8gdGhpcyBvbmVvZiBhcyBhbiBhcnJheSBmb3IgaXRlcmF0aW9uLlxuICAgICAqIEB0eXBlIHtGaWVsZFtdfVxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIHRoaXMuZmllbGRzQXJyYXkgPSBbXTsgLy8gZGVjbGFyZWQgcmVhZG9ubHkgZm9yIGNvbmZvcm1hbmNlLCBwb3NzaWJseSBub3QgeWV0IGFkZGVkIHRvIHBhcmVudFxuXG4gICAgLyoqXG4gICAgICogQ29tbWVudCBmb3IgdGhpcyBmaWVsZC5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5jb21tZW50ID0gY29tbWVudDtcbn1cblxuLyoqXG4gKiBPbmVvZiBkZXNjcmlwdG9yLlxuICogQGludGVyZmFjZSBJT25lT2ZcbiAqIEBwcm9wZXJ0eSB7QXJyYXkuPHN0cmluZz59IG9uZW9mIE9uZW9mIGZpZWxkIG5hbWVzXG4gKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLCo+fSBbb3B0aW9uc10gT25lb2Ygb3B0aW9uc1xuICovXG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG9uZW9mIGZyb20gYSBvbmVvZiBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgT25lb2YgbmFtZVxuICogQHBhcmFtIHtJT25lT2Z9IGpzb24gT25lb2YgZGVzY3JpcHRvclxuICogQHJldHVybnMge09uZU9mfSBDcmVhdGVkIG9uZW9mXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGFyZ3VtZW50cyBhcmUgaW52YWxpZFxuICovXG5PbmVPZi5mcm9tSlNPTiA9IGZ1bmN0aW9uIGZyb21KU09OKG5hbWUsIGpzb24pIHtcbiAgICByZXR1cm4gbmV3IE9uZU9mKG5hbWUsIGpzb24ub25lb2YsIGpzb24ub3B0aW9ucywganNvbi5jb21tZW50KTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBvbmVvZiB0byBhIG9uZW9mIGRlc2NyaXB0b3IuXG4gKiBAcGFyYW0ge0lUb0pTT05PcHRpb25zfSBbdG9KU09OT3B0aW9uc10gSlNPTiBjb252ZXJzaW9uIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtJT25lT2Z9IE9uZW9mIGRlc2NyaXB0b3JcbiAqL1xuT25lT2YucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTih0b0pTT05PcHRpb25zKSB7XG4gICAgdmFyIGtlZXBDb21tZW50cyA9IHRvSlNPTk9wdGlvbnMgPyBCb29sZWFuKHRvSlNPTk9wdGlvbnMua2VlcENvbW1lbnRzKSA6IGZhbHNlO1xuICAgIHJldHVybiB1dGlsLnRvT2JqZWN0KFtcbiAgICAgICAgXCJvcHRpb25zXCIgLCB0aGlzLm9wdGlvbnMsXG4gICAgICAgIFwib25lb2ZcIiAgICwgdGhpcy5vbmVvZixcbiAgICAgICAgXCJjb21tZW50XCIgLCBrZWVwQ29tbWVudHMgPyB0aGlzLmNvbW1lbnQgOiB1bmRlZmluZWRcbiAgICBdKTtcbn07XG5cbi8qKlxuICogQWRkcyB0aGUgZmllbGRzIG9mIHRoZSBzcGVjaWZpZWQgb25lb2YgdG8gdGhlIHBhcmVudCBpZiBub3QgYWxyZWFkeSBkb25lIHNvLlxuICogQHBhcmFtIHtPbmVPZn0gb25lb2YgVGhlIG9uZW9mXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICogQGlubmVyXG4gKiBAaWdub3JlXG4gKi9cbmZ1bmN0aW9uIGFkZEZpZWxkc1RvUGFyZW50KG9uZW9mKSB7XG4gICAgaWYgKG9uZW9mLnBhcmVudClcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvbmVvZi5maWVsZHNBcnJheS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIGlmICghb25lb2YuZmllbGRzQXJyYXlbaV0ucGFyZW50KVxuICAgICAgICAgICAgICAgIG9uZW9mLnBhcmVudC5hZGQob25lb2YuZmllbGRzQXJyYXlbaV0pO1xufVxuXG4vKipcbiAqIEFkZHMgYSBmaWVsZCB0byB0aGlzIG9uZW9mIGFuZCByZW1vdmVzIGl0IGZyb20gaXRzIGN1cnJlbnQgcGFyZW50LCBpZiBhbnkuXG4gKiBAcGFyYW0ge0ZpZWxkfSBmaWVsZCBGaWVsZCB0byBhZGRcbiAqIEByZXR1cm5zIHtPbmVPZn0gYHRoaXNgXG4gKi9cbk9uZU9mLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQoZmllbGQpIHtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghKGZpZWxkIGluc3RhbmNlb2YgRmllbGQpKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJmaWVsZCBtdXN0IGJlIGEgRmllbGRcIik7XG5cbiAgICBpZiAoZmllbGQucGFyZW50ICYmIGZpZWxkLnBhcmVudCAhPT0gdGhpcy5wYXJlbnQpXG4gICAgICAgIGZpZWxkLnBhcmVudC5yZW1vdmUoZmllbGQpO1xuICAgIHRoaXMub25lb2YucHVzaChmaWVsZC5uYW1lKTtcbiAgICB0aGlzLmZpZWxkc0FycmF5LnB1c2goZmllbGQpO1xuICAgIGZpZWxkLnBhcnRPZiA9IHRoaXM7IC8vIGZpZWxkLnBhcmVudCByZW1haW5zIG51bGxcbiAgICBhZGRGaWVsZHNUb1BhcmVudCh0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhIGZpZWxkIGZyb20gdGhpcyBvbmVvZiBhbmQgcHV0cyBpdCBiYWNrIHRvIHRoZSBvbmVvZidzIHBhcmVudC5cbiAqIEBwYXJhbSB7RmllbGR9IGZpZWxkIEZpZWxkIHRvIHJlbW92ZVxuICogQHJldHVybnMge09uZU9mfSBgdGhpc2BcbiAqL1xuT25lT2YucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShmaWVsZCkge1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCEoZmllbGQgaW5zdGFuY2VvZiBGaWVsZCkpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcImZpZWxkIG11c3QgYmUgYSBGaWVsZFwiKTtcblxuICAgIHZhciBpbmRleCA9IHRoaXMuZmllbGRzQXJyYXkuaW5kZXhPZihmaWVsZCk7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaW5kZXggPCAwKVxuICAgICAgICB0aHJvdyBFcnJvcihmaWVsZCArIFwiIGlzIG5vdCBhIG1lbWJlciBvZiBcIiArIHRoaXMpO1xuXG4gICAgdGhpcy5maWVsZHNBcnJheS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIGluZGV4ID0gdGhpcy5vbmVvZi5pbmRleE9mKGZpZWxkLm5hbWUpO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoaW5kZXggPiAtMSkgLy8gdGhlb3JldGljYWxcbiAgICAgICAgdGhpcy5vbmVvZi5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gICAgZmllbGQucGFydE9mID0gbnVsbDtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cbk9uZU9mLnByb3RvdHlwZS5vbkFkZCA9IGZ1bmN0aW9uIG9uQWRkKHBhcmVudCkge1xuICAgIFJlZmxlY3Rpb25PYmplY3QucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcywgcGFyZW50KTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgLy8gQ29sbGVjdCBwcmVzZW50IGZpZWxkc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5vbmVvZi5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgZmllbGQgPSBwYXJlbnQuZ2V0KHRoaXMub25lb2ZbaV0pO1xuICAgICAgICBpZiAoZmllbGQgJiYgIWZpZWxkLnBhcnRPZikge1xuICAgICAgICAgICAgZmllbGQucGFydE9mID0gc2VsZjtcbiAgICAgICAgICAgIHNlbGYuZmllbGRzQXJyYXkucHVzaChmaWVsZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQWRkIG5vdCB5ZXQgcHJlc2VudCBmaWVsZHNcbiAgICBhZGRGaWVsZHNUb1BhcmVudCh0aGlzKTtcbn07XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cbk9uZU9mLnByb3RvdHlwZS5vblJlbW92ZSA9IGZ1bmN0aW9uIG9uUmVtb3ZlKHBhcmVudCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBmaWVsZDsgaSA8IHRoaXMuZmllbGRzQXJyYXkubGVuZ3RoOyArK2kpXG4gICAgICAgIGlmICgoZmllbGQgPSB0aGlzLmZpZWxkc0FycmF5W2ldKS5wYXJlbnQpXG4gICAgICAgICAgICBmaWVsZC5wYXJlbnQucmVtb3ZlKGZpZWxkKTtcbiAgICBSZWZsZWN0aW9uT2JqZWN0LnByb3RvdHlwZS5vblJlbW92ZS5jYWxsKHRoaXMsIHBhcmVudCk7XG59O1xuXG4vKipcbiAqIERlY29yYXRvciBmdW5jdGlvbiBhcyByZXR1cm5lZCBieSB7QGxpbmsgT25lT2YuZH0gKFR5cGVTY3JpcHQpLlxuICogQHR5cGVkZWYgT25lT2ZEZWNvcmF0b3JcbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b3R5cGUgVGFyZ2V0IHByb3RvdHlwZVxuICogQHBhcmFtIHtzdHJpbmd9IG9uZW9mTmFtZSBPbmVPZiBuYW1lXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5cbi8qKlxuICogT25lT2YgZGVjb3JhdG9yIChUeXBlU2NyaXB0KS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHsuLi5zdHJpbmd9IGZpZWxkTmFtZXMgRmllbGQgbmFtZXNcbiAqIEByZXR1cm5zIHtPbmVPZkRlY29yYXRvcn0gRGVjb3JhdG9yIGZ1bmN0aW9uXG4gKiBAdGVtcGxhdGUgVCBleHRlbmRzIHN0cmluZ1xuICovXG5PbmVPZi5kID0gZnVuY3Rpb24gZGVjb3JhdGVPbmVPZigpIHtcbiAgICB2YXIgZmllbGROYW1lcyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKSxcbiAgICAgICAgaW5kZXggPSAwO1xuICAgIHdoaWxlIChpbmRleCA8IGFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICAgIGZpZWxkTmFtZXNbaW5kZXhdID0gYXJndW1lbnRzW2luZGV4KytdO1xuICAgIHJldHVybiBmdW5jdGlvbiBvbmVPZkRlY29yYXRvcihwcm90b3R5cGUsIG9uZW9mTmFtZSkge1xuICAgICAgICB1dGlsLmRlY29yYXRlVHlwZShwcm90b3R5cGUuY29uc3RydWN0b3IpXG4gICAgICAgICAgICAuYWRkKG5ldyBPbmVPZihvbmVvZk5hbWUsIGZpZWxkTmFtZXMpKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvdHlwZSwgb25lb2ZOYW1lLCB7XG4gICAgICAgICAgICBnZXQ6IHV0aWwub25lT2ZHZXR0ZXIoZmllbGROYW1lcyksXG4gICAgICAgICAgICBzZXQ6IHV0aWwub25lT2ZTZXR0ZXIoZmllbGROYW1lcylcbiAgICAgICAgfSk7XG4gICAgfTtcbn07XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsIk9uZU9mIiwiUmVmbGVjdGlvbk9iamVjdCIsInJlcXVpcmUiLCJwcm90b3R5cGUiLCJPYmplY3QiLCJjcmVhdGUiLCJjb25zdHJ1Y3RvciIsImNsYXNzTmFtZSIsIkZpZWxkIiwidXRpbCIsIm5hbWUiLCJmaWVsZE5hbWVzIiwib3B0aW9ucyIsImNvbW1lbnQiLCJBcnJheSIsImlzQXJyYXkiLCJ1bmRlZmluZWQiLCJjYWxsIiwiVHlwZUVycm9yIiwib25lb2YiLCJmaWVsZHNBcnJheSIsImZyb21KU09OIiwianNvbiIsInRvSlNPTiIsInRvSlNPTk9wdGlvbnMiLCJrZWVwQ29tbWVudHMiLCJCb29sZWFuIiwidG9PYmplY3QiLCJhZGRGaWVsZHNUb1BhcmVudCIsInBhcmVudCIsImkiLCJsZW5ndGgiLCJhZGQiLCJmaWVsZCIsInJlbW92ZSIsInB1c2giLCJwYXJ0T2YiLCJpbmRleCIsImluZGV4T2YiLCJFcnJvciIsInNwbGljZSIsIm9uQWRkIiwic2VsZiIsImdldCIsIm9uUmVtb3ZlIiwiZCIsImRlY29yYXRlT25lT2YiLCJhcmd1bWVudHMiLCJvbmVPZkRlY29yYXRvciIsIm9uZW9mTmFtZSIsImRlY29yYXRlVHlwZSIsImRlZmluZVByb3BlcnR5Iiwib25lT2ZHZXR0ZXIiLCJzZXQiLCJvbmVPZlNldHRlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/protobufjs/src/oneof.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/src/parse.js":
/*!***********************************************!*\
  !*** ../node_modules/protobufjs/src/parse.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = parse;\nparse.filename = null;\nparse.defaults = {\n    keepCase: false\n};\nvar tokenize = __webpack_require__(/*! ./tokenize */ \"(ssr)/../node_modules/protobufjs/src/tokenize.js\"), Root = __webpack_require__(/*! ./root */ \"(ssr)/../node_modules/protobufjs/src/root.js\"), Type = __webpack_require__(/*! ./type */ \"(ssr)/../node_modules/protobufjs/src/type.js\"), Field = __webpack_require__(/*! ./field */ \"(ssr)/../node_modules/protobufjs/src/field.js\"), MapField = __webpack_require__(/*! ./mapfield */ \"(ssr)/../node_modules/protobufjs/src/mapfield.js\"), OneOf = __webpack_require__(/*! ./oneof */ \"(ssr)/../node_modules/protobufjs/src/oneof.js\"), Enum = __webpack_require__(/*! ./enum */ \"(ssr)/../node_modules/protobufjs/src/enum.js\"), Service = __webpack_require__(/*! ./service */ \"(ssr)/../node_modules/protobufjs/src/service.js\"), Method = __webpack_require__(/*! ./method */ \"(ssr)/../node_modules/protobufjs/src/method.js\"), types = __webpack_require__(/*! ./types */ \"(ssr)/../node_modules/protobufjs/src/types.js\"), util = __webpack_require__(/*! ./util */ \"(ssr)/../node_modules/protobufjs/src/util.js\");\nvar base10Re = /^[1-9][0-9]*$/, base10NegRe = /^-?[1-9][0-9]*$/, base16Re = /^0[x][0-9a-fA-F]+$/, base16NegRe = /^-?0[x][0-9a-fA-F]+$/, base8Re = /^0[0-7]+$/, base8NegRe = /^-?0[0-7]+$/, numberRe = /^(?![eE])[0-9]*(?:\\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/, nameRe = /^[a-zA-Z_][a-zA-Z_0-9]*$/, typeRefRe = /^(?:\\.?[a-zA-Z_][a-zA-Z_0-9]*)(?:\\.[a-zA-Z_][a-zA-Z_0-9]*)*$/, fqTypeRefRe = /^(?:\\.[a-zA-Z_][a-zA-Z_0-9]*)+$/;\n/**\n * Result object returned from {@link parse}.\n * @interface IParserResult\n * @property {string|undefined} package Package name, if declared\n * @property {string[]|undefined} imports Imports, if any\n * @property {string[]|undefined} weakImports Weak imports, if any\n * @property {string|undefined} syntax Syntax, if specified (either `\"proto2\"` or `\"proto3\"`)\n * @property {Root} root Populated root instance\n */ /**\n * Options modifying the behavior of {@link parse}.\n * @interface IParseOptions\n * @property {boolean} [keepCase=false] Keeps field casing instead of converting to camel case\n * @property {boolean} [alternateCommentMode=false] Recognize double-slash comments in addition to doc-block comments.\n * @property {boolean} [preferTrailingComment=false] Use trailing comment when both leading comment and trailing comment exist.\n */ /**\n * Options modifying the behavior of JSON serialization.\n * @interface IToJSONOptions\n * @property {boolean} [keepComments=false] Serializes comments.\n */ /**\n * Parses the given .proto source and returns an object with the parsed contents.\n * @param {string} source Source contents\n * @param {Root} root Root to populate\n * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.\n * @returns {IParserResult} Parser result\n * @property {string} filename=null Currently processing file name for error reporting, if known\n * @property {IParseOptions} defaults Default {@link IParseOptions}\n */ function parse(source, root, options) {\n    /* eslint-disable callback-return */ if (!(root instanceof Root)) {\n        options = root;\n        root = new Root();\n    }\n    if (!options) options = parse.defaults;\n    var preferTrailingComment = options.preferTrailingComment || false;\n    var tn = tokenize(source, options.alternateCommentMode || false), next = tn.next, push = tn.push, peek = tn.peek, skip = tn.skip, cmnt = tn.cmnt;\n    var head = true, pkg, imports, weakImports, syntax, isProto3 = false;\n    var ptr = root;\n    var applyCase = options.keepCase ? function(name) {\n        return name;\n    } : util.camelCase;\n    /* istanbul ignore next */ function illegal(token, name, insideTryCatch) {\n        var filename = parse.filename;\n        if (!insideTryCatch) parse.filename = null;\n        return Error(\"illegal \" + (name || \"token\") + \" '\" + token + \"' (\" + (filename ? filename + \", \" : \"\") + \"line \" + tn.line + \")\");\n    }\n    function readString() {\n        var values = [], token;\n        do {\n            /* istanbul ignore if */ if ((token = next()) !== '\"' && token !== \"'\") throw illegal(token);\n            values.push(next());\n            skip(token);\n            token = peek();\n        }while (token === '\"' || token === \"'\");\n        return values.join(\"\");\n    }\n    function readValue(acceptTypeRef) {\n        var token = next();\n        switch(token){\n            case \"'\":\n            case '\"':\n                push(token);\n                return readString();\n            case \"true\":\n            case \"TRUE\":\n                return true;\n            case \"false\":\n            case \"FALSE\":\n                return false;\n        }\n        try {\n            return parseNumber(token, /* insideTryCatch */ true);\n        } catch (e) {\n            /* istanbul ignore else */ if (acceptTypeRef && typeRefRe.test(token)) return token;\n            /* istanbul ignore next */ throw illegal(token, \"value\");\n        }\n    }\n    function readRanges(target, acceptStrings) {\n        var token, start;\n        do {\n            if (acceptStrings && ((token = peek()) === '\"' || token === \"'\")) target.push(readString());\n            else target.push([\n                start = parseId(next()),\n                skip(\"to\", true) ? parseId(next()) : start\n            ]);\n        }while (skip(\",\", true));\n        skip(\";\");\n    }\n    function parseNumber(token, insideTryCatch) {\n        var sign = 1;\n        if (token.charAt(0) === \"-\") {\n            sign = -1;\n            token = token.substring(1);\n        }\n        switch(token){\n            case \"inf\":\n            case \"INF\":\n            case \"Inf\":\n                return sign * Infinity;\n            case \"nan\":\n            case \"NAN\":\n            case \"Nan\":\n            case \"NaN\":\n                return NaN;\n            case \"0\":\n                return 0;\n        }\n        if (base10Re.test(token)) return sign * parseInt(token, 10);\n        if (base16Re.test(token)) return sign * parseInt(token, 16);\n        if (base8Re.test(token)) return sign * parseInt(token, 8);\n        /* istanbul ignore else */ if (numberRe.test(token)) return sign * parseFloat(token);\n        /* istanbul ignore next */ throw illegal(token, \"number\", insideTryCatch);\n    }\n    function parseId(token, acceptNegative) {\n        switch(token){\n            case \"max\":\n            case \"MAX\":\n            case \"Max\":\n                return 536870911;\n            case \"0\":\n                return 0;\n        }\n        /* istanbul ignore if */ if (!acceptNegative && token.charAt(0) === \"-\") throw illegal(token, \"id\");\n        if (base10NegRe.test(token)) return parseInt(token, 10);\n        if (base16NegRe.test(token)) return parseInt(token, 16);\n        /* istanbul ignore else */ if (base8NegRe.test(token)) return parseInt(token, 8);\n        /* istanbul ignore next */ throw illegal(token, \"id\");\n    }\n    function parsePackage() {\n        /* istanbul ignore if */ if (pkg !== undefined) throw illegal(\"package\");\n        pkg = next();\n        /* istanbul ignore if */ if (!typeRefRe.test(pkg)) throw illegal(pkg, \"name\");\n        ptr = ptr.define(pkg);\n        skip(\";\");\n    }\n    function parseImport() {\n        var token = peek();\n        var whichImports;\n        switch(token){\n            case \"weak\":\n                whichImports = weakImports || (weakImports = []);\n                next();\n                break;\n            case \"public\":\n                next();\n            // eslint-disable-next-line no-fallthrough\n            default:\n                whichImports = imports || (imports = []);\n                break;\n        }\n        token = readString();\n        skip(\";\");\n        whichImports.push(token);\n    }\n    function parseSyntax() {\n        skip(\"=\");\n        syntax = readString();\n        isProto3 = syntax === \"proto3\";\n        /* istanbul ignore if */ if (!isProto3 && syntax !== \"proto2\") throw illegal(syntax, \"syntax\");\n        skip(\";\");\n    }\n    function parseCommon(parent, token) {\n        switch(token){\n            case \"option\":\n                parseOption(parent, token);\n                skip(\";\");\n                return true;\n            case \"message\":\n                parseType(parent, token);\n                return true;\n            case \"enum\":\n                parseEnum(parent, token);\n                return true;\n            case \"service\":\n                parseService(parent, token);\n                return true;\n            case \"extend\":\n                parseExtension(parent, token);\n                return true;\n        }\n        return false;\n    }\n    function ifBlock(obj, fnIf, fnElse) {\n        var trailingLine = tn.line;\n        if (obj) {\n            if (typeof obj.comment !== \"string\") {\n                obj.comment = cmnt(); // try block-type comment\n            }\n            obj.filename = parse.filename;\n        }\n        if (skip(\"{\", true)) {\n            var token;\n            while((token = next()) !== \"}\")fnIf(token);\n            skip(\";\", true);\n        } else {\n            if (fnElse) fnElse();\n            skip(\";\");\n            if (obj && (typeof obj.comment !== \"string\" || preferTrailingComment)) obj.comment = cmnt(trailingLine) || obj.comment; // try line-type comment\n        }\n    }\n    function parseType(parent, token) {\n        /* istanbul ignore if */ if (!nameRe.test(token = next())) throw illegal(token, \"type name\");\n        var type = new Type(token);\n        ifBlock(type, function parseType_block(token) {\n            if (parseCommon(type, token)) return;\n            switch(token){\n                case \"map\":\n                    parseMapField(type, token);\n                    break;\n                case \"required\":\n                case \"repeated\":\n                    parseField(type, token);\n                    break;\n                case \"optional\":\n                    /* istanbul ignore if */ if (isProto3) {\n                        parseField(type, \"proto3_optional\");\n                    } else {\n                        parseField(type, \"optional\");\n                    }\n                    break;\n                case \"oneof\":\n                    parseOneOf(type, token);\n                    break;\n                case \"extensions\":\n                    readRanges(type.extensions || (type.extensions = []));\n                    break;\n                case \"reserved\":\n                    readRanges(type.reserved || (type.reserved = []), true);\n                    break;\n                default:\n                    /* istanbul ignore if */ if (!isProto3 || !typeRefRe.test(token)) throw illegal(token);\n                    push(token);\n                    parseField(type, \"optional\");\n                    break;\n            }\n        });\n        parent.add(type);\n    }\n    function parseField(parent, rule, extend) {\n        var type = next();\n        if (type === \"group\") {\n            parseGroup(parent, rule);\n            return;\n        }\n        // Type names can consume multiple tokens, in multiple variants:\n        //    package.subpackage   field       tokens: \"package.subpackage\" [TYPE NAME ENDS HERE] \"field\"\n        //    package . subpackage field       tokens: \"package\" \".\" \"subpackage\" [TYPE NAME ENDS HERE] \"field\"\n        //    package.  subpackage field       tokens: \"package.\" \"subpackage\" [TYPE NAME ENDS HERE] \"field\"\n        //    package  .subpackage field       tokens: \"package\" \".subpackage\" [TYPE NAME ENDS HERE] \"field\"\n        // Keep reading tokens until we get a type name with no period at the end,\n        // and the next token does not start with a period.\n        while(type.endsWith(\".\") || peek().startsWith(\".\")){\n            type += next();\n        }\n        /* istanbul ignore if */ if (!typeRefRe.test(type)) throw illegal(type, \"type\");\n        var name = next();\n        /* istanbul ignore if */ if (!nameRe.test(name)) throw illegal(name, \"name\");\n        name = applyCase(name);\n        skip(\"=\");\n        var field = new Field(name, parseId(next()), type, rule, extend);\n        ifBlock(field, function parseField_block(token) {\n            /* istanbul ignore else */ if (token === \"option\") {\n                parseOption(field, token);\n                skip(\";\");\n            } else throw illegal(token);\n        }, function parseField_line() {\n            parseInlineOptions(field);\n        });\n        if (rule === \"proto3_optional\") {\n            // for proto3 optional fields, we create a single-member Oneof to mimic \"optional\" behavior\n            var oneof = new OneOf(\"_\" + name);\n            field.setOption(\"proto3_optional\", true);\n            oneof.add(field);\n            parent.add(oneof);\n        } else {\n            parent.add(field);\n        }\n        // JSON defaults to packed=true if not set so we have to set packed=false explicity when\n        // parsing proto2 descriptors without the option, where applicable. This must be done for\n        // all known packable types and anything that could be an enum (= is not a basic type).\n        if (!isProto3 && field.repeated && (types.packed[type] !== undefined || types.basic[type] === undefined)) field.setOption(\"packed\", false, /* ifNotSet */ true);\n    }\n    function parseGroup(parent, rule) {\n        var name = next();\n        /* istanbul ignore if */ if (!nameRe.test(name)) throw illegal(name, \"name\");\n        var fieldName = util.lcFirst(name);\n        if (name === fieldName) name = util.ucFirst(name);\n        skip(\"=\");\n        var id = parseId(next());\n        var type = new Type(name);\n        type.group = true;\n        var field = new Field(fieldName, id, name, rule);\n        field.filename = parse.filename;\n        ifBlock(type, function parseGroup_block(token) {\n            switch(token){\n                case \"option\":\n                    parseOption(type, token);\n                    skip(\";\");\n                    break;\n                case \"required\":\n                case \"repeated\":\n                    parseField(type, token);\n                    break;\n                case \"optional\":\n                    /* istanbul ignore if */ if (isProto3) {\n                        parseField(type, \"proto3_optional\");\n                    } else {\n                        parseField(type, \"optional\");\n                    }\n                    break;\n                case \"message\":\n                    parseType(type, token);\n                    break;\n                case \"enum\":\n                    parseEnum(type, token);\n                    break;\n                /* istanbul ignore next */ default:\n                    throw illegal(token); // there are no groups with proto3 semantics\n            }\n        });\n        parent.add(type).add(field);\n    }\n    function parseMapField(parent) {\n        skip(\"<\");\n        var keyType = next();\n        /* istanbul ignore if */ if (types.mapKey[keyType] === undefined) throw illegal(keyType, \"type\");\n        skip(\",\");\n        var valueType = next();\n        /* istanbul ignore if */ if (!typeRefRe.test(valueType)) throw illegal(valueType, \"type\");\n        skip(\">\");\n        var name = next();\n        /* istanbul ignore if */ if (!nameRe.test(name)) throw illegal(name, \"name\");\n        skip(\"=\");\n        var field = new MapField(applyCase(name), parseId(next()), keyType, valueType);\n        ifBlock(field, function parseMapField_block(token) {\n            /* istanbul ignore else */ if (token === \"option\") {\n                parseOption(field, token);\n                skip(\";\");\n            } else throw illegal(token);\n        }, function parseMapField_line() {\n            parseInlineOptions(field);\n        });\n        parent.add(field);\n    }\n    function parseOneOf(parent, token) {\n        /* istanbul ignore if */ if (!nameRe.test(token = next())) throw illegal(token, \"name\");\n        var oneof = new OneOf(applyCase(token));\n        ifBlock(oneof, function parseOneOf_block(token) {\n            if (token === \"option\") {\n                parseOption(oneof, token);\n                skip(\";\");\n            } else {\n                push(token);\n                parseField(oneof, \"optional\");\n            }\n        });\n        parent.add(oneof);\n    }\n    function parseEnum(parent, token) {\n        /* istanbul ignore if */ if (!nameRe.test(token = next())) throw illegal(token, \"name\");\n        var enm = new Enum(token);\n        ifBlock(enm, function parseEnum_block(token) {\n            switch(token){\n                case \"option\":\n                    parseOption(enm, token);\n                    skip(\";\");\n                    break;\n                case \"reserved\":\n                    readRanges(enm.reserved || (enm.reserved = []), true);\n                    break;\n                default:\n                    parseEnumValue(enm, token);\n            }\n        });\n        parent.add(enm);\n    }\n    function parseEnumValue(parent, token) {\n        /* istanbul ignore if */ if (!nameRe.test(token)) throw illegal(token, \"name\");\n        skip(\"=\");\n        var value = parseId(next(), true), dummy = {\n            options: undefined\n        };\n        dummy.setOption = function(name, value) {\n            if (this.options === undefined) this.options = {};\n            this.options[name] = value;\n        };\n        ifBlock(dummy, function parseEnumValue_block(token) {\n            /* istanbul ignore else */ if (token === \"option\") {\n                parseOption(dummy, token); // skip\n                skip(\";\");\n            } else throw illegal(token);\n        }, function parseEnumValue_line() {\n            parseInlineOptions(dummy); // skip\n        });\n        parent.add(token, value, dummy.comment, dummy.options);\n    }\n    function parseOption(parent, token) {\n        var isCustom = skip(\"(\", true);\n        /* istanbul ignore if */ if (!typeRefRe.test(token = next())) throw illegal(token, \"name\");\n        var name = token;\n        var option = name;\n        var propName;\n        if (isCustom) {\n            skip(\")\");\n            name = \"(\" + name + \")\";\n            option = name;\n            token = peek();\n            if (fqTypeRefRe.test(token)) {\n                propName = token.slice(1); //remove '.' before property name\n                name += token;\n                next();\n            }\n        }\n        skip(\"=\");\n        var optionValue = parseOptionValue(parent, name);\n        setParsedOption(parent, option, optionValue, propName);\n    }\n    function parseOptionValue(parent, name) {\n        // { a: \"foo\" b { c: \"bar\" } }\n        if (skip(\"{\", true)) {\n            var objectResult = {};\n            while(!skip(\"}\", true)){\n                /* istanbul ignore if */ if (!nameRe.test(token = next())) {\n                    throw illegal(token, \"name\");\n                }\n                if (token === null) {\n                    throw illegal(token, \"end of input\");\n                }\n                var value;\n                var propName = token;\n                skip(\":\", true);\n                if (peek() === \"{\") value = parseOptionValue(parent, name + \".\" + token);\n                else if (peek() === \"[\") {\n                    // option (my_option) = {\n                    //     repeated_value: [ \"foo\", \"bar\" ]\n                    // };\n                    value = [];\n                    var lastValue;\n                    if (skip(\"[\", true)) {\n                        do {\n                            lastValue = readValue(true);\n                            value.push(lastValue);\n                        }while (skip(\",\", true));\n                        skip(\"]\");\n                        if (typeof lastValue !== \"undefined\") {\n                            setOption(parent, name + \".\" + token, lastValue);\n                        }\n                    }\n                } else {\n                    value = readValue(true);\n                    setOption(parent, name + \".\" + token, value);\n                }\n                var prevValue = objectResult[propName];\n                if (prevValue) value = [].concat(prevValue).concat(value);\n                objectResult[propName] = value;\n                // Semicolons and commas can be optional\n                skip(\",\", true);\n                skip(\";\", true);\n            }\n            return objectResult;\n        }\n        var simpleValue = readValue(true);\n        setOption(parent, name, simpleValue);\n        return simpleValue;\n    // Does not enforce a delimiter to be universal\n    }\n    function setOption(parent, name, value) {\n        if (parent.setOption) parent.setOption(name, value);\n    }\n    function setParsedOption(parent, name, value, propName) {\n        if (parent.setParsedOption) parent.setParsedOption(name, value, propName);\n    }\n    function parseInlineOptions(parent) {\n        if (skip(\"[\", true)) {\n            do {\n                parseOption(parent, \"option\");\n            }while (skip(\",\", true));\n            skip(\"]\");\n        }\n        return parent;\n    }\n    function parseService(parent, token) {\n        /* istanbul ignore if */ if (!nameRe.test(token = next())) throw illegal(token, \"service name\");\n        var service = new Service(token);\n        ifBlock(service, function parseService_block(token) {\n            if (parseCommon(service, token)) return;\n            /* istanbul ignore else */ if (token === \"rpc\") parseMethod(service, token);\n            else throw illegal(token);\n        });\n        parent.add(service);\n    }\n    function parseMethod(parent, token) {\n        // Get the comment of the preceding line now (if one exists) in case the\n        // method is defined across multiple lines.\n        var commentText = cmnt();\n        var type = token;\n        /* istanbul ignore if */ if (!nameRe.test(token = next())) throw illegal(token, \"name\");\n        var name = token, requestType, requestStream, responseType, responseStream;\n        skip(\"(\");\n        if (skip(\"stream\", true)) requestStream = true;\n        /* istanbul ignore if */ if (!typeRefRe.test(token = next())) throw illegal(token);\n        requestType = token;\n        skip(\")\");\n        skip(\"returns\");\n        skip(\"(\");\n        if (skip(\"stream\", true)) responseStream = true;\n        /* istanbul ignore if */ if (!typeRefRe.test(token = next())) throw illegal(token);\n        responseType = token;\n        skip(\")\");\n        var method = new Method(name, type, requestType, responseType, requestStream, responseStream);\n        method.comment = commentText;\n        ifBlock(method, function parseMethod_block(token) {\n            /* istanbul ignore else */ if (token === \"option\") {\n                parseOption(method, token);\n                skip(\";\");\n            } else throw illegal(token);\n        });\n        parent.add(method);\n    }\n    function parseExtension(parent, token) {\n        /* istanbul ignore if */ if (!typeRefRe.test(token = next())) throw illegal(token, \"reference\");\n        var reference = token;\n        ifBlock(null, function parseExtension_block(token) {\n            switch(token){\n                case \"required\":\n                case \"repeated\":\n                    parseField(parent, token, reference);\n                    break;\n                case \"optional\":\n                    /* istanbul ignore if */ if (isProto3) {\n                        parseField(parent, \"proto3_optional\", reference);\n                    } else {\n                        parseField(parent, \"optional\", reference);\n                    }\n                    break;\n                default:\n                    /* istanbul ignore if */ if (!isProto3 || !typeRefRe.test(token)) throw illegal(token);\n                    push(token);\n                    parseField(parent, \"optional\", reference);\n                    break;\n            }\n        });\n    }\n    var token;\n    while((token = next()) !== null){\n        switch(token){\n            case \"package\":\n                /* istanbul ignore if */ if (!head) throw illegal(token);\n                parsePackage();\n                break;\n            case \"import\":\n                /* istanbul ignore if */ if (!head) throw illegal(token);\n                parseImport();\n                break;\n            case \"syntax\":\n                /* istanbul ignore if */ if (!head) throw illegal(token);\n                parseSyntax();\n                break;\n            case \"option\":\n                parseOption(ptr, token);\n                skip(\";\");\n                break;\n            default:\n                /* istanbul ignore else */ if (parseCommon(ptr, token)) {\n                    head = false;\n                    continue;\n                }\n                /* istanbul ignore next */ throw illegal(token);\n        }\n    }\n    parse.filename = null;\n    return {\n        \"package\": pkg,\n        \"imports\": imports,\n        weakImports: weakImports,\n        syntax: syntax,\n        root: root\n    };\n} /**\n * Parses the given .proto source and returns an object with the parsed contents.\n * @name parse\n * @function\n * @param {string} source Source contents\n * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.\n * @returns {IParserResult} Parser result\n * @property {string} filename=null Currently processing file name for error reporting, if known\n * @property {IParseOptions} defaults Default {@link IParseOptions}\n * @variation 2\n */ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3BhcnNlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLE9BQU9DLE9BQU8sR0FBR0M7QUFFakJBLE1BQU1DLFFBQVEsR0FBRztBQUNqQkQsTUFBTUUsUUFBUSxHQUFHO0lBQUVDLFVBQVU7QUFBTTtBQUVuQyxJQUFJQyxXQUFZQyxtQkFBT0EsQ0FBQyxvRUFBWSxHQUNoQ0MsT0FBWUQsbUJBQU9BLENBQUMsNERBQVEsR0FDNUJFLE9BQVlGLG1CQUFPQSxDQUFDLDREQUFRLEdBQzVCRyxRQUFZSCxtQkFBT0EsQ0FBQyw4REFBUyxHQUM3QkksV0FBWUosbUJBQU9BLENBQUMsb0VBQVksR0FDaENLLFFBQVlMLG1CQUFPQSxDQUFDLDhEQUFTLEdBQzdCTSxPQUFZTixtQkFBT0EsQ0FBQyw0REFBUSxHQUM1Qk8sVUFBWVAsbUJBQU9BLENBQUMsa0VBQVcsR0FDL0JRLFNBQVlSLG1CQUFPQSxDQUFDLGdFQUFVLEdBQzlCUyxRQUFZVCxtQkFBT0EsQ0FBQyw4REFBUyxHQUM3QlUsT0FBWVYsbUJBQU9BLENBQUMsNERBQVE7QUFFaEMsSUFBSVcsV0FBYyxpQkFDZEMsY0FBYyxtQkFDZEMsV0FBYyxzQkFDZEMsY0FBYyx3QkFDZEMsVUFBYyxhQUNkQyxhQUFjLGVBQ2RDLFdBQWMscURBQ2RDLFNBQWMsNEJBQ2RDLFlBQWMsZ0VBQ2RDLGNBQWM7QUFFbEI7Ozs7Ozs7O0NBUUMsR0FFRDs7Ozs7O0NBTUMsR0FFRDs7OztDQUlDLEdBRUQ7Ozs7Ozs7O0NBUUMsR0FDRCxTQUFTekIsTUFBTTBCLE1BQU0sRUFBRUMsSUFBSSxFQUFFQyxPQUFPO0lBQ2hDLGtDQUFrQyxHQUNsQyxJQUFJLENBQUVELENBQUFBLGdCQUFnQnJCLElBQUcsR0FBSTtRQUN6QnNCLFVBQVVEO1FBQ1ZBLE9BQU8sSUFBSXJCO0lBQ2Y7SUFDQSxJQUFJLENBQUNzQixTQUNEQSxVQUFVNUIsTUFBTUUsUUFBUTtJQUU1QixJQUFJMkIsd0JBQXdC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Ozs7Ozs7Ozs7O0NBVUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3BhcnNlLmpzPzIzMWIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlO1xuXG5wYXJzZS5maWxlbmFtZSA9IG51bGw7XG5wYXJzZS5kZWZhdWx0cyA9IHsga2VlcENhc2U6IGZhbHNlIH07XG5cbnZhciB0b2tlbml6ZSAgPSByZXF1aXJlKFwiLi90b2tlbml6ZVwiKSxcbiAgICBSb290ICAgICAgPSByZXF1aXJlKFwiLi9yb290XCIpLFxuICAgIFR5cGUgICAgICA9IHJlcXVpcmUoXCIuL3R5cGVcIiksXG4gICAgRmllbGQgICAgID0gcmVxdWlyZShcIi4vZmllbGRcIiksXG4gICAgTWFwRmllbGQgID0gcmVxdWlyZShcIi4vbWFwZmllbGRcIiksXG4gICAgT25lT2YgICAgID0gcmVxdWlyZShcIi4vb25lb2ZcIiksXG4gICAgRW51bSAgICAgID0gcmVxdWlyZShcIi4vZW51bVwiKSxcbiAgICBTZXJ2aWNlICAgPSByZXF1aXJlKFwiLi9zZXJ2aWNlXCIpLFxuICAgIE1ldGhvZCAgICA9IHJlcXVpcmUoXCIuL21ldGhvZFwiKSxcbiAgICB0eXBlcyAgICAgPSByZXF1aXJlKFwiLi90eXBlc1wiKSxcbiAgICB1dGlsICAgICAgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuXG52YXIgYmFzZTEwUmUgICAgPSAvXlsxLTldWzAtOV0qJC8sXG4gICAgYmFzZTEwTmVnUmUgPSAvXi0/WzEtOV1bMC05XSokLyxcbiAgICBiYXNlMTZSZSAgICA9IC9eMFt4XVswLTlhLWZBLUZdKyQvLFxuICAgIGJhc2UxNk5lZ1JlID0gL14tPzBbeF1bMC05YS1mQS1GXSskLyxcbiAgICBiYXNlOFJlICAgICA9IC9eMFswLTddKyQvLFxuICAgIGJhc2U4TmVnUmUgID0gL14tPzBbMC03XSskLyxcbiAgICBudW1iZXJSZSAgICA9IC9eKD8hW2VFXSlbMC05XSooPzpcXC5bMC05XSopPyg/OltlRV1bKy1dP1swLTldKyk/JC8sXG4gICAgbmFtZVJlICAgICAgPSAvXlthLXpBLVpfXVthLXpBLVpfMC05XSokLyxcbiAgICB0eXBlUmVmUmUgICA9IC9eKD86XFwuP1thLXpBLVpfXVthLXpBLVpfMC05XSopKD86XFwuW2EtekEtWl9dW2EtekEtWl8wLTldKikqJC8sXG4gICAgZnFUeXBlUmVmUmUgPSAvXig/OlxcLlthLXpBLVpfXVthLXpBLVpfMC05XSopKyQvO1xuXG4vKipcbiAqIFJlc3VsdCBvYmplY3QgcmV0dXJuZWQgZnJvbSB7QGxpbmsgcGFyc2V9LlxuICogQGludGVyZmFjZSBJUGFyc2VyUmVzdWx0XG4gKiBAcHJvcGVydHkge3N0cmluZ3x1bmRlZmluZWR9IHBhY2thZ2UgUGFja2FnZSBuYW1lLCBpZiBkZWNsYXJlZFxuICogQHByb3BlcnR5IHtzdHJpbmdbXXx1bmRlZmluZWR9IGltcG9ydHMgSW1wb3J0cywgaWYgYW55XG4gKiBAcHJvcGVydHkge3N0cmluZ1tdfHVuZGVmaW5lZH0gd2Vha0ltcG9ydHMgV2VhayBpbXBvcnRzLCBpZiBhbnlcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfHVuZGVmaW5lZH0gc3ludGF4IFN5bnRheCwgaWYgc3BlY2lmaWVkIChlaXRoZXIgYFwicHJvdG8yXCJgIG9yIGBcInByb3RvM1wiYClcbiAqIEBwcm9wZXJ0eSB7Um9vdH0gcm9vdCBQb3B1bGF0ZWQgcm9vdCBpbnN0YW5jZVxuICovXG5cbi8qKlxuICogT3B0aW9ucyBtb2RpZnlpbmcgdGhlIGJlaGF2aW9yIG9mIHtAbGluayBwYXJzZX0uXG4gKiBAaW50ZXJmYWNlIElQYXJzZU9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2tlZXBDYXNlPWZhbHNlXSBLZWVwcyBmaWVsZCBjYXNpbmcgaW5zdGVhZCBvZiBjb252ZXJ0aW5nIHRvIGNhbWVsIGNhc2VcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2FsdGVybmF0ZUNvbW1lbnRNb2RlPWZhbHNlXSBSZWNvZ25pemUgZG91YmxlLXNsYXNoIGNvbW1lbnRzIGluIGFkZGl0aW9uIHRvIGRvYy1ibG9jayBjb21tZW50cy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3ByZWZlclRyYWlsaW5nQ29tbWVudD1mYWxzZV0gVXNlIHRyYWlsaW5nIGNvbW1lbnQgd2hlbiBib3RoIGxlYWRpbmcgY29tbWVudCBhbmQgdHJhaWxpbmcgY29tbWVudCBleGlzdC5cbiAqL1xuXG4vKipcbiAqIE9wdGlvbnMgbW9kaWZ5aW5nIHRoZSBiZWhhdmlvciBvZiBKU09OIHNlcmlhbGl6YXRpb24uXG4gKiBAaW50ZXJmYWNlIElUb0pTT05PcHRpb25zXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtrZWVwQ29tbWVudHM9ZmFsc2VdIFNlcmlhbGl6ZXMgY29tbWVudHMuXG4gKi9cblxuLyoqXG4gKiBQYXJzZXMgdGhlIGdpdmVuIC5wcm90byBzb3VyY2UgYW5kIHJldHVybnMgYW4gb2JqZWN0IHdpdGggdGhlIHBhcnNlZCBjb250ZW50cy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UgU291cmNlIGNvbnRlbnRzXG4gKiBAcGFyYW0ge1Jvb3R9IHJvb3QgUm9vdCB0byBwb3B1bGF0ZVxuICogQHBhcmFtIHtJUGFyc2VPcHRpb25zfSBbb3B0aW9uc10gUGFyc2Ugb3B0aW9ucy4gRGVmYXVsdHMgdG8ge0BsaW5rIHBhcnNlLmRlZmF1bHRzfSB3aGVuIG9taXR0ZWQuXG4gKiBAcmV0dXJucyB7SVBhcnNlclJlc3VsdH0gUGFyc2VyIHJlc3VsdFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGZpbGVuYW1lPW51bGwgQ3VycmVudGx5IHByb2Nlc3NpbmcgZmlsZSBuYW1lIGZvciBlcnJvciByZXBvcnRpbmcsIGlmIGtub3duXG4gKiBAcHJvcGVydHkge0lQYXJzZU9wdGlvbnN9IGRlZmF1bHRzIERlZmF1bHQge0BsaW5rIElQYXJzZU9wdGlvbnN9XG4gKi9cbmZ1bmN0aW9uIHBhcnNlKHNvdXJjZSwgcm9vdCwgb3B0aW9ucykge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIGNhbGxiYWNrLXJldHVybiAqL1xuICAgIGlmICghKHJvb3QgaW5zdGFuY2VvZiBSb290KSkge1xuICAgICAgICBvcHRpb25zID0gcm9vdDtcbiAgICAgICAgcm9vdCA9IG5ldyBSb290KCk7XG4gICAgfVxuICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgb3B0aW9ucyA9IHBhcnNlLmRlZmF1bHRzO1xuXG4gICAgdmFyIHByZWZlclRyYWlsaW5nQ29tbWVudCA9IG9wdGlvbnMucHJlZmVyVHJhaWxpbmdDb21tZW50IHx8IGZhbHNlO1xuICAgIHZhciB0biA9IHRva2VuaXplKHNvdXJjZSwgb3B0aW9ucy5hbHRlcm5hdGVDb21tZW50TW9kZSB8fCBmYWxzZSksXG4gICAgICAgIG5leHQgPSB0bi5uZXh0LFxuICAgICAgICBwdXNoID0gdG4ucHVzaCxcbiAgICAgICAgcGVlayA9IHRuLnBlZWssXG4gICAgICAgIHNraXAgPSB0bi5za2lwLFxuICAgICAgICBjbW50ID0gdG4uY21udDtcblxuICAgIHZhciBoZWFkID0gdHJ1ZSxcbiAgICAgICAgcGtnLFxuICAgICAgICBpbXBvcnRzLFxuICAgICAgICB3ZWFrSW1wb3J0cyxcbiAgICAgICAgc3ludGF4LFxuICAgICAgICBpc1Byb3RvMyA9IGZhbHNlO1xuXG4gICAgdmFyIHB0ciA9IHJvb3Q7XG5cbiAgICB2YXIgYXBwbHlDYXNlID0gb3B0aW9ucy5rZWVwQ2FzZSA/IGZ1bmN0aW9uKG5hbWUpIHsgcmV0dXJuIG5hbWU7IH0gOiB1dGlsLmNhbWVsQ2FzZTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgZnVuY3Rpb24gaWxsZWdhbCh0b2tlbiwgbmFtZSwgaW5zaWRlVHJ5Q2F0Y2gpIHtcbiAgICAgICAgdmFyIGZpbGVuYW1lID0gcGFyc2UuZmlsZW5hbWU7XG4gICAgICAgIGlmICghaW5zaWRlVHJ5Q2F0Y2gpXG4gICAgICAgICAgICBwYXJzZS5maWxlbmFtZSA9IG51bGw7XG4gICAgICAgIHJldHVybiBFcnJvcihcImlsbGVnYWwgXCIgKyAobmFtZSB8fCBcInRva2VuXCIpICsgXCIgJ1wiICsgdG9rZW4gKyBcIicgKFwiICsgKGZpbGVuYW1lID8gZmlsZW5hbWUgKyBcIiwgXCIgOiBcIlwiKSArIFwibGluZSBcIiArIHRuLmxpbmUgKyBcIilcIik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVhZFN0cmluZygpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IFtdLFxuICAgICAgICAgICAgdG9rZW47XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKCh0b2tlbiA9IG5leHQoKSkgIT09IFwiXFxcIlwiICYmIHRva2VuICE9PSBcIidcIilcbiAgICAgICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuKTtcblxuICAgICAgICAgICAgdmFsdWVzLnB1c2gobmV4dCgpKTtcbiAgICAgICAgICAgIHNraXAodG9rZW4pO1xuICAgICAgICAgICAgdG9rZW4gPSBwZWVrKCk7XG4gICAgICAgIH0gd2hpbGUgKHRva2VuID09PSBcIlxcXCJcIiB8fCB0b2tlbiA9PT0gXCInXCIpO1xuICAgICAgICByZXR1cm4gdmFsdWVzLmpvaW4oXCJcIik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVhZFZhbHVlKGFjY2VwdFR5cGVSZWYpIHtcbiAgICAgICAgdmFyIHRva2VuID0gbmV4dCgpO1xuICAgICAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAgICAgICBjYXNlIFwiJ1wiOlxuICAgICAgICAgICAgY2FzZSBcIlxcXCJcIjpcbiAgICAgICAgICAgICAgICBwdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVhZFN0cmluZygpO1xuICAgICAgICAgICAgY2FzZSBcInRydWVcIjogY2FzZSBcIlRSVUVcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGNhc2UgXCJmYWxzZVwiOiBjYXNlIFwiRkFMU0VcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZU51bWJlcih0b2tlbiwgLyogaW5zaWRlVHJ5Q2F0Y2ggKi8gdHJ1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcblxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmIChhY2NlcHRUeXBlUmVmICYmIHR5cGVSZWZSZS50ZXN0KHRva2VuKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG5cbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuLCBcInZhbHVlXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVhZFJhbmdlcyh0YXJnZXQsIGFjY2VwdFN0cmluZ3MpIHtcbiAgICAgICAgdmFyIHRva2VuLCBzdGFydDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKGFjY2VwdFN0cmluZ3MgJiYgKCh0b2tlbiA9IHBlZWsoKSkgPT09IFwiXFxcIlwiIHx8IHRva2VuID09PSBcIidcIikpXG4gICAgICAgICAgICAgICAgdGFyZ2V0LnB1c2gocmVhZFN0cmluZygpKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0YXJnZXQucHVzaChbIHN0YXJ0ID0gcGFyc2VJZChuZXh0KCkpLCBza2lwKFwidG9cIiwgdHJ1ZSkgPyBwYXJzZUlkKG5leHQoKSkgOiBzdGFydCBdKTtcbiAgICAgICAgfSB3aGlsZSAoc2tpcChcIixcIiwgdHJ1ZSkpO1xuICAgICAgICBza2lwKFwiO1wiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZU51bWJlcih0b2tlbiwgaW5zaWRlVHJ5Q2F0Y2gpIHtcbiAgICAgICAgdmFyIHNpZ24gPSAxO1xuICAgICAgICBpZiAodG9rZW4uY2hhckF0KDApID09PSBcIi1cIikge1xuICAgICAgICAgICAgc2lnbiA9IC0xO1xuICAgICAgICAgICAgdG9rZW4gPSB0b2tlbi5zdWJzdHJpbmcoMSk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICAgICAgY2FzZSBcImluZlwiOiBjYXNlIFwiSU5GXCI6IGNhc2UgXCJJbmZcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gc2lnbiAqIEluZmluaXR5O1xuICAgICAgICAgICAgY2FzZSBcIm5hblwiOiBjYXNlIFwiTkFOXCI6IGNhc2UgXCJOYW5cIjogY2FzZSBcIk5hTlwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgICAgICBjYXNlIFwiMFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiYXNlMTBSZS50ZXN0KHRva2VuKSlcbiAgICAgICAgICAgIHJldHVybiBzaWduICogcGFyc2VJbnQodG9rZW4sIDEwKTtcbiAgICAgICAgaWYgKGJhc2UxNlJlLnRlc3QodG9rZW4pKVxuICAgICAgICAgICAgcmV0dXJuIHNpZ24gKiBwYXJzZUludCh0b2tlbiwgMTYpO1xuICAgICAgICBpZiAoYmFzZThSZS50ZXN0KHRva2VuKSlcbiAgICAgICAgICAgIHJldHVybiBzaWduICogcGFyc2VJbnQodG9rZW4sIDgpO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmIChudW1iZXJSZS50ZXN0KHRva2VuKSlcbiAgICAgICAgICAgIHJldHVybiBzaWduICogcGFyc2VGbG9hdCh0b2tlbik7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbiwgXCJudW1iZXJcIiwgaW5zaWRlVHJ5Q2F0Y2gpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlSWQodG9rZW4sIGFjY2VwdE5lZ2F0aXZlKSB7XG4gICAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgICAgIGNhc2UgXCJtYXhcIjogY2FzZSBcIk1BWFwiOiBjYXNlIFwiTWF4XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDUzNjg3MDkxMTtcbiAgICAgICAgICAgIGNhc2UgXCIwXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFhY2NlcHROZWdhdGl2ZSAmJiB0b2tlbi5jaGFyQXQoMCkgPT09IFwiLVwiKVxuICAgICAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbiwgXCJpZFwiKTtcblxuICAgICAgICBpZiAoYmFzZTEwTmVnUmUudGVzdCh0b2tlbikpXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQodG9rZW4sIDEwKTtcbiAgICAgICAgaWYgKGJhc2UxNk5lZ1JlLnRlc3QodG9rZW4pKVxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHRva2VuLCAxNik7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKGJhc2U4TmVnUmUudGVzdCh0b2tlbikpXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQodG9rZW4sIDgpO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4sIFwiaWRcIik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VQYWNrYWdlKCkge1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAocGtnICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKFwicGFja2FnZVwiKTtcblxuICAgICAgICBwa2cgPSBuZXh0KCk7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghdHlwZVJlZlJlLnRlc3QocGtnKSlcbiAgICAgICAgICAgIHRocm93IGlsbGVnYWwocGtnLCBcIm5hbWVcIik7XG5cbiAgICAgICAgcHRyID0gcHRyLmRlZmluZShwa2cpO1xuICAgICAgICBza2lwKFwiO1wiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUltcG9ydCgpIHtcbiAgICAgICAgdmFyIHRva2VuID0gcGVlaygpO1xuICAgICAgICB2YXIgd2hpY2hJbXBvcnRzO1xuICAgICAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAgICAgICBjYXNlIFwid2Vha1wiOlxuICAgICAgICAgICAgICAgIHdoaWNoSW1wb3J0cyA9IHdlYWtJbXBvcnRzIHx8ICh3ZWFrSW1wb3J0cyA9IFtdKTtcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicHVibGljXCI6XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB3aGljaEltcG9ydHMgPSBpbXBvcnRzIHx8IChpbXBvcnRzID0gW10pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHRva2VuID0gcmVhZFN0cmluZygpO1xuICAgICAgICBza2lwKFwiO1wiKTtcbiAgICAgICAgd2hpY2hJbXBvcnRzLnB1c2godG9rZW4pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlU3ludGF4KCkge1xuICAgICAgICBza2lwKFwiPVwiKTtcbiAgICAgICAgc3ludGF4ID0gcmVhZFN0cmluZygpO1xuICAgICAgICBpc1Byb3RvMyA9IHN5bnRheCA9PT0gXCJwcm90bzNcIjtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFpc1Byb3RvMyAmJiBzeW50YXggIT09IFwicHJvdG8yXCIpXG4gICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHN5bnRheCwgXCJzeW50YXhcIik7XG5cbiAgICAgICAgc2tpcChcIjtcIik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VDb21tb24ocGFyZW50LCB0b2tlbikge1xuICAgICAgICBzd2l0Y2ggKHRva2VuKSB7XG5cbiAgICAgICAgICAgIGNhc2UgXCJvcHRpb25cIjpcbiAgICAgICAgICAgICAgICBwYXJzZU9wdGlvbihwYXJlbnQsIHRva2VuKTtcbiAgICAgICAgICAgICAgICBza2lwKFwiO1wiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICBwYXJzZVR5cGUocGFyZW50LCB0b2tlbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICAgICAgcGFyc2VFbnVtKHBhcmVudCwgdG9rZW4pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgICAgICBjYXNlIFwic2VydmljZVwiOlxuICAgICAgICAgICAgICAgIHBhcnNlU2VydmljZShwYXJlbnQsIHRva2VuKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICAgICAgY2FzZSBcImV4dGVuZFwiOlxuICAgICAgICAgICAgICAgIHBhcnNlRXh0ZW5zaW9uKHBhcmVudCwgdG9rZW4pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpZkJsb2NrKG9iaiwgZm5JZiwgZm5FbHNlKSB7XG4gICAgICAgIHZhciB0cmFpbGluZ0xpbmUgPSB0bi5saW5lO1xuICAgICAgICBpZiAob2JqKSB7XG4gICAgICAgICAgICBpZih0eXBlb2Ygb2JqLmNvbW1lbnQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgb2JqLmNvbW1lbnQgPSBjbW50KCk7IC8vIHRyeSBibG9jay10eXBlIGNvbW1lbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9iai5maWxlbmFtZSA9IHBhcnNlLmZpbGVuYW1lO1xuICAgICAgICB9XG4gICAgICAgIGlmIChza2lwKFwie1wiLCB0cnVlKSkge1xuICAgICAgICAgICAgdmFyIHRva2VuO1xuICAgICAgICAgICAgd2hpbGUgKCh0b2tlbiA9IG5leHQoKSkgIT09IFwifVwiKVxuICAgICAgICAgICAgICAgIGZuSWYodG9rZW4pO1xuICAgICAgICAgICAgc2tpcChcIjtcIiwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZm5FbHNlKVxuICAgICAgICAgICAgICAgIGZuRWxzZSgpO1xuICAgICAgICAgICAgc2tpcChcIjtcIik7XG4gICAgICAgICAgICBpZiAob2JqICYmICh0eXBlb2Ygb2JqLmNvbW1lbnQgIT09IFwic3RyaW5nXCIgfHwgcHJlZmVyVHJhaWxpbmdDb21tZW50KSlcbiAgICAgICAgICAgICAgICBvYmouY29tbWVudCA9IGNtbnQodHJhaWxpbmdMaW5lKSB8fCBvYmouY29tbWVudDsgLy8gdHJ5IGxpbmUtdHlwZSBjb21tZW50XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVR5cGUocGFyZW50LCB0b2tlbikge1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIW5hbWVSZS50ZXN0KHRva2VuID0gbmV4dCgpKSlcbiAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4sIFwidHlwZSBuYW1lXCIpO1xuXG4gICAgICAgIHZhciB0eXBlID0gbmV3IFR5cGUodG9rZW4pO1xuICAgICAgICBpZkJsb2NrKHR5cGUsIGZ1bmN0aW9uIHBhcnNlVHlwZV9ibG9jayh0b2tlbikge1xuICAgICAgICAgICAgaWYgKHBhcnNlQ29tbW9uKHR5cGUsIHRva2VuKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgIHN3aXRjaCAodG9rZW4pIHtcblxuICAgICAgICAgICAgICAgIGNhc2UgXCJtYXBcIjpcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VNYXBGaWVsZCh0eXBlLCB0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBcInJlcXVpcmVkXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInJlcGVhdGVkXCI6XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRmllbGQodHlwZSwgdG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgXCJvcHRpb25hbFwiOlxuICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzUHJvdG8zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUZpZWxkKHR5cGUsIFwicHJvdG8zX29wdGlvbmFsXCIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VGaWVsZCh0eXBlLCBcIm9wdGlvbmFsXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBcIm9uZW9mXCI6XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlT25lT2YodHlwZSwgdG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgXCJleHRlbnNpb25zXCI6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRSYW5nZXModHlwZS5leHRlbnNpb25zIHx8ICh0eXBlLmV4dGVuc2lvbnMgPSBbXSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgXCJyZXNlcnZlZFwiOlxuICAgICAgICAgICAgICAgICAgICByZWFkUmFuZ2VzKHR5cGUucmVzZXJ2ZWQgfHwgKHR5cGUucmVzZXJ2ZWQgPSBbXSksIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzUHJvdG8zIHx8ICF0eXBlUmVmUmUudGVzdCh0b2tlbikpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuKTtcblxuICAgICAgICAgICAgICAgICAgICBwdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VGaWVsZCh0eXBlLCBcIm9wdGlvbmFsXCIpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHBhcmVudC5hZGQodHlwZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VGaWVsZChwYXJlbnQsIHJ1bGUsIGV4dGVuZCkge1xuICAgICAgICB2YXIgdHlwZSA9IG5leHQoKTtcbiAgICAgICAgaWYgKHR5cGUgPT09IFwiZ3JvdXBcIikge1xuICAgICAgICAgICAgcGFyc2VHcm91cChwYXJlbnQsIHJ1bGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFR5cGUgbmFtZXMgY2FuIGNvbnN1bWUgbXVsdGlwbGUgdG9rZW5zLCBpbiBtdWx0aXBsZSB2YXJpYW50czpcbiAgICAgICAgLy8gICAgcGFja2FnZS5zdWJwYWNrYWdlICAgZmllbGQgICAgICAgdG9rZW5zOiBcInBhY2thZ2Uuc3VicGFja2FnZVwiIFtUWVBFIE5BTUUgRU5EUyBIRVJFXSBcImZpZWxkXCJcbiAgICAgICAgLy8gICAgcGFja2FnZSAuIHN1YnBhY2thZ2UgZmllbGQgICAgICAgdG9rZW5zOiBcInBhY2thZ2VcIiBcIi5cIiBcInN1YnBhY2thZ2VcIiBbVFlQRSBOQU1FIEVORFMgSEVSRV0gXCJmaWVsZFwiXG4gICAgICAgIC8vICAgIHBhY2thZ2UuICBzdWJwYWNrYWdlIGZpZWxkICAgICAgIHRva2VuczogXCJwYWNrYWdlLlwiIFwic3VicGFja2FnZVwiIFtUWVBFIE5BTUUgRU5EUyBIRVJFXSBcImZpZWxkXCJcbiAgICAgICAgLy8gICAgcGFja2FnZSAgLnN1YnBhY2thZ2UgZmllbGQgICAgICAgdG9rZW5zOiBcInBhY2thZ2VcIiBcIi5zdWJwYWNrYWdlXCIgW1RZUEUgTkFNRSBFTkRTIEhFUkVdIFwiZmllbGRcIlxuICAgICAgICAvLyBLZWVwIHJlYWRpbmcgdG9rZW5zIHVudGlsIHdlIGdldCBhIHR5cGUgbmFtZSB3aXRoIG5vIHBlcmlvZCBhdCB0aGUgZW5kLFxuICAgICAgICAvLyBhbmQgdGhlIG5leHQgdG9rZW4gZG9lcyBub3Qgc3RhcnQgd2l0aCBhIHBlcmlvZC5cbiAgICAgICAgd2hpbGUgKHR5cGUuZW5kc1dpdGgoXCIuXCIpIHx8IHBlZWsoKS5zdGFydHNXaXRoKFwiLlwiKSkge1xuICAgICAgICAgICAgdHlwZSArPSBuZXh0KCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCF0eXBlUmVmUmUudGVzdCh0eXBlKSlcbiAgICAgICAgICAgIHRocm93IGlsbGVnYWwodHlwZSwgXCJ0eXBlXCIpO1xuXG4gICAgICAgIHZhciBuYW1lID0gbmV4dCgpO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIW5hbWVSZS50ZXN0KG5hbWUpKVxuICAgICAgICAgICAgdGhyb3cgaWxsZWdhbChuYW1lLCBcIm5hbWVcIik7XG5cbiAgICAgICAgbmFtZSA9IGFwcGx5Q2FzZShuYW1lKTtcbiAgICAgICAgc2tpcChcIj1cIik7XG5cbiAgICAgICAgdmFyIGZpZWxkID0gbmV3IEZpZWxkKG5hbWUsIHBhcnNlSWQobmV4dCgpKSwgdHlwZSwgcnVsZSwgZXh0ZW5kKTtcbiAgICAgICAgaWZCbG9jayhmaWVsZCwgZnVuY3Rpb24gcGFyc2VGaWVsZF9ibG9jayh0b2tlbikge1xuXG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgaWYgKHRva2VuID09PSBcIm9wdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VPcHRpb24oZmllbGQsIHRva2VuKTtcbiAgICAgICAgICAgICAgICBza2lwKFwiO1wiKTtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4pO1xuXG4gICAgICAgIH0sIGZ1bmN0aW9uIHBhcnNlRmllbGRfbGluZSgpIHtcbiAgICAgICAgICAgIHBhcnNlSW5saW5lT3B0aW9ucyhmaWVsZCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChydWxlID09PSBcInByb3RvM19vcHRpb25hbFwiKSB7XG4gICAgICAgICAgICAvLyBmb3IgcHJvdG8zIG9wdGlvbmFsIGZpZWxkcywgd2UgY3JlYXRlIGEgc2luZ2xlLW1lbWJlciBPbmVvZiB0byBtaW1pYyBcIm9wdGlvbmFsXCIgYmVoYXZpb3JcbiAgICAgICAgICAgIHZhciBvbmVvZiA9IG5ldyBPbmVPZihcIl9cIiArIG5hbWUpO1xuICAgICAgICAgICAgZmllbGQuc2V0T3B0aW9uKFwicHJvdG8zX29wdGlvbmFsXCIsIHRydWUpO1xuICAgICAgICAgICAgb25lb2YuYWRkKGZpZWxkKTtcbiAgICAgICAgICAgIHBhcmVudC5hZGQob25lb2YpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyZW50LmFkZChmaWVsZCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBKU09OIGRlZmF1bHRzIHRvIHBhY2tlZD10cnVlIGlmIG5vdCBzZXQgc28gd2UgaGF2ZSB0byBzZXQgcGFja2VkPWZhbHNlIGV4cGxpY2l0eSB3aGVuXG4gICAgICAgIC8vIHBhcnNpbmcgcHJvdG8yIGRlc2NyaXB0b3JzIHdpdGhvdXQgdGhlIG9wdGlvbiwgd2hlcmUgYXBwbGljYWJsZS4gVGhpcyBtdXN0IGJlIGRvbmUgZm9yXG4gICAgICAgIC8vIGFsbCBrbm93biBwYWNrYWJsZSB0eXBlcyBhbmQgYW55dGhpbmcgdGhhdCBjb3VsZCBiZSBhbiBlbnVtICg9IGlzIG5vdCBhIGJhc2ljIHR5cGUpLlxuICAgICAgICBpZiAoIWlzUHJvdG8zICYmIGZpZWxkLnJlcGVhdGVkICYmICh0eXBlcy5wYWNrZWRbdHlwZV0gIT09IHVuZGVmaW5lZCB8fCB0eXBlcy5iYXNpY1t0eXBlXSA9PT0gdW5kZWZpbmVkKSlcbiAgICAgICAgICAgIGZpZWxkLnNldE9wdGlvbihcInBhY2tlZFwiLCBmYWxzZSwgLyogaWZOb3RTZXQgKi8gdHJ1ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VHcm91cChwYXJlbnQsIHJ1bGUpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBuZXh0KCk7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghbmFtZVJlLnRlc3QobmFtZSkpXG4gICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKG5hbWUsIFwibmFtZVwiKTtcblxuICAgICAgICB2YXIgZmllbGROYW1lID0gdXRpbC5sY0ZpcnN0KG5hbWUpO1xuICAgICAgICBpZiAobmFtZSA9PT0gZmllbGROYW1lKVxuICAgICAgICAgICAgbmFtZSA9IHV0aWwudWNGaXJzdChuYW1lKTtcbiAgICAgICAgc2tpcChcIj1cIik7XG4gICAgICAgIHZhciBpZCA9IHBhcnNlSWQobmV4dCgpKTtcbiAgICAgICAgdmFyIHR5cGUgPSBuZXcgVHlwZShuYW1lKTtcbiAgICAgICAgdHlwZS5ncm91cCA9IHRydWU7XG4gICAgICAgIHZhciBmaWVsZCA9IG5ldyBGaWVsZChmaWVsZE5hbWUsIGlkLCBuYW1lLCBydWxlKTtcbiAgICAgICAgZmllbGQuZmlsZW5hbWUgPSBwYXJzZS5maWxlbmFtZTtcbiAgICAgICAgaWZCbG9jayh0eXBlLCBmdW5jdGlvbiBwYXJzZUdyb3VwX2Jsb2NrKHRva2VuKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRva2VuKSB7XG5cbiAgICAgICAgICAgICAgICBjYXNlIFwib3B0aW9uXCI6XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlT3B0aW9uKHR5cGUsIHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgc2tpcChcIjtcIik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBcInJlcXVpcmVkXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInJlcGVhdGVkXCI6XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRmllbGQodHlwZSwgdG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgXCJvcHRpb25hbFwiOlxuICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzUHJvdG8zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUZpZWxkKHR5cGUsIFwicHJvdG8zX29wdGlvbmFsXCIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VGaWVsZCh0eXBlLCBcIm9wdGlvbmFsXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VUeXBlKHR5cGUsIHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgICAgICAgICBwYXJzZUVudW0odHlwZSwgdG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbik7IC8vIHRoZXJlIGFyZSBubyBncm91cHMgd2l0aCBwcm90bzMgc2VtYW50aWNzXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBwYXJlbnQuYWRkKHR5cGUpXG4gICAgICAgICAgICAgIC5hZGQoZmllbGQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlTWFwRmllbGQocGFyZW50KSB7XG4gICAgICAgIHNraXAoXCI8XCIpO1xuICAgICAgICB2YXIga2V5VHlwZSA9IG5leHQoKTtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKHR5cGVzLm1hcEtleVtrZXlUeXBlXSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgaWxsZWdhbChrZXlUeXBlLCBcInR5cGVcIik7XG5cbiAgICAgICAgc2tpcChcIixcIik7XG4gICAgICAgIHZhciB2YWx1ZVR5cGUgPSBuZXh0KCk7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghdHlwZVJlZlJlLnRlc3QodmFsdWVUeXBlKSlcbiAgICAgICAgICAgIHRocm93IGlsbGVnYWwodmFsdWVUeXBlLCBcInR5cGVcIik7XG5cbiAgICAgICAgc2tpcChcIj5cIik7XG4gICAgICAgIHZhciBuYW1lID0gbmV4dCgpO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIW5hbWVSZS50ZXN0KG5hbWUpKVxuICAgICAgICAgICAgdGhyb3cgaWxsZWdhbChuYW1lLCBcIm5hbWVcIik7XG5cbiAgICAgICAgc2tpcChcIj1cIik7XG4gICAgICAgIHZhciBmaWVsZCA9IG5ldyBNYXBGaWVsZChhcHBseUNhc2UobmFtZSksIHBhcnNlSWQobmV4dCgpKSwga2V5VHlwZSwgdmFsdWVUeXBlKTtcbiAgICAgICAgaWZCbG9jayhmaWVsZCwgZnVuY3Rpb24gcGFyc2VNYXBGaWVsZF9ibG9jayh0b2tlbikge1xuXG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgaWYgKHRva2VuID09PSBcIm9wdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VPcHRpb24oZmllbGQsIHRva2VuKTtcbiAgICAgICAgICAgICAgICBza2lwKFwiO1wiKTtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4pO1xuXG4gICAgICAgIH0sIGZ1bmN0aW9uIHBhcnNlTWFwRmllbGRfbGluZSgpIHtcbiAgICAgICAgICAgIHBhcnNlSW5saW5lT3B0aW9ucyhmaWVsZCk7XG4gICAgICAgIH0pO1xuICAgICAgICBwYXJlbnQuYWRkKGZpZWxkKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZU9uZU9mKHBhcmVudCwgdG9rZW4pIHtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFuYW1lUmUudGVzdCh0b2tlbiA9IG5leHQoKSkpXG4gICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuLCBcIm5hbWVcIik7XG5cbiAgICAgICAgdmFyIG9uZW9mID0gbmV3IE9uZU9mKGFwcGx5Q2FzZSh0b2tlbikpO1xuICAgICAgICBpZkJsb2NrKG9uZW9mLCBmdW5jdGlvbiBwYXJzZU9uZU9mX2Jsb2NrKHRva2VuKSB7XG4gICAgICAgICAgICBpZiAodG9rZW4gPT09IFwib3B0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBwYXJzZU9wdGlvbihvbmVvZiwgdG9rZW4pO1xuICAgICAgICAgICAgICAgIHNraXAoXCI7XCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBwYXJzZUZpZWxkKG9uZW9mLCBcIm9wdGlvbmFsXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcGFyZW50LmFkZChvbmVvZik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VFbnVtKHBhcmVudCwgdG9rZW4pIHtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFuYW1lUmUudGVzdCh0b2tlbiA9IG5leHQoKSkpXG4gICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuLCBcIm5hbWVcIik7XG5cbiAgICAgICAgdmFyIGVubSA9IG5ldyBFbnVtKHRva2VuKTtcbiAgICAgICAgaWZCbG9jayhlbm0sIGZ1bmN0aW9uIHBhcnNlRW51bV9ibG9jayh0b2tlbikge1xuICAgICAgICAgIHN3aXRjaCh0b2tlbikge1xuICAgICAgICAgICAgY2FzZSBcIm9wdGlvblwiOlxuICAgICAgICAgICAgICBwYXJzZU9wdGlvbihlbm0sIHRva2VuKTtcbiAgICAgICAgICAgICAgc2tpcChcIjtcIik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFwicmVzZXJ2ZWRcIjpcbiAgICAgICAgICAgICAgcmVhZFJhbmdlcyhlbm0ucmVzZXJ2ZWQgfHwgKGVubS5yZXNlcnZlZCA9IFtdKSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBwYXJzZUVudW1WYWx1ZShlbm0sIHRva2VuKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBwYXJlbnQuYWRkKGVubSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VFbnVtVmFsdWUocGFyZW50LCB0b2tlbikge1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIW5hbWVSZS50ZXN0KHRva2VuKSlcbiAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4sIFwibmFtZVwiKTtcblxuICAgICAgICBza2lwKFwiPVwiKTtcbiAgICAgICAgdmFyIHZhbHVlID0gcGFyc2VJZChuZXh0KCksIHRydWUpLFxuICAgICAgICAgICAgZHVtbXkgPSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uczogdW5kZWZpbmVkXG4gICAgICAgICAgICB9O1xuICAgICAgICBkdW1teS5zZXRPcHRpb24gPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zW25hbWVdID0gdmFsdWU7XG4gICAgICAgIH07XG4gICAgICAgIGlmQmxvY2soZHVtbXksIGZ1bmN0aW9uIHBhcnNlRW51bVZhbHVlX2Jsb2NrKHRva2VuKSB7XG5cbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICBpZiAodG9rZW4gPT09IFwib3B0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBwYXJzZU9wdGlvbihkdW1teSwgdG9rZW4pOyAvLyBza2lwXG4gICAgICAgICAgICAgICAgc2tpcChcIjtcIik7XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuKTtcblxuICAgICAgICB9LCBmdW5jdGlvbiBwYXJzZUVudW1WYWx1ZV9saW5lKCkge1xuICAgICAgICAgICAgcGFyc2VJbmxpbmVPcHRpb25zKGR1bW15KTsgLy8gc2tpcFxuICAgICAgICB9KTtcbiAgICAgICAgcGFyZW50LmFkZCh0b2tlbiwgdmFsdWUsIGR1bW15LmNvbW1lbnQsIGR1bW15Lm9wdGlvbnMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlT3B0aW9uKHBhcmVudCwgdG9rZW4pIHtcbiAgICAgICAgdmFyIGlzQ3VzdG9tID0gc2tpcChcIihcIiwgdHJ1ZSk7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghdHlwZVJlZlJlLnRlc3QodG9rZW4gPSBuZXh0KCkpKVxuICAgICAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbiwgXCJuYW1lXCIpO1xuXG4gICAgICAgIHZhciBuYW1lID0gdG9rZW47XG4gICAgICAgIHZhciBvcHRpb24gPSBuYW1lO1xuICAgICAgICB2YXIgcHJvcE5hbWU7XG5cbiAgICAgICAgaWYgKGlzQ3VzdG9tKSB7XG4gICAgICAgICAgICBza2lwKFwiKVwiKTtcbiAgICAgICAgICAgIG5hbWUgPSBcIihcIiArIG5hbWUgKyBcIilcIjtcbiAgICAgICAgICAgIG9wdGlvbiA9IG5hbWU7XG4gICAgICAgICAgICB0b2tlbiA9IHBlZWsoKTtcbiAgICAgICAgICAgIGlmIChmcVR5cGVSZWZSZS50ZXN0KHRva2VuKSkge1xuICAgICAgICAgICAgICAgIHByb3BOYW1lID0gdG9rZW4uc2xpY2UoMSk7IC8vcmVtb3ZlICcuJyBiZWZvcmUgcHJvcGVydHkgbmFtZVxuICAgICAgICAgICAgICAgIG5hbWUgKz0gdG9rZW47XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNraXAoXCI9XCIpO1xuICAgICAgICB2YXIgb3B0aW9uVmFsdWUgPSBwYXJzZU9wdGlvblZhbHVlKHBhcmVudCwgbmFtZSk7XG4gICAgICAgIHNldFBhcnNlZE9wdGlvbihwYXJlbnQsIG9wdGlvbiwgb3B0aW9uVmFsdWUsIHByb3BOYW1lKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZU9wdGlvblZhbHVlKHBhcmVudCwgbmFtZSkge1xuICAgICAgICAvLyB7IGE6IFwiZm9vXCIgYiB7IGM6IFwiYmFyXCIgfSB9XG4gICAgICAgIGlmIChza2lwKFwie1wiLCB0cnVlKSkge1xuICAgICAgICAgICAgdmFyIG9iamVjdFJlc3VsdCA9IHt9O1xuXG4gICAgICAgICAgICB3aGlsZSAoIXNraXAoXCJ9XCIsIHRydWUpKSB7XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgaWYgKCFuYW1lUmUudGVzdCh0b2tlbiA9IG5leHQoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbiwgXCJuYW1lXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodG9rZW4gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4sIFwiZW5kIG9mIGlucHV0XCIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcE5hbWUgPSB0b2tlbjtcblxuICAgICAgICAgICAgICAgIHNraXAoXCI6XCIsIHRydWUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHBlZWsoKSA9PT0gXCJ7XCIpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2VPcHRpb25WYWx1ZShwYXJlbnQsIG5hbWUgKyBcIi5cIiArIHRva2VuKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwZWVrKCkgPT09IFwiW1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG9wdGlvbiAobXlfb3B0aW9uKSA9IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIHJlcGVhdGVkX3ZhbHVlOiBbIFwiZm9vXCIsIFwiYmFyXCIgXVxuICAgICAgICAgICAgICAgICAgICAvLyB9O1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2tpcChcIltcIiwgdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0VmFsdWUgPSByZWFkVmFsdWUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUucHVzaChsYXN0VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoc2tpcChcIixcIiwgdHJ1ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2tpcChcIl1cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGxhc3RWYWx1ZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldE9wdGlvbihwYXJlbnQsIG5hbWUgKyBcIi5cIiArIHRva2VuLCBsYXN0VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSByZWFkVmFsdWUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHNldE9wdGlvbihwYXJlbnQsIG5hbWUgKyBcIi5cIiArIHRva2VuLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHByZXZWYWx1ZSA9IG9iamVjdFJlc3VsdFtwcm9wTmFtZV07XG5cbiAgICAgICAgICAgICAgICBpZiAocHJldlZhbHVlKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IFtdLmNvbmNhdChwcmV2VmFsdWUpLmNvbmNhdCh2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICBvYmplY3RSZXN1bHRbcHJvcE5hbWVdID0gdmFsdWU7XG5cbiAgICAgICAgICAgICAgICAvLyBTZW1pY29sb25zIGFuZCBjb21tYXMgY2FuIGJlIG9wdGlvbmFsXG4gICAgICAgICAgICAgICAgc2tpcChcIixcIiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgc2tpcChcIjtcIiwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvYmplY3RSZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2ltcGxlVmFsdWUgPSByZWFkVmFsdWUodHJ1ZSk7XG4gICAgICAgIHNldE9wdGlvbihwYXJlbnQsIG5hbWUsIHNpbXBsZVZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHNpbXBsZVZhbHVlO1xuICAgICAgICAvLyBEb2VzIG5vdCBlbmZvcmNlIGEgZGVsaW1pdGVyIHRvIGJlIHVuaXZlcnNhbFxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldE9wdGlvbihwYXJlbnQsIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGlmIChwYXJlbnQuc2V0T3B0aW9uKVxuICAgICAgICAgICAgcGFyZW50LnNldE9wdGlvbihuYW1lLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0UGFyc2VkT3B0aW9uKHBhcmVudCwgbmFtZSwgdmFsdWUsIHByb3BOYW1lKSB7XG4gICAgICAgIGlmIChwYXJlbnQuc2V0UGFyc2VkT3B0aW9uKVxuICAgICAgICAgICAgcGFyZW50LnNldFBhcnNlZE9wdGlvbihuYW1lLCB2YWx1ZSwgcHJvcE5hbWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlSW5saW5lT3B0aW9ucyhwYXJlbnQpIHtcbiAgICAgICAgaWYgKHNraXAoXCJbXCIsIHRydWUpKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgcGFyc2VPcHRpb24ocGFyZW50LCBcIm9wdGlvblwiKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKHNraXAoXCIsXCIsIHRydWUpKTtcbiAgICAgICAgICAgIHNraXAoXCJdXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VTZXJ2aWNlKHBhcmVudCwgdG9rZW4pIHtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFuYW1lUmUudGVzdCh0b2tlbiA9IG5leHQoKSkpXG4gICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuLCBcInNlcnZpY2UgbmFtZVwiKTtcblxuICAgICAgICB2YXIgc2VydmljZSA9IG5ldyBTZXJ2aWNlKHRva2VuKTtcbiAgICAgICAgaWZCbG9jayhzZXJ2aWNlLCBmdW5jdGlvbiBwYXJzZVNlcnZpY2VfYmxvY2sodG9rZW4pIHtcbiAgICAgICAgICAgIGlmIChwYXJzZUNvbW1vbihzZXJ2aWNlLCB0b2tlbikpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgaWYgKHRva2VuID09PSBcInJwY1wiKVxuICAgICAgICAgICAgICAgIHBhcnNlTWV0aG9kKHNlcnZpY2UsIHRva2VuKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHBhcmVudC5hZGQoc2VydmljZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VNZXRob2QocGFyZW50LCB0b2tlbikge1xuICAgICAgICAvLyBHZXQgdGhlIGNvbW1lbnQgb2YgdGhlIHByZWNlZGluZyBsaW5lIG5vdyAoaWYgb25lIGV4aXN0cykgaW4gY2FzZSB0aGVcbiAgICAgICAgLy8gbWV0aG9kIGlzIGRlZmluZWQgYWNyb3NzIG11bHRpcGxlIGxpbmVzLlxuICAgICAgICB2YXIgY29tbWVudFRleHQgPSBjbW50KCk7XG5cbiAgICAgICAgdmFyIHR5cGUgPSB0b2tlbjtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFuYW1lUmUudGVzdCh0b2tlbiA9IG5leHQoKSkpXG4gICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuLCBcIm5hbWVcIik7XG5cbiAgICAgICAgdmFyIG5hbWUgPSB0b2tlbixcbiAgICAgICAgICAgIHJlcXVlc3RUeXBlLCByZXF1ZXN0U3RyZWFtLFxuICAgICAgICAgICAgcmVzcG9uc2VUeXBlLCByZXNwb25zZVN0cmVhbTtcblxuICAgICAgICBza2lwKFwiKFwiKTtcbiAgICAgICAgaWYgKHNraXAoXCJzdHJlYW1cIiwgdHJ1ZSkpXG4gICAgICAgICAgICByZXF1ZXN0U3RyZWFtID0gdHJ1ZTtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCF0eXBlUmVmUmUudGVzdCh0b2tlbiA9IG5leHQoKSkpXG4gICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuKTtcblxuICAgICAgICByZXF1ZXN0VHlwZSA9IHRva2VuO1xuICAgICAgICBza2lwKFwiKVwiKTsgc2tpcChcInJldHVybnNcIik7IHNraXAoXCIoXCIpO1xuICAgICAgICBpZiAoc2tpcChcInN0cmVhbVwiLCB0cnVlKSlcbiAgICAgICAgICAgIHJlc3BvbnNlU3RyZWFtID0gdHJ1ZTtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCF0eXBlUmVmUmUudGVzdCh0b2tlbiA9IG5leHQoKSkpXG4gICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuKTtcblxuICAgICAgICByZXNwb25zZVR5cGUgPSB0b2tlbjtcbiAgICAgICAgc2tpcChcIilcIik7XG5cbiAgICAgICAgdmFyIG1ldGhvZCA9IG5ldyBNZXRob2QobmFtZSwgdHlwZSwgcmVxdWVzdFR5cGUsIHJlc3BvbnNlVHlwZSwgcmVxdWVzdFN0cmVhbSwgcmVzcG9uc2VTdHJlYW0pO1xuICAgICAgICBtZXRob2QuY29tbWVudCA9IGNvbW1lbnRUZXh0O1xuICAgICAgICBpZkJsb2NrKG1ldGhvZCwgZnVuY3Rpb24gcGFyc2VNZXRob2RfYmxvY2sodG9rZW4pIHtcblxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gXCJvcHRpb25cIikge1xuICAgICAgICAgICAgICAgIHBhcnNlT3B0aW9uKG1ldGhvZCwgdG9rZW4pO1xuICAgICAgICAgICAgICAgIHNraXAoXCI7XCIpO1xuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbik7XG5cbiAgICAgICAgfSk7XG4gICAgICAgIHBhcmVudC5hZGQobWV0aG9kKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUV4dGVuc2lvbihwYXJlbnQsIHRva2VuKSB7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghdHlwZVJlZlJlLnRlc3QodG9rZW4gPSBuZXh0KCkpKVxuICAgICAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbiwgXCJyZWZlcmVuY2VcIik7XG5cbiAgICAgICAgdmFyIHJlZmVyZW5jZSA9IHRva2VuO1xuICAgICAgICBpZkJsb2NrKG51bGwsIGZ1bmN0aW9uIHBhcnNlRXh0ZW5zaW9uX2Jsb2NrKHRva2VuKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRva2VuKSB7XG5cbiAgICAgICAgICAgICAgICBjYXNlIFwicmVxdWlyZWRcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwicmVwZWF0ZWRcIjpcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VGaWVsZChwYXJlbnQsIHRva2VuLCByZWZlcmVuY2UpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgXCJvcHRpb25hbFwiOlxuICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzUHJvdG8zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUZpZWxkKHBhcmVudCwgXCJwcm90bzNfb3B0aW9uYWxcIiwgcmVmZXJlbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRmllbGQocGFyZW50LCBcIm9wdGlvbmFsXCIsIHJlZmVyZW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1Byb3RvMyB8fCAhdHlwZVJlZlJlLnRlc3QodG9rZW4pKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIHB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBwYXJzZUZpZWxkKHBhcmVudCwgXCJvcHRpb25hbFwiLCByZWZlcmVuY2UpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIHRva2VuO1xuICAgIHdoaWxlICgodG9rZW4gPSBuZXh0KCkpICE9PSBudWxsKSB7XG4gICAgICAgIHN3aXRjaCAodG9rZW4pIHtcblxuICAgICAgICAgICAgY2FzZSBcInBhY2thZ2VcIjpcblxuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICAgIGlmICghaGVhZClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbik7XG5cbiAgICAgICAgICAgICAgICBwYXJzZVBhY2thZ2UoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBcImltcG9ydFwiOlxuXG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgaWYgKCFoZWFkKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuKTtcblxuICAgICAgICAgICAgICAgIHBhcnNlSW1wb3J0KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCJzeW50YXhcIjpcblxuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICAgIGlmICghaGVhZClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbik7XG5cbiAgICAgICAgICAgICAgICBwYXJzZVN5bnRheCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFwib3B0aW9uXCI6XG5cbiAgICAgICAgICAgICAgICBwYXJzZU9wdGlvbihwdHIsIHRva2VuKTtcbiAgICAgICAgICAgICAgICBza2lwKFwiO1wiKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgZGVmYXVsdDpcblxuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlQ29tbW9uKHB0ciwgdG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHBhcnNlLmZpbGVuYW1lID0gbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgICBcInBhY2thZ2VcIiAgICAgOiBwa2csXG4gICAgICAgIFwiaW1wb3J0c1wiICAgICA6IGltcG9ydHMsXG4gICAgICAgICB3ZWFrSW1wb3J0cyAgOiB3ZWFrSW1wb3J0cyxcbiAgICAgICAgIHN5bnRheCAgICAgICA6IHN5bnRheCxcbiAgICAgICAgIHJvb3QgICAgICAgICA6IHJvb3RcbiAgICB9O1xufVxuXG4vKipcbiAqIFBhcnNlcyB0aGUgZ2l2ZW4gLnByb3RvIHNvdXJjZSBhbmQgcmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0aGUgcGFyc2VkIGNvbnRlbnRzLlxuICogQG5hbWUgcGFyc2VcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZSBTb3VyY2UgY29udGVudHNcbiAqIEBwYXJhbSB7SVBhcnNlT3B0aW9uc30gW29wdGlvbnNdIFBhcnNlIG9wdGlvbnMuIERlZmF1bHRzIHRvIHtAbGluayBwYXJzZS5kZWZhdWx0c30gd2hlbiBvbWl0dGVkLlxuICogQHJldHVybnMge0lQYXJzZXJSZXN1bHR9IFBhcnNlciByZXN1bHRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBmaWxlbmFtZT1udWxsIEN1cnJlbnRseSBwcm9jZXNzaW5nIGZpbGUgbmFtZSBmb3IgZXJyb3IgcmVwb3J0aW5nLCBpZiBrbm93blxuICogQHByb3BlcnR5IHtJUGFyc2VPcHRpb25zfSBkZWZhdWx0cyBEZWZhdWx0IHtAbGluayBJUGFyc2VPcHRpb25zfVxuICogQHZhcmlhdGlvbiAyXG4gKi9cbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwicGFyc2UiLCJmaWxlbmFtZSIsImRlZmF1bHRzIiwia2VlcENhc2UiLCJ0b2tlbml6ZSIsInJlcXVpcmUiLCJSb290IiwiVHlwZSIsIkZpZWxkIiwiTWFwRmllbGQiLCJPbmVPZiIsIkVudW0iLCJTZXJ2aWNlIiwiTWV0aG9kIiwidHlwZXMiLCJ1dGlsIiwiYmFzZTEwUmUiLCJiYXNlMTBOZWdSZSIsImJhc2UxNlJlIiwiYmFzZTE2TmVnUmUiLCJiYXNlOFJlIiwiYmFzZThOZWdSZSIsIm51bWJlclJlIiwibmFtZVJlIiwidHlwZVJlZlJlIiwiZnFUeXBlUmVmUmUiLCJzb3VyY2UiLCJyb290Iiwib3B0aW9ucyIsInByZWZlclRyYWlsaW5nQ29tbWVudCIsInRuIiwiYWx0ZXJuYXRlQ29tbWVudE1vZGUiLCJuZXh0IiwicHVzaCIsInBlZWsiLCJza2lwIiwiY21udCIsImhlYWQiLCJwa2ciLCJpbXBvcnRzIiwid2Vha0ltcG9ydHMiLCJzeW50YXgiLCJpc1Byb3RvMyIsInB0ciIsImFwcGx5Q2FzZSIsIm5hbWUiLCJjYW1lbENhc2UiLCJpbGxlZ2FsIiwidG9rZW4iLCJpbnNpZGVUcnlDYXRjaCIsIkVycm9yIiwibGluZSIsInJlYWRTdHJpbmciLCJ2YWx1ZXMiLCJqb2luIiwicmVhZFZhbHVlIiwiYWNjZXB0VHlwZVJlZiIsInBhcnNlTnVtYmVyIiwiZSIsInRlc3QiLCJyZWFkUmFuZ2VzIiwidGFyZ2V0IiwiYWNjZXB0U3RyaW5ncyIsInN0YXJ0IiwicGFyc2VJZCIsInNpZ24iLCJjaGFyQXQiLCJzdWJzdHJpbmciLCJJbmZpbml0eSIsIk5hTiIsInBhcnNlSW50IiwicGFyc2VGbG9hdCIsImFjY2VwdE5lZ2F0aXZlIiwicGFyc2VQYWNrYWdlIiwidW5kZWZpbmVkIiwiZGVmaW5lIiwicGFyc2VJbXBvcnQiLCJ3aGljaEltcG9ydHMiLCJwYXJzZVN5bnRheCIsInBhcnNlQ29tbW9uIiwicGFyZW50IiwicGFyc2VPcHRpb24iLCJwYXJzZVR5cGUiLCJwYXJzZUVudW0iLCJwYXJzZVNlcnZpY2UiLCJwYXJzZUV4dGVuc2lvbiIsImlmQmxvY2siLCJvYmoiLCJmbklmIiwiZm5FbHNlIiwidHJhaWxpbmdMaW5lIiwiY29tbWVudCIsInR5cGUiLCJwYXJzZVR5cGVfYmxvY2siLCJwYXJzZU1hcEZpZWxkIiwicGFyc2VGaWVsZCIsInBhcnNlT25lT2YiLCJleHRlbnNpb25zIiwicmVzZXJ2ZWQiLCJhZGQiLCJydWxlIiwiZXh0ZW5kIiwicGFyc2VHcm91cCIsImVuZHNXaXRoIiwic3RhcnRzV2l0aCIsImZpZWxkIiwicGFyc2VGaWVsZF9ibG9jayIsInBhcnNlRmllbGRfbGluZSIsInBhcnNlSW5saW5lT3B0aW9ucyIsIm9uZW9mIiwic2V0T3B0aW9uIiwicmVwZWF0ZWQiLCJwYWNrZWQiLCJiYXNpYyIsImZpZWxkTmFtZSIsImxjRmlyc3QiLCJ1Y0ZpcnN0IiwiaWQiLCJncm91cCIsInBhcnNlR3JvdXBfYmxvY2siLCJrZXlUeXBlIiwibWFwS2V5IiwidmFsdWVUeXBlIiwicGFyc2VNYXBGaWVsZF9ibG9jayIsInBhcnNlTWFwRmllbGRfbGluZSIsInBhcnNlT25lT2ZfYmxvY2siLCJlbm0iLCJwYXJzZUVudW1fYmxvY2siLCJwYXJzZUVudW1WYWx1ZSIsInZhbHVlIiwiZHVtbXkiLCJwYXJzZUVudW1WYWx1ZV9ibG9jayIsInBhcnNlRW51bVZhbHVlX2xpbmUiLCJpc0N1c3RvbSIsIm9wdGlvbiIsInByb3BOYW1lIiwic2xpY2UiLCJvcHRpb25WYWx1ZSIsInBhcnNlT3B0aW9uVmFsdWUiLCJzZXRQYXJzZWRPcHRpb24iLCJvYmplY3RSZXN1bHQiLCJsYXN0VmFsdWUiLCJwcmV2VmFsdWUiLCJjb25jYXQiLCJzaW1wbGVWYWx1ZSIsInNlcnZpY2UiLCJwYXJzZVNlcnZpY2VfYmxvY2siLCJwYXJzZU1ldGhvZCIsImNvbW1lbnRUZXh0IiwicmVxdWVzdFR5cGUiLCJyZXF1ZXN0U3RyZWFtIiwicmVzcG9uc2VUeXBlIiwicmVzcG9uc2VTdHJlYW0iLCJtZXRob2QiLCJwYXJzZU1ldGhvZF9ibG9jayIsInJlZmVyZW5jZSIsInBhcnNlRXh0ZW5zaW9uX2Jsb2NrIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/protobufjs/src/parse.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/src/reader.js":
/*!************************************************!*\
  !*** ../node_modules/protobufjs/src/reader.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = Reader;\nvar util = __webpack_require__(/*! ./util/minimal */ \"(ssr)/../node_modules/protobufjs/src/util/minimal.js\");\nvar BufferReader; // cyclic\nvar LongBits = util.LongBits, utf8 = util.utf8;\n/* istanbul ignore next */ function indexOutOfRange(reader, writeLength) {\n    return RangeError(\"index out of range: \" + reader.pos + \" + \" + (writeLength || 1) + \" > \" + reader.len);\n}\n/**\n * Constructs a new reader instance using the specified buffer.\n * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n * @param {Uint8Array} buffer Buffer to read from\n */ function Reader(buffer) {\n    /**\n     * Read buffer.\n     * @type {Uint8Array}\n     */ this.buf = buffer;\n    /**\n     * Read buffer position.\n     * @type {number}\n     */ this.pos = 0;\n    /**\n     * Read buffer length.\n     * @type {number}\n     */ this.len = buffer.length;\n}\nvar create_array = typeof Uint8Array !== \"undefined\" ? function create_typed_array(buffer) {\n    if (buffer instanceof Uint8Array || Array.isArray(buffer)) return new Reader(buffer);\n    throw Error(\"illegal buffer\");\n} : function create_array(buffer) {\n    if (Array.isArray(buffer)) return new Reader(buffer);\n    throw Error(\"illegal buffer\");\n};\nvar create = function create() {\n    return util.Buffer ? function create_buffer_setup(buffer) {\n        return (Reader.create = function create_buffer(buffer) {\n            return util.Buffer.isBuffer(buffer) ? new BufferReader(buffer) : create_array(buffer);\n        })(buffer);\n    } : create_array;\n};\n/**\n * Creates a new reader using the specified buffer.\n * @function\n * @param {Uint8Array|Buffer} buffer Buffer to read from\n * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}\n * @throws {Error} If `buffer` is not a valid buffer\n */ Reader.create = create();\nReader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;\n/**\n * Reads a varint as an unsigned 32 bit value.\n * @function\n * @returns {number} Value read\n */ Reader.prototype.uint32 = function read_uint32_setup() {\n    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)\n    return function read_uint32() {\n        value = (this.buf[this.pos] & 127) >>> 0;\n        if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;\n        if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;\n        if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;\n        if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;\n        if (this.buf[this.pos++] < 128) return value;\n        /* istanbul ignore if */ if ((this.pos += 5) > this.len) {\n            this.pos = this.len;\n            throw indexOutOfRange(this, 10);\n        }\n        return value;\n    };\n}();\n/**\n * Reads a varint as a signed 32 bit value.\n * @returns {number} Value read\n */ Reader.prototype.int32 = function read_int32() {\n    return this.uint32() | 0;\n};\n/**\n * Reads a zig-zag encoded varint as a signed 32 bit value.\n * @returns {number} Value read\n */ Reader.prototype.sint32 = function read_sint32() {\n    var value = this.uint32();\n    return value >>> 1 ^ -(value & 1) | 0;\n};\n/* eslint-disable no-invalid-this */ function readLongVarint() {\n    // tends to deopt with local vars for octet etc.\n    var bits = new LongBits(0, 0);\n    var i = 0;\n    if (this.len - this.pos > 4) {\n        for(; i < 4; ++i){\n            // 1st..4th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128) return bits;\n        }\n        // 5th\n        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;\n        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;\n        if (this.buf[this.pos++] < 128) return bits;\n        i = 0;\n    } else {\n        for(; i < 3; ++i){\n            /* istanbul ignore if */ if (this.pos >= this.len) throw indexOutOfRange(this);\n            // 1st..3th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128) return bits;\n        }\n        // 4th\n        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;\n        return bits;\n    }\n    if (this.len - this.pos > 4) {\n        for(; i < 5; ++i){\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128) return bits;\n        }\n    } else {\n        for(; i < 5; ++i){\n            /* istanbul ignore if */ if (this.pos >= this.len) throw indexOutOfRange(this);\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128) return bits;\n        }\n    }\n    /* istanbul ignore next */ throw Error(\"invalid varint encoding\");\n}\n/* eslint-enable no-invalid-this */ /**\n * Reads a varint as a signed 64 bit value.\n * @name Reader#int64\n * @function\n * @returns {Long} Value read\n */ /**\n * Reads a varint as an unsigned 64 bit value.\n * @name Reader#uint64\n * @function\n * @returns {Long} Value read\n */ /**\n * Reads a zig-zag encoded varint as a signed 64 bit value.\n * @name Reader#sint64\n * @function\n * @returns {Long} Value read\n */ /**\n * Reads a varint as a boolean.\n * @returns {boolean} Value read\n */ Reader.prototype.bool = function read_bool() {\n    return this.uint32() !== 0;\n};\nfunction readFixed32_end(buf, end) {\n    return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;\n}\n/**\n * Reads fixed 32 bits as an unsigned 32 bit integer.\n * @returns {number} Value read\n */ Reader.prototype.fixed32 = function read_fixed32() {\n    /* istanbul ignore if */ if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4);\n    return readFixed32_end(this.buf, this.pos += 4);\n};\n/**\n * Reads fixed 32 bits as a signed 32 bit integer.\n * @returns {number} Value read\n */ Reader.prototype.sfixed32 = function read_sfixed32() {\n    /* istanbul ignore if */ if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4);\n    return readFixed32_end(this.buf, this.pos += 4) | 0;\n};\n/* eslint-disable no-invalid-this */ function readFixed64() {\n    /* istanbul ignore if */ if (this.pos + 8 > this.len) throw indexOutOfRange(this, 8);\n    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));\n}\n/* eslint-enable no-invalid-this */ /**\n * Reads fixed 64 bits.\n * @name Reader#fixed64\n * @function\n * @returns {Long} Value read\n */ /**\n * Reads zig-zag encoded fixed 64 bits.\n * @name Reader#sfixed64\n * @function\n * @returns {Long} Value read\n */ /**\n * Reads a float (32 bit) as a number.\n * @function\n * @returns {number} Value read\n */ Reader.prototype.float = function read_float() {\n    /* istanbul ignore if */ if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4);\n    var value = util.float.readFloatLE(this.buf, this.pos);\n    this.pos += 4;\n    return value;\n};\n/**\n * Reads a double (64 bit float) as a number.\n * @function\n * @returns {number} Value read\n */ Reader.prototype.double = function read_double() {\n    /* istanbul ignore if */ if (this.pos + 8 > this.len) throw indexOutOfRange(this, 4);\n    var value = util.float.readDoubleLE(this.buf, this.pos);\n    this.pos += 8;\n    return value;\n};\n/**\n * Reads a sequence of bytes preceeded by its length as a varint.\n * @returns {Uint8Array} Value read\n */ Reader.prototype.bytes = function read_bytes() {\n    var length = this.uint32(), start = this.pos, end = this.pos + length;\n    /* istanbul ignore if */ if (end > this.len) throw indexOutOfRange(this, length);\n    this.pos += length;\n    if (Array.isArray(this.buf)) return this.buf.slice(start, end);\n    if (start === end) {\n        var nativeBuffer = util.Buffer;\n        return nativeBuffer ? nativeBuffer.alloc(0) : new this.buf.constructor(0);\n    }\n    return this._slice.call(this.buf, start, end);\n};\n/**\n * Reads a string preceeded by its byte length as a varint.\n * @returns {string} Value read\n */ Reader.prototype.string = function read_string() {\n    var bytes = this.bytes();\n    return utf8.read(bytes, 0, bytes.length);\n};\n/**\n * Skips the specified number of bytes if specified, otherwise skips a varint.\n * @param {number} [length] Length if known, otherwise a varint is assumed\n * @returns {Reader} `this`\n */ Reader.prototype.skip = function skip(length) {\n    if (typeof length === \"number\") {\n        /* istanbul ignore if */ if (this.pos + length > this.len) throw indexOutOfRange(this, length);\n        this.pos += length;\n    } else {\n        do {\n            /* istanbul ignore if */ if (this.pos >= this.len) throw indexOutOfRange(this);\n        }while (this.buf[this.pos++] & 128);\n    }\n    return this;\n};\n/**\n * Skips the next element of the specified wire type.\n * @param {number} wireType Wire type received\n * @returns {Reader} `this`\n */ Reader.prototype.skipType = function(wireType) {\n    switch(wireType){\n        case 0:\n            this.skip();\n            break;\n        case 1:\n            this.skip(8);\n            break;\n        case 2:\n            this.skip(this.uint32());\n            break;\n        case 3:\n            while((wireType = this.uint32() & 7) !== 4){\n                this.skipType(wireType);\n            }\n            break;\n        case 5:\n            this.skip(4);\n            break;\n        /* istanbul ignore next */ default:\n            throw Error(\"invalid wire type \" + wireType + \" at offset \" + this.pos);\n    }\n    return this;\n};\nReader._configure = function(BufferReader_) {\n    BufferReader = BufferReader_;\n    Reader.create = create();\n    BufferReader._configure();\n    var fn = util.Long ? \"toLong\" : /* istanbul ignore next */ \"toNumber\";\n    util.merge(Reader.prototype, {\n        int64: function read_int64() {\n            return readLongVarint.call(this)[fn](false);\n        },\n        uint64: function read_uint64() {\n            return readLongVarint.call(this)[fn](true);\n        },\n        sint64: function read_sint64() {\n            return readLongVarint.call(this).zzDecode()[fn](false);\n        },\n        fixed64: function read_fixed64() {\n            return readFixed64.call(this)[fn](true);\n        },\n        sfixed64: function read_sfixed64() {\n            return readFixed64.call(this)[fn](false);\n        }\n    });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3JlYWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSxPQUFPQyxPQUFPLEdBQUdDO0FBRWpCLElBQUlDLE9BQVlDLG1CQUFPQSxDQUFDLDRFQUFnQjtBQUV4QyxJQUFJQyxjQUFjLFNBQVM7QUFFM0IsSUFBSUMsV0FBWUgsS0FBS0csUUFBUSxFQUN6QkMsT0FBWUosS0FBS0ksSUFBSTtBQUV6Qix3QkFBd0IsR0FDeEIsU0FBU0MsZ0JBQWdCQyxNQUFNLEVBQUVDLFdBQVc7SUFDeEMsT0FBT0MsV0FBVyx5QkFBeUJGLE9BQU9HLEdBQUcsR0FBRyxRQUFTRixDQUFBQSxlQUFlLEtBQUssUUFBUUQsT0FBT0ksR0FBRztBQUMzRztBQUVBOzs7OztDQUtDLEdBQ0QsU0FBU1gsT0FBT1ksTUFBTTtJQUVsQjs7O0tBR0MsR0FDRCxJQUFJLENBQUNDLEdBQUcsR0FBR0Q7SUFFWDs7O0tBR0MsR0FDRCxJQUFJLENBQUNGLEdBQUcsR0FBRztJQUVYOzs7S0FHQyxHQUNELElBQUksQ0FBQ0MsR0FBRyxHQUFHQyxPQUFPRSxNQUFNO0FBQzVCO0FBRUEsSUFBSUMsZUFBZSxPQUFPQyxlQUFlLGNBQ25DLFNBQVNDLG1CQUFtQkwsTUFBTTtJQUNoQyxJQUFJQSxrQkFBa0JJLGNBQWNFLE1BQU1DLE9BQU8sQ0FBQ1AsU0FDOUMsT0FBTyxJQUFJWixPQUFPWTtJQUN0QixNQUFNUSxNQUFNO0FBQ2hCLElBRUUsU0FBU0wsYUFBYUgsTUFBTTtJQUMxQixJQUFJTSxNQUFNQyxPQUFPLENBQUNQLFNBQ2QsT0FBTyxJQUFJWixPQUFPWTtJQUN0QixNQUFNUSxNQUFNO0FBQ2hCO0FBRUosSUFBSUMsU0FBUyxTQUFTQTtJQUNsQixPQUFPcEIsS0FBS3FCLE1BQU0sR0FDWixTQUFTQyxvQkFBb0JYLE1BQU07UUFDakMsT0FBTyxDQUFDWixPQUFPcUIsTUFBTSxHQUFHLFNBQVNHLGNBQWNaLE1BQU07WUFDakQsT0FBT1gsS0FB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LFlBQVlhLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQ1MsR0FBRyxDQUFDO1FBQ3RDO0lBRUo7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcmVhZGVyLmpzP2VkZDAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRlcjtcblxudmFyIHV0aWwgICAgICA9IHJlcXVpcmUoXCIuL3V0aWwvbWluaW1hbFwiKTtcblxudmFyIEJ1ZmZlclJlYWRlcjsgLy8gY3ljbGljXG5cbnZhciBMb25nQml0cyAgPSB1dGlsLkxvbmdCaXRzLFxuICAgIHV0ZjggICAgICA9IHV0aWwudXRmODtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGluZGV4T3V0T2ZSYW5nZShyZWFkZXIsIHdyaXRlTGVuZ3RoKSB7XG4gICAgcmV0dXJuIFJhbmdlRXJyb3IoXCJpbmRleCBvdXQgb2YgcmFuZ2U6IFwiICsgcmVhZGVyLnBvcyArIFwiICsgXCIgKyAod3JpdGVMZW5ndGggfHwgMSkgKyBcIiA+IFwiICsgcmVhZGVyLmxlbik7XG59XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyByZWFkZXIgaW5zdGFuY2UgdXNpbmcgdGhlIHNwZWNpZmllZCBidWZmZXIuXG4gKiBAY2xhc3NkZXNjIFdpcmUgZm9ybWF0IHJlYWRlciB1c2luZyBgVWludDhBcnJheWAgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgYEFycmF5YC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZmZXIgQnVmZmVyIHRvIHJlYWQgZnJvbVxuICovXG5mdW5jdGlvbiBSZWFkZXIoYnVmZmVyKSB7XG5cbiAgICAvKipcbiAgICAgKiBSZWFkIGJ1ZmZlci5cbiAgICAgKiBAdHlwZSB7VWludDhBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmJ1ZiA9IGJ1ZmZlcjtcblxuICAgIC8qKlxuICAgICAqIFJlYWQgYnVmZmVyIHBvc2l0aW9uLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5wb3MgPSAwO1xuXG4gICAgLyoqXG4gICAgICogUmVhZCBidWZmZXIgbGVuZ3RoLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5sZW4gPSBidWZmZXIubGVuZ3RoO1xufVxuXG52YXIgY3JlYXRlX2FycmF5ID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09IFwidW5kZWZpbmVkXCJcbiAgICA/IGZ1bmN0aW9uIGNyZWF0ZV90eXBlZF9hcnJheShidWZmZXIpIHtcbiAgICAgICAgaWYgKGJ1ZmZlciBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHwgQXJyYXkuaXNBcnJheShidWZmZXIpKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWFkZXIoYnVmZmVyKTtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIGJ1ZmZlclwiKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICA6IGZ1bmN0aW9uIGNyZWF0ZV9hcnJheShidWZmZXIpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYnVmZmVyKSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVhZGVyKGJ1ZmZlcik7XG4gICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBidWZmZXJcIik7XG4gICAgfTtcblxudmFyIGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgICByZXR1cm4gdXRpbC5CdWZmZXJcbiAgICAgICAgPyBmdW5jdGlvbiBjcmVhdGVfYnVmZmVyX3NldHVwKGJ1ZmZlcikge1xuICAgICAgICAgICAgcmV0dXJuIChSZWFkZXIuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlX2J1ZmZlcihidWZmZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXRpbC5CdWZmZXIuaXNCdWZmZXIoYnVmZmVyKVxuICAgICAgICAgICAgICAgICAgICA/IG5ldyBCdWZmZXJSZWFkZXIoYnVmZmVyKVxuICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgICAgICAgICA6IGNyZWF0ZV9hcnJheShidWZmZXIpO1xuICAgICAgICAgICAgfSkoYnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICA6IGNyZWF0ZV9hcnJheTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyByZWFkZXIgdXNpbmcgdGhlIHNwZWNpZmllZCBidWZmZXIuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7VWludDhBcnJheXxCdWZmZXJ9IGJ1ZmZlciBCdWZmZXIgdG8gcmVhZCBmcm9tXG4gKiBAcmV0dXJucyB7UmVhZGVyfEJ1ZmZlclJlYWRlcn0gQSB7QGxpbmsgQnVmZmVyUmVhZGVyfSBpZiBgYnVmZmVyYCBpcyBhIEJ1ZmZlciwgb3RoZXJ3aXNlIGEge0BsaW5rIFJlYWRlcn1cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBgYnVmZmVyYCBpcyBub3QgYSB2YWxpZCBidWZmZXJcbiAqL1xuUmVhZGVyLmNyZWF0ZSA9IGNyZWF0ZSgpO1xuXG5SZWFkZXIucHJvdG90eXBlLl9zbGljZSA9IHV0aWwuQXJyYXkucHJvdG90eXBlLnN1YmFycmF5IHx8IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHV0aWwuQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG4vKipcbiAqIFJlYWRzIGEgdmFyaW50IGFzIGFuIHVuc2lnbmVkIDMyIGJpdCB2YWx1ZS5cbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLnVpbnQzMiA9IChmdW5jdGlvbiByZWFkX3VpbnQzMl9zZXR1cCgpIHtcbiAgICB2YXIgdmFsdWUgPSA0Mjk0OTY3Mjk1OyAvLyBvcHRpbWl6ZXIgdHlwZS1oaW50LCB0ZW5kcyB0byBkZW9wdCBvdGhlcndpc2UgKD8hKVxuICAgIHJldHVybiBmdW5jdGlvbiByZWFkX3VpbnQzMigpIHtcbiAgICAgICAgdmFsdWUgPSAoICAgICAgICAgdGhpcy5idWZbdGhpcy5wb3NdICYgMTI3ICAgICAgICkgPj4+IDA7IGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOCkgcmV0dXJuIHZhbHVlO1xuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8ICA3KSA+Pj4gMDsgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KSByZXR1cm4gdmFsdWU7XG4gICAgICAgIHZhbHVlID0gKHZhbHVlIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgMTQpID4+PiAwOyBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPSAodmFsdWUgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCAyMSkgPj4+IDA7IGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOCkgcmV0dXJuIHZhbHVlO1xuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAgMTUpIDw8IDI4KSA+Pj4gMDsgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KSByZXR1cm4gdmFsdWU7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICgodGhpcy5wb3MgKz0gNSkgPiB0aGlzLmxlbikge1xuICAgICAgICAgICAgdGhpcy5wb3MgPSB0aGlzLmxlbjtcbiAgICAgICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCAxMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG59KSgpO1xuXG4vKipcbiAqIFJlYWRzIGEgdmFyaW50IGFzIGEgc2lnbmVkIDMyIGJpdCB2YWx1ZS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5pbnQzMiA9IGZ1bmN0aW9uIHJlYWRfaW50MzIoKSB7XG4gICAgcmV0dXJuIHRoaXMudWludDMyKCkgfCAwO1xufTtcblxuLyoqXG4gKiBSZWFkcyBhIHppZy16YWcgZW5jb2RlZCB2YXJpbnQgYXMgYSBzaWduZWQgMzIgYml0IHZhbHVlLlxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLnNpbnQzMiA9IGZ1bmN0aW9uIHJlYWRfc2ludDMyKCkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMudWludDMyKCk7XG4gICAgcmV0dXJuIHZhbHVlID4+PiAxIF4gLSh2YWx1ZSAmIDEpIHwgMDtcbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLWludmFsaWQtdGhpcyAqL1xuXG5mdW5jdGlvbiByZWFkTG9uZ1ZhcmludCgpIHtcbiAgICAvLyB0ZW5kcyB0byBkZW9wdCB3aXRoIGxvY2FsIHZhcnMgZm9yIG9jdGV0IGV0Yy5cbiAgICB2YXIgYml0cyA9IG5ldyBMb25nQml0cygwLCAwKTtcbiAgICB2YXIgaSA9IDA7XG4gICAgaWYgKHRoaXMubGVuIC0gdGhpcy5wb3MgPiA0KSB7IC8vIGZhc3Qgcm91dGUgKGxvKVxuICAgICAgICBmb3IgKDsgaSA8IDQ7ICsraSkge1xuICAgICAgICAgICAgLy8gMXN0Li40dGhcbiAgICAgICAgICAgIGJpdHMubG8gPSAoYml0cy5sbyB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IGkgKiA3KSA+Pj4gMDtcbiAgICAgICAgICAgIGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOClcbiAgICAgICAgICAgICAgICByZXR1cm4gYml0cztcbiAgICAgICAgfVxuICAgICAgICAvLyA1dGhcbiAgICAgICAgYml0cy5sbyA9IChiaXRzLmxvIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgMjgpID4+PiAwO1xuICAgICAgICBiaXRzLmhpID0gKGJpdHMuaGkgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA+PiAgNCkgPj4+IDA7XG4gICAgICAgIGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOClcbiAgICAgICAgICAgIHJldHVybiBiaXRzO1xuICAgICAgICBpID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKDsgaSA8IDM7ICsraSkge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5sZW4pXG4gICAgICAgICAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMpO1xuICAgICAgICAgICAgLy8gMXN0Li4zdGhcbiAgICAgICAgICAgIGJpdHMubG8gPSAoYml0cy5sbyB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IGkgKiA3KSA+Pj4gMDtcbiAgICAgICAgICAgIGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOClcbiAgICAgICAgICAgICAgICByZXR1cm4gYml0cztcbiAgICAgICAgfVxuICAgICAgICAvLyA0dGhcbiAgICAgICAgYml0cy5sbyA9IChiaXRzLmxvIHwgKHRoaXMuYnVmW3RoaXMucG9zKytdICYgMTI3KSA8PCBpICogNykgPj4+IDA7XG4gICAgICAgIHJldHVybiBiaXRzO1xuICAgIH1cbiAgICBpZiAodGhpcy5sZW4gLSB0aGlzLnBvcyA+IDQpIHsgLy8gZmFzdCByb3V0ZSAoaGkpXG4gICAgICAgIGZvciAoOyBpIDwgNTsgKytpKSB7XG4gICAgICAgICAgICAvLyA2dGguLjEwdGhcbiAgICAgICAgICAgIGJpdHMuaGkgPSAoYml0cy5oaSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IGkgKiA3ICsgMykgPj4+IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKDsgaSA8IDU7ICsraSkge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5sZW4pXG4gICAgICAgICAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMpO1xuICAgICAgICAgICAgLy8gNnRoLi4xMHRoXG4gICAgICAgICAgICBiaXRzLmhpID0gKGJpdHMuaGkgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCBpICogNyArIDMpID4+PiAwO1xuICAgICAgICAgICAgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KVxuICAgICAgICAgICAgICAgIHJldHVybiBiaXRzO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgdGhyb3cgRXJyb3IoXCJpbnZhbGlkIHZhcmludCBlbmNvZGluZ1wiKTtcbn1cblxuLyogZXNsaW50LWVuYWJsZSBuby1pbnZhbGlkLXRoaXMgKi9cblxuLyoqXG4gKiBSZWFkcyBhIHZhcmludCBhcyBhIHNpZ25lZCA2NCBiaXQgdmFsdWUuXG4gKiBAbmFtZSBSZWFkZXIjaW50NjRcbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge0xvbmd9IFZhbHVlIHJlYWRcbiAqL1xuXG4vKipcbiAqIFJlYWRzIGEgdmFyaW50IGFzIGFuIHVuc2lnbmVkIDY0IGJpdCB2YWx1ZS5cbiAqIEBuYW1lIFJlYWRlciN1aW50NjRcbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge0xvbmd9IFZhbHVlIHJlYWRcbiAqL1xuXG4vKipcbiAqIFJlYWRzIGEgemlnLXphZyBlbmNvZGVkIHZhcmludCBhcyBhIHNpZ25lZCA2NCBiaXQgdmFsdWUuXG4gKiBAbmFtZSBSZWFkZXIjc2ludDY0XG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtMb25nfSBWYWx1ZSByZWFkXG4gKi9cblxuLyoqXG4gKiBSZWFkcyBhIHZhcmludCBhcyBhIGJvb2xlYW4uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLmJvb2wgPSBmdW5jdGlvbiByZWFkX2Jvb2woKSB7XG4gICAgcmV0dXJuIHRoaXMudWludDMyKCkgIT09IDA7XG59O1xuXG5mdW5jdGlvbiByZWFkRml4ZWQzMl9lbmQoYnVmLCBlbmQpIHsgLy8gbm90ZSB0aGF0IHRoaXMgdXNlcyBgZW5kYCwgbm90IGBwb3NgXG4gICAgcmV0dXJuIChidWZbZW5kIC0gNF1cbiAgICAgICAgICB8IGJ1ZltlbmQgLSAzXSA8PCA4XG4gICAgICAgICAgfCBidWZbZW5kIC0gMl0gPDwgMTZcbiAgICAgICAgICB8IGJ1ZltlbmQgLSAxXSA8PCAyNCkgPj4+IDA7XG59XG5cbi8qKlxuICogUmVhZHMgZml4ZWQgMzIgYml0cyBhcyBhbiB1bnNpZ25lZCAzMiBiaXQgaW50ZWdlci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5maXhlZDMyID0gZnVuY3Rpb24gcmVhZF9maXhlZDMyKCkge1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHRoaXMucG9zICsgNCA+IHRoaXMubGVuKVxuICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgNCk7XG5cbiAgICByZXR1cm4gcmVhZEZpeGVkMzJfZW5kKHRoaXMuYnVmLCB0aGlzLnBvcyArPSA0KTtcbn07XG5cbi8qKlxuICogUmVhZHMgZml4ZWQgMzIgYml0cyBhcyBhIHNpZ25lZCAzMiBiaXQgaW50ZWdlci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5zZml4ZWQzMiA9IGZ1bmN0aW9uIHJlYWRfc2ZpeGVkMzIoKSB7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAodGhpcy5wb3MgKyA0ID4gdGhpcy5sZW4pXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCA0KTtcblxuICAgIHJldHVybiByZWFkRml4ZWQzMl9lbmQodGhpcy5idWYsIHRoaXMucG9zICs9IDQpIHwgMDtcbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLWludmFsaWQtdGhpcyAqL1xuXG5mdW5jdGlvbiByZWFkRml4ZWQ2NCgvKiB0aGlzOiBSZWFkZXIgKi8pIHtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh0aGlzLnBvcyArIDggPiB0aGlzLmxlbilcbiAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDgpO1xuXG4gICAgcmV0dXJuIG5ldyBMb25nQml0cyhyZWFkRml4ZWQzMl9lbmQodGhpcy5idWYsIHRoaXMucG9zICs9IDQpLCByZWFkRml4ZWQzMl9lbmQodGhpcy5idWYsIHRoaXMucG9zICs9IDQpKTtcbn1cblxuLyogZXNsaW50LWVuYWJsZSBuby1pbnZhbGlkLXRoaXMgKi9cblxuLyoqXG4gKiBSZWFkcyBmaXhlZCA2NCBiaXRzLlxuICogQG5hbWUgUmVhZGVyI2ZpeGVkNjRcbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge0xvbmd9IFZhbHVlIHJlYWRcbiAqL1xuXG4vKipcbiAqIFJlYWRzIHppZy16YWcgZW5jb2RlZCBmaXhlZCA2NCBiaXRzLlxuICogQG5hbWUgUmVhZGVyI3NmaXhlZDY0XG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtMb25nfSBWYWx1ZSByZWFkXG4gKi9cblxuLyoqXG4gKiBSZWFkcyBhIGZsb2F0ICgzMiBiaXQpIGFzIGEgbnVtYmVyLlxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuZmxvYXQgPSBmdW5jdGlvbiByZWFkX2Zsb2F0KCkge1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHRoaXMucG9zICsgNCA+IHRoaXMubGVuKVxuICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgNCk7XG5cbiAgICB2YXIgdmFsdWUgPSB1dGlsLmZsb2F0LnJlYWRGbG9hdExFKHRoaXMuYnVmLCB0aGlzLnBvcyk7XG4gICAgdGhpcy5wb3MgKz0gNDtcbiAgICByZXR1cm4gdmFsdWU7XG59O1xuXG4vKipcbiAqIFJlYWRzIGEgZG91YmxlICg2NCBiaXQgZmxvYXQpIGFzIGEgbnVtYmVyLlxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuZG91YmxlID0gZnVuY3Rpb24gcmVhZF9kb3VibGUoKSB7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAodGhpcy5wb3MgKyA4ID4gdGhpcy5sZW4pXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCA0KTtcblxuICAgIHZhciB2YWx1ZSA9IHV0aWwuZmxvYXQucmVhZERvdWJsZUxFKHRoaXMuYnVmLCB0aGlzLnBvcyk7XG4gICAgdGhpcy5wb3MgKz0gODtcbiAgICByZXR1cm4gdmFsdWU7XG59O1xuXG4vKipcbiAqIFJlYWRzIGEgc2VxdWVuY2Ugb2YgYnl0ZXMgcHJlY2VlZGVkIGJ5IGl0cyBsZW5ndGggYXMgYSB2YXJpbnQuXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLmJ5dGVzID0gZnVuY3Rpb24gcmVhZF9ieXRlcygpIHtcbiAgICB2YXIgbGVuZ3RoID0gdGhpcy51aW50MzIoKSxcbiAgICAgICAgc3RhcnQgID0gdGhpcy5wb3MsXG4gICAgICAgIGVuZCAgICA9IHRoaXMucG9zICsgbGVuZ3RoO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGVuZCA+IHRoaXMubGVuKVxuICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgbGVuZ3RoKTtcblxuICAgIHRoaXMucG9zICs9IGxlbmd0aDtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLmJ1ZikpIC8vIHBsYWluIGFycmF5XG4gICAgICAgIHJldHVybiB0aGlzLmJ1Zi5zbGljZShzdGFydCwgZW5kKTtcblxuICAgIGlmIChzdGFydCA9PT0gZW5kKSB7IC8vIGZpeCBmb3IgSUUgMTAvV2luOCBhbmQgb3RoZXJzJyBzdWJhcnJheSByZXR1cm5pbmcgYXJyYXkgb2Ygc2l6ZSAxXG4gICAgICAgIHZhciBuYXRpdmVCdWZmZXIgPSB1dGlsLkJ1ZmZlcjtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZUJ1ZmZlclxuICAgICAgICAgICAgPyBuYXRpdmVCdWZmZXIuYWxsb2MoMClcbiAgICAgICAgICAgIDogbmV3IHRoaXMuYnVmLmNvbnN0cnVjdG9yKDApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc2xpY2UuY2FsbCh0aGlzLmJ1Ziwgc3RhcnQsIGVuZCk7XG59O1xuXG4vKipcbiAqIFJlYWRzIGEgc3RyaW5nIHByZWNlZWRlZCBieSBpdHMgYnl0ZSBsZW5ndGggYXMgYSB2YXJpbnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuc3RyaW5nID0gZnVuY3Rpb24gcmVhZF9zdHJpbmcoKSB7XG4gICAgdmFyIGJ5dGVzID0gdGhpcy5ieXRlcygpO1xuICAgIHJldHVybiB1dGY4LnJlYWQoYnl0ZXMsIDAsIGJ5dGVzLmxlbmd0aCk7XG59O1xuXG4vKipcbiAqIFNraXBzIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIGJ5dGVzIGlmIHNwZWNpZmllZCwgb3RoZXJ3aXNlIHNraXBzIGEgdmFyaW50LlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIExlbmd0aCBpZiBrbm93biwgb3RoZXJ3aXNlIGEgdmFyaW50IGlzIGFzc3VtZWRcbiAqIEByZXR1cm5zIHtSZWFkZXJ9IGB0aGlzYFxuICovXG5SZWFkZXIucHJvdG90eXBlLnNraXAgPSBmdW5jdGlvbiBza2lwKGxlbmd0aCkge1xuICAgIGlmICh0eXBlb2YgbGVuZ3RoID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAodGhpcy5wb3MgKyBsZW5ndGggPiB0aGlzLmxlbilcbiAgICAgICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCBsZW5ndGgpO1xuICAgICAgICB0aGlzLnBvcyArPSBsZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5sZW4pXG4gICAgICAgICAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMpO1xuICAgICAgICB9IHdoaWxlICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSAmIDEyOCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTa2lwcyB0aGUgbmV4dCBlbGVtZW50IG9mIHRoZSBzcGVjaWZpZWQgd2lyZSB0eXBlLlxuICogQHBhcmFtIHtudW1iZXJ9IHdpcmVUeXBlIFdpcmUgdHlwZSByZWNlaXZlZFxuICogQHJldHVybnMge1JlYWRlcn0gYHRoaXNgXG4gKi9cblJlYWRlci5wcm90b3R5cGUuc2tpcFR5cGUgPSBmdW5jdGlvbih3aXJlVHlwZSkge1xuICAgIHN3aXRjaCAod2lyZVR5cGUpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgdGhpcy5za2lwKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgdGhpcy5za2lwKDgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHRoaXMuc2tpcCh0aGlzLnVpbnQzMigpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICB3aGlsZSAoKHdpcmVUeXBlID0gdGhpcy51aW50MzIoKSAmIDcpICE9PSA0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5za2lwVHlwZSh3aXJlVHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgdGhpcy5za2lwKDQpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiaW52YWxpZCB3aXJlIHR5cGUgXCIgKyB3aXJlVHlwZSArIFwiIGF0IG9mZnNldCBcIiArIHRoaXMucG9zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5SZWFkZXIuX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uKEJ1ZmZlclJlYWRlcl8pIHtcbiAgICBCdWZmZXJSZWFkZXIgPSBCdWZmZXJSZWFkZXJfO1xuICAgIFJlYWRlci5jcmVhdGUgPSBjcmVhdGUoKTtcbiAgICBCdWZmZXJSZWFkZXIuX2NvbmZpZ3VyZSgpO1xuXG4gICAgdmFyIGZuID0gdXRpbC5Mb25nID8gXCJ0b0xvbmdcIiA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIFwidG9OdW1iZXJcIjtcbiAgICB1dGlsLm1lcmdlKFJlYWRlci5wcm90b3R5cGUsIHtcblxuICAgICAgICBpbnQ2NDogZnVuY3Rpb24gcmVhZF9pbnQ2NCgpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkTG9uZ1ZhcmludC5jYWxsKHRoaXMpW2ZuXShmYWxzZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdWludDY0OiBmdW5jdGlvbiByZWFkX3VpbnQ2NCgpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkTG9uZ1ZhcmludC5jYWxsKHRoaXMpW2ZuXSh0cnVlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzaW50NjQ6IGZ1bmN0aW9uIHJlYWRfc2ludDY0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlYWRMb25nVmFyaW50LmNhbGwodGhpcykuenpEZWNvZGUoKVtmbl0oZmFsc2UpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpeGVkNjQ6IGZ1bmN0aW9uIHJlYWRfZml4ZWQ2NCgpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkRml4ZWQ2NC5jYWxsKHRoaXMpW2ZuXSh0cnVlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZml4ZWQ2NDogZnVuY3Rpb24gcmVhZF9zZml4ZWQ2NCgpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkRml4ZWQ2NC5jYWxsKHRoaXMpW2ZuXShmYWxzZSk7XG4gICAgICAgIH1cblxuICAgIH0pO1xufTtcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwiUmVhZGVyIiwidXRpbCIsInJlcXVpcmUiLCJCdWZmZXJSZWFkZXIiLCJMb25nQml0cyIsInV0ZjgiLCJpbmRleE91dE9mUmFuZ2UiLCJyZWFkZXIiLCJ3cml0ZUxlbmd0aCIsIlJhbmdlRXJyb3IiLCJwb3MiLCJsZW4iLCJidWZmZXIiLCJidWYiLCJsZW5ndGgiLCJjcmVhdGVfYXJyYXkiLCJVaW50OEFycmF5IiwiY3JlYXRlX3R5cGVkX2FycmF5IiwiQXJyYXkiLCJpc0FycmF5IiwiRXJyb3IiLCJjcmVhdGUiLCJCdWZmZXIiLCJjcmVhdGVfYnVmZmVyX3NldHVwIiwiY3JlYXRlX2J1ZmZlciIsImlzQnVmZmVyIiwicHJvdG90eXBlIiwiX3NsaWNlIiwic3ViYXJyYXkiLCJzbGljZSIsInVpbnQzMiIsInJlYWRfdWludDMyX3NldHVwIiwidmFsdWUiLCJyZWFkX3VpbnQzMiIsImludDMyIiwicmVhZF9pbnQzMiIsInNpbnQzMiIsInJlYWRfc2ludDMyIiwicmVhZExvbmdWYXJpbnQiLCJiaXRzIiwiaSIsImxvIiwiaGkiLCJib29sIiwicmVhZF9ib29sIiwicmVhZEZpeGVkMzJfZW5kIiwiZW5kIiwiZml4ZWQzMiIsInJlYWRfZml4ZWQzMiIsInNmaXhlZDMyIiwicmVhZF9zZml4ZWQzMiIsInJlYWRGaXhlZDY0IiwiZmxvYXQiLCJyZWFkX2Zsb2F0IiwicmVhZEZsb2F0TEUiLCJkb3VibGUiLCJyZWFkX2RvdWJsZSIsInJlYWREb3VibGVMRSIsImJ5dGVzIiwicmVhZF9ieXRlcyIsInN0YXJ0IiwibmF0aXZlQnVmZmVyIiwiYWxsb2MiLCJjb25zdHJ1Y3RvciIsImNhbGwiLCJzdHJpbmciLCJyZWFkX3N0cmluZyIsInJlYWQiLCJza2lwIiwic2tpcFR5cGUiLCJ3aXJlVHlwZSIsIl9jb25maWd1cmUiLCJCdWZmZXJSZWFkZXJfIiwiZm4iLCJMb25nIiwibWVyZ2UiLCJpbnQ2NCIsInJlYWRfaW50NjQiLCJ1aW50NjQiLCJyZWFkX3VpbnQ2NCIsInNpbnQ2NCIsInJlYWRfc2ludDY0IiwienpEZWNvZGUiLCJmaXhlZDY0IiwicmVhZF9maXhlZDY0Iiwic2ZpeGVkNjQiLCJyZWFkX3NmaXhlZDY0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/protobufjs/src/reader.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/src/reader_buffer.js":
/*!*******************************************************!*\
  !*** ../node_modules/protobufjs/src/reader_buffer.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = BufferReader;\n// extends Reader\nvar Reader = __webpack_require__(/*! ./reader */ \"(ssr)/../node_modules/protobufjs/src/reader.js\");\n(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;\nvar util = __webpack_require__(/*! ./util/minimal */ \"(ssr)/../node_modules/protobufjs/src/util/minimal.js\");\n/**\n * Constructs a new buffer reader instance.\n * @classdesc Wire format reader using node buffers.\n * @extends Reader\n * @constructor\n * @param {Buffer} buffer Buffer to read from\n */ function BufferReader(buffer) {\n    Reader.call(this, buffer);\n/**\n     * Read buffer.\n     * @name BufferReader#buf\n     * @type {Buffer}\n     */ }\nBufferReader._configure = function() {\n    /* istanbul ignore else */ if (util.Buffer) BufferReader.prototype._slice = util.Buffer.prototype.slice;\n};\n/**\n * @override\n */ BufferReader.prototype.string = function read_string_buffer() {\n    var len = this.uint32(); // modifies pos\n    return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString(\"utf-8\", this.pos, this.pos = Math.min(this.pos + len, this.len));\n};\n/**\n * Reads a sequence of bytes preceeded by its length as a varint.\n * @name BufferReader#bytes\n * @function\n * @returns {Buffer} Value read\n */ BufferReader._configure();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3JlYWRlcl9idWZmZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsT0FBT0MsT0FBTyxHQUFHQztBQUVqQixpQkFBaUI7QUFDakIsSUFBSUMsU0FBU0MsbUJBQU9BLENBQUMsZ0VBQVU7QUFDOUJGLENBQUFBLGFBQWFHLFNBQVMsR0FBR0MsT0FBT0MsTUFBTSxDQUFDSixPQUFPRSxTQUFTLEdBQUdHLFdBQVcsR0FBR047QUFFekUsSUFBSU8sT0FBT0wsbUJBQU9BLENBQUMsNEVBQWdCO0FBRW5DOzs7Ozs7Q0FNQyxHQUNELFNBQVNGLGFBQWFRLE1BQU07SUFDeEJQLE9BQU9RLElBQUksQ0FBQyxJQUFJLEVBQUVEO0FBRWxCOzs7O0tBSUMsR0FDTDtBQUVBUixhQUFhVSxVQUFVLEdBQUc7SUFDdEIsd0JBQXdCLEdBQ3hCLElBQUlILEtBQUtJLE1BQU0sRUFDWFgsYUFBYUcsU0FBUyxDQUFDUyxNQUFNLEdBQUdMLEtBQUtJLE1BQU0sQ0FBQ1IsU0FBUyxDQUFDVSxLQUFLO0FBQ25FO0FBR0E7O0NBRUMsR0FDRGIsYUFBYUcsU0FBUyxDQUFDVyxNQUFNLEdBQUcsU0FBU0M7SUFDckMsSUFBSUMsTUFBTSxJQUFJLENBQUNDLE1BQU0sSUFBSSxlQUFlO0lBQ3hDLE9BQU8sSUFBSSxDQUFDQyxHQUFHLENBQUNDLFNBQVMsR0FDbkIsSUFBSSxDQUFDRCxHQUFHLENBQUNDLFNBQVMsQ0FBQyxJQUFJLENBQUNDLEdBQUcsRUFBRSxJQUFJLENBQUNBLEdBQUcsR0FBR0MsS0FBS0MsR0FBRyxDQUFDLElBQUksQ0FBQ0YsR0FBRyxHQUFHSixLQUFLLElBQUksQ0FBQ0EsR0FBRyxLQUN6RSxJQUFJLENBQUNFLEdBQUcsQ0FBQ0ssUUFBUSxDQUFDLFNBQVMsSUFBSSxDQUFDSCxHQUFHLEVBQUUsSUFBSSxDQUFDQSxHQUFHLEdBQUdDLEtBQUtDLEdBQUcsQ0FBQyxJQUFJLENBQUNGLEdBQUcsR0FBR0osS0FBSyxJQUFJLENBQUNBLEdBQUc7QUFDM0Y7QUFFQTs7Ozs7Q0FLQyxHQUVEaEIsYUFBYVUsVUFBVSIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcmVhZGVyX2J1ZmZlci5qcz9lOTkyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBCdWZmZXJSZWFkZXI7XG5cbi8vIGV4dGVuZHMgUmVhZGVyXG52YXIgUmVhZGVyID0gcmVxdWlyZShcIi4vcmVhZGVyXCIpO1xuKEJ1ZmZlclJlYWRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFJlYWRlci5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IEJ1ZmZlclJlYWRlcjtcblxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsL21pbmltYWxcIik7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBidWZmZXIgcmVhZGVyIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBXaXJlIGZvcm1hdCByZWFkZXIgdXNpbmcgbm9kZSBidWZmZXJzLlxuICogQGV4dGVuZHMgUmVhZGVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgQnVmZmVyIHRvIHJlYWQgZnJvbVxuICovXG5mdW5jdGlvbiBCdWZmZXJSZWFkZXIoYnVmZmVyKSB7XG4gICAgUmVhZGVyLmNhbGwodGhpcywgYnVmZmVyKTtcblxuICAgIC8qKlxuICAgICAqIFJlYWQgYnVmZmVyLlxuICAgICAqIEBuYW1lIEJ1ZmZlclJlYWRlciNidWZcbiAgICAgKiBAdHlwZSB7QnVmZmVyfVxuICAgICAqL1xufVxuXG5CdWZmZXJSZWFkZXIuX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmICh1dGlsLkJ1ZmZlcilcbiAgICAgICAgQnVmZmVyUmVhZGVyLnByb3RvdHlwZS5fc2xpY2UgPSB1dGlsLkJ1ZmZlci5wcm90b3R5cGUuc2xpY2U7XG59O1xuXG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cbkJ1ZmZlclJlYWRlci5wcm90b3R5cGUuc3RyaW5nID0gZnVuY3Rpb24gcmVhZF9zdHJpbmdfYnVmZmVyKCkge1xuICAgIHZhciBsZW4gPSB0aGlzLnVpbnQzMigpOyAvLyBtb2RpZmllcyBwb3NcbiAgICByZXR1cm4gdGhpcy5idWYudXRmOFNsaWNlXG4gICAgICAgID8gdGhpcy5idWYudXRmOFNsaWNlKHRoaXMucG9zLCB0aGlzLnBvcyA9IE1hdGgubWluKHRoaXMucG9zICsgbGVuLCB0aGlzLmxlbikpXG4gICAgICAgIDogdGhpcy5idWYudG9TdHJpbmcoXCJ1dGYtOFwiLCB0aGlzLnBvcywgdGhpcy5wb3MgPSBNYXRoLm1pbih0aGlzLnBvcyArIGxlbiwgdGhpcy5sZW4pKTtcbn07XG5cbi8qKlxuICogUmVhZHMgYSBzZXF1ZW5jZSBvZiBieXRlcyBwcmVjZWVkZWQgYnkgaXRzIGxlbmd0aCBhcyBhIHZhcmludC5cbiAqIEBuYW1lIEJ1ZmZlclJlYWRlciNieXRlc1xuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7QnVmZmVyfSBWYWx1ZSByZWFkXG4gKi9cblxuQnVmZmVyUmVhZGVyLl9jb25maWd1cmUoKTtcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwiQnVmZmVyUmVhZGVyIiwiUmVhZGVyIiwicmVxdWlyZSIsInByb3RvdHlwZSIsIk9iamVjdCIsImNyZWF0ZSIsImNvbnN0cnVjdG9yIiwidXRpbCIsImJ1ZmZlciIsImNhbGwiLCJfY29uZmlndXJlIiwiQnVmZmVyIiwiX3NsaWNlIiwic2xpY2UiLCJzdHJpbmciLCJyZWFkX3N0cmluZ19idWZmZXIiLCJsZW4iLCJ1aW50MzIiLCJidWYiLCJ1dGY4U2xpY2UiLCJwb3MiLCJNYXRoIiwibWluIiwidG9TdHJpbmciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/protobufjs/src/reader_buffer.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/src/root.js":
/*!**********************************************!*\
  !*** ../node_modules/protobufjs/src/root.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = Root;\n// extends Namespace\nvar Namespace = __webpack_require__(/*! ./namespace */ \"(ssr)/../node_modules/protobufjs/src/namespace.js\");\n((Root.prototype = Object.create(Namespace.prototype)).constructor = Root).className = \"Root\";\nvar Field = __webpack_require__(/*! ./field */ \"(ssr)/../node_modules/protobufjs/src/field.js\"), Enum = __webpack_require__(/*! ./enum */ \"(ssr)/../node_modules/protobufjs/src/enum.js\"), OneOf = __webpack_require__(/*! ./oneof */ \"(ssr)/../node_modules/protobufjs/src/oneof.js\"), util = __webpack_require__(/*! ./util */ \"(ssr)/../node_modules/protobufjs/src/util.js\");\nvar Type, parse, common; // \"\n/**\n * Constructs a new root namespace instance.\n * @classdesc Root namespace wrapping all types, enums, services, sub-namespaces etc. that belong together.\n * @extends NamespaceBase\n * @constructor\n * @param {Object.<string,*>} [options] Top level options\n */ function Root(options) {\n    Namespace.call(this, \"\", options);\n    /**\n     * Deferred extension fields.\n     * @type {Field[]}\n     */ this.deferred = [];\n    /**\n     * Resolved file names of loaded files.\n     * @type {string[]}\n     */ this.files = [];\n}\n/**\n * Loads a namespace descriptor into a root namespace.\n * @param {INamespace} json Nameespace descriptor\n * @param {Root} [root] Root namespace, defaults to create a new one if omitted\n * @returns {Root} Root namespace\n */ Root.fromJSON = function fromJSON(json, root) {\n    if (!root) root = new Root();\n    if (json.options) root.setOptions(json.options);\n    return root.addJSON(json.nested);\n};\n/**\n * Resolves the path of an imported file, relative to the importing origin.\n * This method exists so you can override it with your own logic in case your imports are scattered over multiple directories.\n * @function\n * @param {string} origin The file name of the importing file\n * @param {string} target The file name being imported\n * @returns {string|null} Resolved path to `target` or `null` to skip the file\n */ Root.prototype.resolvePath = util.path.resolve;\n/**\n * Fetch content from file path or url\n * This method exists so you can override it with your own logic.\n * @function\n * @param {string} path File path or url\n * @param {FetchCallback} callback Callback function\n * @returns {undefined}\n */ Root.prototype.fetch = util.fetch;\n// A symbol-like function to safely signal synchronous loading\n/* istanbul ignore next */ function SYNC() {} // eslint-disable-line no-empty-function\n/**\n * Loads one or multiple .proto or preprocessed .json files into this root namespace and calls the callback.\n * @param {string|string[]} filename Names of one or multiple files to load\n * @param {IParseOptions} options Parse options\n * @param {LoadCallback} callback Callback function\n * @returns {undefined}\n */ Root.prototype.load = function load(filename, options, callback) {\n    if (typeof options === \"function\") {\n        callback = options;\n        options = undefined;\n    }\n    var self = this;\n    if (!callback) return util.asPromise(load, self, filename, options);\n    var sync = callback === SYNC; // undocumented\n    // Finishes loading by calling the callback (exactly once)\n    function finish(err, root) {\n        /* istanbul ignore if */ if (!callback) return;\n        if (sync) throw err;\n        var cb = callback;\n        callback = null;\n        cb(err, root);\n    }\n    // Bundled definition existence checking\n    function getBundledFileName(filename) {\n        var idx = filename.lastIndexOf(\"google/protobuf/\");\n        if (idx > -1) {\n            var altname = filename.substring(idx);\n            if (altname in common) return altname;\n        }\n        return null;\n    }\n    // Processes a single file\n    function process(filename, source) {\n        try {\n            if (util.isString(source) && source.charAt(0) === \"{\") source = JSON.parse(source);\n            if (!util.isString(source)) self.setOptions(source.options).addJSON(source.nested);\n            else {\n                parse.filename = filename;\n                var parsed = parse(source, self, options), resolved, i = 0;\n                if (parsed.imports) {\n                    for(; i < parsed.imports.length; ++i)if (resolved = getBundledFileName(parsed.imports[i]) || self.resolvePath(filename, parsed.imports[i])) fetch(resolved);\n                }\n                if (parsed.weakImports) {\n                    for(i = 0; i < parsed.weakImports.length; ++i)if (resolved = getBundledFileName(parsed.weakImports[i]) || self.resolvePath(filename, parsed.weakImports[i])) fetch(resolved, true);\n                }\n            }\n        } catch (err) {\n            finish(err);\n        }\n        if (!sync && !queued) finish(null, self); // only once anyway\n    }\n    // Fetches a single file\n    function fetch(filename, weak) {\n        filename = getBundledFileName(filename) || filename;\n        // Skip if already loaded / attempted\n        if (self.files.indexOf(filename) > -1) return;\n        self.files.push(filename);\n        // Shortcut bundled definitions\n        if (filename in common) {\n            if (sync) process(filename, common[filename]);\n            else {\n                ++queued;\n                setTimeout(function() {\n                    --queued;\n                    process(filename, common[filename]);\n                });\n            }\n            return;\n        }\n        // Otherwise fetch from disk or network\n        if (sync) {\n            var source;\n            try {\n                source = util.fs.readFileSync(filename).toString(\"utf8\");\n            } catch (err) {\n                if (!weak) finish(err);\n                return;\n            }\n            process(filename, source);\n        } else {\n            ++queued;\n            self.fetch(filename, function(err, source) {\n                --queued;\n                /* istanbul ignore if */ if (!callback) return; // terminated meanwhile\n                if (err) {\n                    /* istanbul ignore else */ if (!weak) finish(err);\n                    else if (!queued) finish(null, self);\n                    return;\n                }\n                process(filename, source);\n            });\n        }\n    }\n    var queued = 0;\n    // Assembling the root namespace doesn't require working type\n    // references anymore, so we can load everything in parallel\n    if (util.isString(filename)) filename = [\n        filename\n    ];\n    for(var i = 0, resolved; i < filename.length; ++i)if (resolved = self.resolvePath(\"\", filename[i])) fetch(resolved);\n    if (sync) return self;\n    if (!queued) finish(null, self);\n    return undefined;\n};\n// function load(filename:string, options:IParseOptions, callback:LoadCallback):undefined\n/**\n * Loads one or multiple .proto or preprocessed .json files into this root namespace and calls the callback.\n * @function Root#load\n * @param {string|string[]} filename Names of one or multiple files to load\n * @param {LoadCallback} callback Callback function\n * @returns {undefined}\n * @variation 2\n */ // function load(filename:string, callback:LoadCallback):undefined\n/**\n * Loads one or multiple .proto or preprocessed .json files into this root namespace and returns a promise.\n * @function Root#load\n * @param {string|string[]} filename Names of one or multiple files to load\n * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.\n * @returns {Promise<Root>} Promise\n * @variation 3\n */ // function load(filename:string, [options:IParseOptions]):Promise<Root>\n/**\n * Synchronously loads one or multiple .proto or preprocessed .json files into this root namespace (node only).\n * @function Root#loadSync\n * @param {string|string[]} filename Names of one or multiple files to load\n * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.\n * @returns {Root} Root namespace\n * @throws {Error} If synchronous fetching is not supported (i.e. in browsers) or if a file's syntax is invalid\n */ Root.prototype.loadSync = function loadSync(filename, options) {\n    if (!util.isNode) throw Error(\"not supported\");\n    return this.load(filename, options, SYNC);\n};\n/**\n * @override\n */ Root.prototype.resolveAll = function resolveAll() {\n    if (this.deferred.length) throw Error(\"unresolvable extensions: \" + this.deferred.map(function(field) {\n        return \"'extend \" + field.extend + \"' in \" + field.parent.fullName;\n    }).join(\", \"));\n    return Namespace.prototype.resolveAll.call(this);\n};\n// only uppercased (and thus conflict-free) children are exposed, see below\nvar exposeRe = /^[A-Z]/;\n/**\n * Handles a deferred declaring extension field by creating a sister field to represent it within its extended type.\n * @param {Root} root Root instance\n * @param {Field} field Declaring extension field witin the declaring type\n * @returns {boolean} `true` if successfully added to the extended type, `false` otherwise\n * @inner\n * @ignore\n */ function tryHandleExtension(root, field) {\n    var extendedType = field.parent.lookup(field.extend);\n    if (extendedType) {\n        var sisterField = new Field(field.fullName, field.id, field.type, field.rule, undefined, field.options);\n        //do not allow to extend same field twice to prevent the error\n        if (extendedType.get(sisterField.name)) {\n            return true;\n        }\n        sisterField.declaringField = field;\n        field.extensionField = sisterField;\n        extendedType.add(sisterField);\n        return true;\n    }\n    return false;\n}\n/**\n * Called when any object is added to this root or its sub-namespaces.\n * @param {ReflectionObject} object Object added\n * @returns {undefined}\n * @private\n */ Root.prototype._handleAdd = function _handleAdd(object) {\n    if (object instanceof Field) {\n        if (/* an extension field (implies not part of a oneof) */ object.extend !== undefined && /* not already handled */ !object.extensionField) {\n            if (!tryHandleExtension(this, object)) this.deferred.push(object);\n        }\n    } else if (object instanceof Enum) {\n        if (exposeRe.test(object.name)) object.parent[object.name] = object.values; // expose enum values as property of its parent\n    } else if (!(object instanceof OneOf)) /* everything else is a namespace */ {\n        if (object instanceof Type) for(var i = 0; i < this.deferred.length;)if (tryHandleExtension(this, this.deferred[i])) this.deferred.splice(i, 1);\n        else ++i;\n        for(var j = 0; j < /* initializes */ object.nestedArray.length; ++j)this._handleAdd(object._nestedArray[j]);\n        if (exposeRe.test(object.name)) object.parent[object.name] = object; // expose namespace as property of its parent\n    }\n// The above also adds uppercased (and thus conflict-free) nested types, services and enums as\n// properties of namespaces just like static code does. This allows using a .d.ts generated for\n// a static module with reflection-based solutions where the condition is met.\n};\n/**\n * Called when any object is removed from this root or its sub-namespaces.\n * @param {ReflectionObject} object Object removed\n * @returns {undefined}\n * @private\n */ Root.prototype._handleRemove = function _handleRemove(object) {\n    if (object instanceof Field) {\n        if (/* an extension field */ object.extend !== undefined) {\n            if (/* already handled */ object.extensionField) {\n                object.extensionField.parent.remove(object.extensionField);\n                object.extensionField = null;\n            } else {\n                var index = this.deferred.indexOf(object);\n                /* istanbul ignore else */ if (index > -1) this.deferred.splice(index, 1);\n            }\n        }\n    } else if (object instanceof Enum) {\n        if (exposeRe.test(object.name)) delete object.parent[object.name]; // unexpose enum values\n    } else if (object instanceof Namespace) {\n        for(var i = 0; i < /* initializes */ object.nestedArray.length; ++i)this._handleRemove(object._nestedArray[i]);\n        if (exposeRe.test(object.name)) delete object.parent[object.name]; // unexpose namespaces\n    }\n};\n// Sets up cyclic dependencies (called in index-light)\nRoot._configure = function(Type_, parse_, common_) {\n    Type = Type_;\n    parse = parse_;\n    common = common_;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3Jvb3QuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsT0FBT0MsT0FBTyxHQUFHQztBQUVqQixvQkFBb0I7QUFDcEIsSUFBSUMsWUFBWUMsbUJBQU9BLENBQUMsc0VBQWE7QUFDcEMsRUFBQ0YsS0FBS0csU0FBUyxHQUFHQyxPQUFPQyxNQUFNLENBQUNKLFVBQVVFLFNBQVMsR0FBR0csV0FBVyxHQUFHTixJQUFHLEVBQUdPLFNBQVMsR0FBRztBQUV2RixJQUFJQyxRQUFVTixtQkFBT0EsQ0FBQyw4REFBUyxHQUMzQk8sT0FBVVAsbUJBQU9BLENBQUMsNERBQVEsR0FDMUJRLFFBQVVSLG1CQUFPQSxDQUFDLDhEQUFTLEdBQzNCUyxPQUFVVCxtQkFBT0EsQ0FBQyw0REFBUTtBQUU5QixJQUFJVSxNQUNBQyxPQUNBQyxRQUFRLElBQUk7QUFFaEI7Ozs7OztDQU1DLEdBQ0QsU0FBU2QsS0FBS2UsT0FBTztJQUNqQmQsVUFBVWUsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJRDtJQUV6Qjs7O0tBR0MsR0FDRCxJQUFJLENBQUNFLFFBQVEsR0FBRyxFQUFFO0lBRWxCOzs7S0FHQyxHQUNELElBQUksQ0FBQ0MsS0FBSyxHQUFHLEVBQUU7QUFDbkI7QUFFQTs7Ozs7Q0FLQyxHQUNEbEIsS0FBS21CLFFBQVEsR0FBRyxTQUFTQSxTQUFTQyxJQUFJLEVBQUVDLElBQUk7SUFDeEMsSUFBSSxDQUFDQSxNQUNEQSxPQUFPLElBQUlyQjtJQUNmLElBQUlvQixLQUFLTCxPQUFPLEVBQ1pNLEtBQUtDLFVBQVUsQ0FBQ0YsS0FBS0wsT0FBTztJQUNoQyxPQUFPTSxLQUFLRSxPQUFPLENBQUNILEtBQUtJLE1BQU07QUFDbkM7QUFFQTs7Ozs7OztDQU9DLEdBQ0R4QixLQUFLRyxTQUFTLENBQUNzQixXQUFXLEdBQUdkLEtBQUtlLElBQUksQ0FBQ0MsT0FBTztBQUU5Qzs7Ozs7OztDQU9DLEdBQ0QzQixLQUFLRyxTQUFTLENB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QixTQUFTZSxJQUFJLENBQUNELE9BQU9MLElBQUksR0FDekIsT0FBT0ssT0FBT2pCLE1BQU0sQ0FBQ2lCLE9BQU9MLElBQUksQ0FBQyxFQUFFLHNCQUFzQjtJQUVqRTtBQUNKO0FBRUEsc0RBQXNEO0FBQ3REbkYsS0FBS2tHLFVBQVUsR0FBRyxTQUFTQyxLQUFLLEVBQUVDLE1BQU0sRUFBRUMsT0FBTztJQUM3Q3pGLE9BQVN1RjtJQUNUdEYsUUFBU3VGO0lBQ1R0RixTQUFTdUY7QUFDYiIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcm9vdC5qcz84MTVhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBSb290O1xuXG4vLyBleHRlbmRzIE5hbWVzcGFjZVxudmFyIE5hbWVzcGFjZSA9IHJlcXVpcmUoXCIuL25hbWVzcGFjZVwiKTtcbigoUm9vdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE5hbWVzcGFjZS5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IFJvb3QpLmNsYXNzTmFtZSA9IFwiUm9vdFwiO1xuXG52YXIgRmllbGQgICA9IHJlcXVpcmUoXCIuL2ZpZWxkXCIpLFxuICAgIEVudW0gICAgPSByZXF1aXJlKFwiLi9lbnVtXCIpLFxuICAgIE9uZU9mICAgPSByZXF1aXJlKFwiLi9vbmVvZlwiKSxcbiAgICB1dGlsICAgID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcblxudmFyIFR5cGUsICAgLy8gY3ljbGljXG4gICAgcGFyc2UsICAvLyBtaWdodCBiZSBleGNsdWRlZFxuICAgIGNvbW1vbjsgLy8gXCJcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHJvb3QgbmFtZXNwYWNlIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBSb290IG5hbWVzcGFjZSB3cmFwcGluZyBhbGwgdHlwZXMsIGVudW1zLCBzZXJ2aWNlcywgc3ViLW5hbWVzcGFjZXMgZXRjLiB0aGF0IGJlbG9uZyB0b2dldGhlci5cbiAqIEBleHRlbmRzIE5hbWVzcGFjZUJhc2VcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gW29wdGlvbnNdIFRvcCBsZXZlbCBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIFJvb3Qob3B0aW9ucykge1xuICAgIE5hbWVzcGFjZS5jYWxsKHRoaXMsIFwiXCIsIG9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogRGVmZXJyZWQgZXh0ZW5zaW9uIGZpZWxkcy5cbiAgICAgKiBAdHlwZSB7RmllbGRbXX1cbiAgICAgKi9cbiAgICB0aGlzLmRlZmVycmVkID0gW107XG5cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlZCBmaWxlIG5hbWVzIG9mIGxvYWRlZCBmaWxlcy5cbiAgICAgKiBAdHlwZSB7c3RyaW5nW119XG4gICAgICovXG4gICAgdGhpcy5maWxlcyA9IFtdO1xufVxuXG4vKipcbiAqIExvYWRzIGEgbmFtZXNwYWNlIGRlc2NyaXB0b3IgaW50byBhIHJvb3QgbmFtZXNwYWNlLlxuICogQHBhcmFtIHtJTmFtZXNwYWNlfSBqc29uIE5hbWVlc3BhY2UgZGVzY3JpcHRvclxuICogQHBhcmFtIHtSb290fSBbcm9vdF0gUm9vdCBuYW1lc3BhY2UsIGRlZmF1bHRzIHRvIGNyZWF0ZSBhIG5ldyBvbmUgaWYgb21pdHRlZFxuICogQHJldHVybnMge1Jvb3R9IFJvb3QgbmFtZXNwYWNlXG4gKi9cblJvb3QuZnJvbUpTT04gPSBmdW5jdGlvbiBmcm9tSlNPTihqc29uLCByb290KSB7XG4gICAgaWYgKCFyb290KVxuICAgICAgICByb290ID0gbmV3IFJvb3QoKTtcbiAgICBpZiAoanNvbi5vcHRpb25zKVxuICAgICAgICByb290LnNldE9wdGlvbnMoanNvbi5vcHRpb25zKTtcbiAgICByZXR1cm4gcm9vdC5hZGRKU09OKGpzb24ubmVzdGVkKTtcbn07XG5cbi8qKlxuICogUmVzb2x2ZXMgdGhlIHBhdGggb2YgYW4gaW1wb3J0ZWQgZmlsZSwgcmVsYXRpdmUgdG8gdGhlIGltcG9ydGluZyBvcmlnaW4uXG4gKiBUaGlzIG1ldGhvZCBleGlzdHMgc28geW91IGNhbiBvdmVycmlkZSBpdCB3aXRoIHlvdXIgb3duIGxvZ2ljIGluIGNhc2UgeW91ciBpbXBvcnRzIGFyZSBzY2F0dGVyZWQgb3ZlciBtdWx0aXBsZSBkaXJlY3Rvcmllcy5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IG9yaWdpbiBUaGUgZmlsZSBuYW1lIG9mIHRoZSBpbXBvcnRpbmcgZmlsZVxuICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldCBUaGUgZmlsZSBuYW1lIGJlaW5nIGltcG9ydGVkXG4gKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IFJlc29sdmVkIHBhdGggdG8gYHRhcmdldGAgb3IgYG51bGxgIHRvIHNraXAgdGhlIGZpbGVcbiAqL1xuUm9vdC5wcm90b3R5cGUucmVzb2x2ZVBhdGggPSB1dGlsLnBhdGgucmVzb2x2ZTtcblxuLyoqXG4gKiBGZXRjaCBjb250ZW50IGZyb20gZmlsZSBwYXRoIG9yIHVybFxuICogVGhpcyBtZXRob2QgZXhpc3RzIHNvIHlvdSBjYW4gb3ZlcnJpZGUgaXQgd2l0aCB5b3VyIG93biBsb2dpYy5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggRmlsZSBwYXRoIG9yIHVybFxuICogQHBhcmFtIHtGZXRjaENhbGxiYWNrfSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuUm9vdC5wcm90b3R5cGUuZmV0Y2ggPSB1dGlsLmZldGNoO1xuXG4vLyBBIHN5bWJvbC1saWtlIGZ1bmN0aW9uIHRvIHNhZmVseSBzaWduYWwgc3luY2hyb25vdXMgbG9hZGluZ1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIFNZTkMoKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWVtcHR5LWZ1bmN0aW9uXG5cbi8qKlxuICogTG9hZHMgb25lIG9yIG11bHRpcGxlIC5wcm90byBvciBwcmVwcm9jZXNzZWQgLmpzb24gZmlsZXMgaW50byB0aGlzIHJvb3QgbmFtZXNwYWNlIGFuZCBjYWxscyB0aGUgY2FsbGJhY2suXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gZmlsZW5hbWUgTmFtZXMgb2Ygb25lIG9yIG11bHRpcGxlIGZpbGVzIHRvIGxvYWRcbiAqIEBwYXJhbSB7SVBhcnNlT3B0aW9uc30gb3B0aW9ucyBQYXJzZSBvcHRpb25zXG4gKiBAcGFyYW0ge0xvYWRDYWxsYmFja30gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cblJvb3QucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiBsb2FkKGZpbGVuYW1lLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICAgICAgb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmICghY2FsbGJhY2spXG4gICAgICAgIHJldHVybiB1dGlsLmFzUHJvbWlzZShsb2FkLCBzZWxmLCBmaWxlbmFtZSwgb3B0aW9ucyk7XG5cbiAgICB2YXIgc3luYyA9IGNhbGxiYWNrID09PSBTWU5DOyAvLyB1bmRvY3VtZW50ZWRcblxuICAgIC8vIEZpbmlzaGVzIGxvYWRpbmcgYnkgY2FsbGluZyB0aGUgY2FsbGJhY2sgKGV4YWN0bHkgb25jZSlcbiAgICBmdW5jdGlvbiBmaW5pc2goZXJyLCByb290KSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIWNhbGxiYWNrKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoc3luYylcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgdmFyIGNiID0gY2FsbGJhY2s7XG4gICAgICAgIGNhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgY2IoZXJyLCByb290KTtcbiAgICB9XG5cbiAgICAvLyBCdW5kbGVkIGRlZmluaXRpb24gZXhpc3RlbmNlIGNoZWNraW5nXG4gICAgZnVuY3Rpb24gZ2V0QnVuZGxlZEZpbGVOYW1lKGZpbGVuYW1lKSB7XG4gICAgICAgIHZhciBpZHggPSBmaWxlbmFtZS5sYXN0SW5kZXhPZihcImdvb2dsZS9wcm90b2J1Zi9cIik7XG4gICAgICAgIGlmIChpZHggPiAtMSkge1xuICAgICAgICAgICAgdmFyIGFsdG5hbWUgPSBmaWxlbmFtZS5zdWJzdHJpbmcoaWR4KTtcbiAgICAgICAgICAgIGlmIChhbHRuYW1lIGluIGNvbW1vbikgcmV0dXJuIGFsdG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gUHJvY2Vzc2VzIGEgc2luZ2xlIGZpbGVcbiAgICBmdW5jdGlvbiBwcm9jZXNzKGZpbGVuYW1lLCBzb3VyY2UpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh1dGlsLmlzU3RyaW5nKHNvdXJjZSkgJiYgc291cmNlLmNoYXJBdCgwKSA9PT0gXCJ7XCIpXG4gICAgICAgICAgICAgICAgc291cmNlID0gSlNPTi5wYXJzZShzb3VyY2UpO1xuICAgICAgICAgICAgaWYgKCF1dGlsLmlzU3RyaW5nKHNvdXJjZSkpXG4gICAgICAgICAgICAgICAgc2VsZi5zZXRPcHRpb25zKHNvdXJjZS5vcHRpb25zKS5hZGRKU09OKHNvdXJjZS5uZXN0ZWQpO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyc2UuZmlsZW5hbWUgPSBmaWxlbmFtZTtcbiAgICAgICAgICAgICAgICB2YXIgcGFyc2VkID0gcGFyc2Uoc291cmNlLCBzZWxmLCBvcHRpb25zKSxcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWQsXG4gICAgICAgICAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZWQuaW1wb3J0cylcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IGkgPCBwYXJzZWQuaW1wb3J0cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlZCA9IGdldEJ1bmRsZWRGaWxlTmFtZShwYXJzZWQuaW1wb3J0c1tpXSkgfHwgc2VsZi5yZXNvbHZlUGF0aChmaWxlbmFtZSwgcGFyc2VkLmltcG9ydHNbaV0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZldGNoKHJlc29sdmVkKTtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VkLndlYWtJbXBvcnRzKVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFyc2VkLndlYWtJbXBvcnRzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc29sdmVkID0gZ2V0QnVuZGxlZEZpbGVOYW1lKHBhcnNlZC53ZWFrSW1wb3J0c1tpXSkgfHwgc2VsZi5yZXNvbHZlUGF0aChmaWxlbmFtZSwgcGFyc2VkLndlYWtJbXBvcnRzW2ldKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZXRjaChyZXNvbHZlZCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgZmluaXNoKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzeW5jICYmICFxdWV1ZWQpXG4gICAgICAgICAgICBmaW5pc2gobnVsbCwgc2VsZik7IC8vIG9ubHkgb25jZSBhbnl3YXlcbiAgICB9XG5cbiAgICAvLyBGZXRjaGVzIGEgc2luZ2xlIGZpbGVcbiAgICBmdW5jdGlvbiBmZXRjaChmaWxlbmFtZSwgd2Vhaykge1xuICAgICAgICBmaWxlbmFtZSA9IGdldEJ1bmRsZWRGaWxlTmFtZShmaWxlbmFtZSkgfHwgZmlsZW5hbWU7XG5cbiAgICAgICAgLy8gU2tpcCBpZiBhbHJlYWR5IGxvYWRlZCAvIGF0dGVtcHRlZFxuICAgICAgICBpZiAoc2VsZi5maWxlcy5pbmRleE9mKGZpbGVuYW1lKSA+IC0xKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBzZWxmLmZpbGVzLnB1c2goZmlsZW5hbWUpO1xuXG4gICAgICAgIC8vIFNob3J0Y3V0IGJ1bmRsZWQgZGVmaW5pdGlvbnNcbiAgICAgICAgaWYgKGZpbGVuYW1lIGluIGNvbW1vbikge1xuICAgICAgICAgICAgaWYgKHN5bmMpXG4gICAgICAgICAgICAgICAgcHJvY2VzcyhmaWxlbmFtZSwgY29tbW9uW2ZpbGVuYW1lXSk7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICArK3F1ZXVlZDtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAtLXF1ZXVlZDtcbiAgICAgICAgICAgICAgICAgICAgcHJvY2VzcyhmaWxlbmFtZSwgY29tbW9uW2ZpbGVuYW1lXSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPdGhlcndpc2UgZmV0Y2ggZnJvbSBkaXNrIG9yIG5ldHdvcmtcbiAgICAgICAgaWYgKHN5bmMpIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2U7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHNvdXJjZSA9IHV0aWwuZnMucmVhZEZpbGVTeW5jKGZpbGVuYW1lKS50b1N0cmluZyhcInV0ZjhcIik7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXdlYWspXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaChlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb2Nlc3MoZmlsZW5hbWUsIHNvdXJjZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICArK3F1ZXVlZDtcbiAgICAgICAgICAgIHNlbGYuZmV0Y2goZmlsZW5hbWUsIGZ1bmN0aW9uKGVyciwgc291cmNlKSB7XG4gICAgICAgICAgICAgICAgLS1xdWV1ZWQ7XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgaWYgKCFjYWxsYmFjaylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAvLyB0ZXJtaW5hdGVkIG1lYW53aGlsZVxuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF3ZWFrKVxuICAgICAgICAgICAgICAgICAgICAgICAgZmluaXNoKGVycik7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFxdWV1ZWQpIC8vIGNhbid0IGJlIGNvdmVyZWQgcmVsaWFibHlcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaChudWxsLCBzZWxmKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcm9jZXNzKGZpbGVuYW1lLCBzb3VyY2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIHF1ZXVlZCA9IDA7XG5cbiAgICAvLyBBc3NlbWJsaW5nIHRoZSByb290IG5hbWVzcGFjZSBkb2Vzbid0IHJlcXVpcmUgd29ya2luZyB0eXBlXG4gICAgLy8gcmVmZXJlbmNlcyBhbnltb3JlLCBzbyB3ZSBjYW4gbG9hZCBldmVyeXRoaW5nIGluIHBhcmFsbGVsXG4gICAgaWYgKHV0aWwuaXNTdHJpbmcoZmlsZW5hbWUpKVxuICAgICAgICBmaWxlbmFtZSA9IFsgZmlsZW5hbWUgXTtcbiAgICBmb3IgKHZhciBpID0gMCwgcmVzb2x2ZWQ7IGkgPCBmaWxlbmFtZS5sZW5ndGg7ICsraSlcbiAgICAgICAgaWYgKHJlc29sdmVkID0gc2VsZi5yZXNvbHZlUGF0aChcIlwiLCBmaWxlbmFtZVtpXSkpXG4gICAgICAgICAgICBmZXRjaChyZXNvbHZlZCk7XG5cbiAgICBpZiAoc3luYylcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgaWYgKCFxdWV1ZWQpXG4gICAgICAgIGZpbmlzaChudWxsLCBzZWxmKTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufTtcbi8vIGZ1bmN0aW9uIGxvYWQoZmlsZW5hbWU6c3RyaW5nLCBvcHRpb25zOklQYXJzZU9wdGlvbnMsIGNhbGxiYWNrOkxvYWRDYWxsYmFjayk6dW5kZWZpbmVkXG5cbi8qKlxuICogTG9hZHMgb25lIG9yIG11bHRpcGxlIC5wcm90byBvciBwcmVwcm9jZXNzZWQgLmpzb24gZmlsZXMgaW50byB0aGlzIHJvb3QgbmFtZXNwYWNlIGFuZCBjYWxscyB0aGUgY2FsbGJhY2suXG4gKiBAZnVuY3Rpb24gUm9vdCNsb2FkXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gZmlsZW5hbWUgTmFtZXMgb2Ygb25lIG9yIG11bHRpcGxlIGZpbGVzIHRvIGxvYWRcbiAqIEBwYXJhbSB7TG9hZENhbGxiYWNrfSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqIEB2YXJpYXRpb24gMlxuICovXG4vLyBmdW5jdGlvbiBsb2FkKGZpbGVuYW1lOnN0cmluZywgY2FsbGJhY2s6TG9hZENhbGxiYWNrKTp1bmRlZmluZWRcblxuLyoqXG4gKiBMb2FkcyBvbmUgb3IgbXVsdGlwbGUgLnByb3RvIG9yIHByZXByb2Nlc3NlZCAuanNvbiBmaWxlcyBpbnRvIHRoaXMgcm9vdCBuYW1lc3BhY2UgYW5kIHJldHVybnMgYSBwcm9taXNlLlxuICogQGZ1bmN0aW9uIFJvb3QjbG9hZFxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IGZpbGVuYW1lIE5hbWVzIG9mIG9uZSBvciBtdWx0aXBsZSBmaWxlcyB0byBsb2FkXG4gKiBAcGFyYW0ge0lQYXJzZU9wdGlvbnN9IFtvcHRpb25zXSBQYXJzZSBvcHRpb25zLiBEZWZhdWx0cyB0byB7QGxpbmsgcGFyc2UuZGVmYXVsdHN9IHdoZW4gb21pdHRlZC5cbiAqIEByZXR1cm5zIHtQcm9taXNlPFJvb3Q+fSBQcm9taXNlXG4gKiBAdmFyaWF0aW9uIDNcbiAqL1xuLy8gZnVuY3Rpb24gbG9hZChmaWxlbmFtZTpzdHJpbmcsIFtvcHRpb25zOklQYXJzZU9wdGlvbnNdKTpQcm9taXNlPFJvb3Q+XG5cbi8qKlxuICogU3luY2hyb25vdXNseSBsb2FkcyBvbmUgb3IgbXVsdGlwbGUgLnByb3RvIG9yIHByZXByb2Nlc3NlZCAuanNvbiBmaWxlcyBpbnRvIHRoaXMgcm9vdCBuYW1lc3BhY2UgKG5vZGUgb25seSkuXG4gKiBAZnVuY3Rpb24gUm9vdCNsb2FkU3luY1xuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IGZpbGVuYW1lIE5hbWVzIG9mIG9uZSBvciBtdWx0aXBsZSBmaWxlcyB0byBsb2FkXG4gKiBAcGFyYW0ge0lQYXJzZU9wdGlvbnN9IFtvcHRpb25zXSBQYXJzZSBvcHRpb25zLiBEZWZhdWx0cyB0byB7QGxpbmsgcGFyc2UuZGVmYXVsdHN9IHdoZW4gb21pdHRlZC5cbiAqIEByZXR1cm5zIHtSb290fSBSb290IG5hbWVzcGFjZVxuICogQHRocm93cyB7RXJyb3J9IElmIHN5bmNocm9ub3VzIGZldGNoaW5nIGlzIG5vdCBzdXBwb3J0ZWQgKGkuZS4gaW4gYnJvd3NlcnMpIG9yIGlmIGEgZmlsZSdzIHN5bnRheCBpcyBpbnZhbGlkXG4gKi9cblJvb3QucHJvdG90eXBlLmxvYWRTeW5jID0gZnVuY3Rpb24gbG9hZFN5bmMoZmlsZW5hbWUsIG9wdGlvbnMpIHtcbiAgICBpZiAoIXV0aWwuaXNOb2RlKVxuICAgICAgICB0aHJvdyBFcnJvcihcIm5vdCBzdXBwb3J0ZWRcIik7XG4gICAgcmV0dXJuIHRoaXMubG9hZChmaWxlbmFtZSwgb3B0aW9ucywgU1lOQyk7XG59O1xuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5Sb290LnByb3RvdHlwZS5yZXNvbHZlQWxsID0gZnVuY3Rpb24gcmVzb2x2ZUFsbCgpIHtcbiAgICBpZiAodGhpcy5kZWZlcnJlZC5sZW5ndGgpXG4gICAgICAgIHRocm93IEVycm9yKFwidW5yZXNvbHZhYmxlIGV4dGVuc2lvbnM6IFwiICsgdGhpcy5kZWZlcnJlZC5tYXAoZnVuY3Rpb24oZmllbGQpIHtcbiAgICAgICAgICAgIHJldHVybiBcIidleHRlbmQgXCIgKyBmaWVsZC5leHRlbmQgKyBcIicgaW4gXCIgKyBmaWVsZC5wYXJlbnQuZnVsbE5hbWU7XG4gICAgICAgIH0pLmpvaW4oXCIsIFwiKSk7XG4gICAgcmV0dXJuIE5hbWVzcGFjZS5wcm90b3R5cGUucmVzb2x2ZUFsbC5jYWxsKHRoaXMpO1xufTtcblxuLy8gb25seSB1cHBlcmNhc2VkIChhbmQgdGh1cyBjb25mbGljdC1mcmVlKSBjaGlsZHJlbiBhcmUgZXhwb3NlZCwgc2VlIGJlbG93XG52YXIgZXhwb3NlUmUgPSAvXltBLVpdLztcblxuLyoqXG4gKiBIYW5kbGVzIGEgZGVmZXJyZWQgZGVjbGFyaW5nIGV4dGVuc2lvbiBmaWVsZCBieSBjcmVhdGluZyBhIHNpc3RlciBmaWVsZCB0byByZXByZXNlbnQgaXQgd2l0aGluIGl0cyBleHRlbmRlZCB0eXBlLlxuICogQHBhcmFtIHtSb290fSByb290IFJvb3QgaW5zdGFuY2VcbiAqIEBwYXJhbSB7RmllbGR9IGZpZWxkIERlY2xhcmluZyBleHRlbnNpb24gZmllbGQgd2l0aW4gdGhlIGRlY2xhcmluZyB0eXBlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHN1Y2Nlc3NmdWxseSBhZGRlZCB0byB0aGUgZXh0ZW5kZWQgdHlwZSwgYGZhbHNlYCBvdGhlcndpc2VcbiAqIEBpbm5lclxuICogQGlnbm9yZVxuICovXG5mdW5jdGlvbiB0cnlIYW5kbGVFeHRlbnNpb24ocm9vdCwgZmllbGQpIHtcbiAgICB2YXIgZXh0ZW5kZWRUeXBlID0gZmllbGQucGFyZW50Lmxvb2t1cChmaWVsZC5leHRlbmQpO1xuICAgIGlmIChleHRlbmRlZFR5cGUpIHtcbiAgICAgICAgdmFyIHNpc3RlckZpZWxkID0gbmV3IEZpZWxkKGZpZWxkLmZ1bGxOYW1lLCBmaWVsZC5pZCwgZmllbGQudHlwZSwgZmllbGQucnVsZSwgdW5kZWZpbmVkLCBmaWVsZC5vcHRpb25zKTtcbiAgICAgICAgLy9kbyBub3QgYWxsb3cgdG8gZXh0ZW5kIHNhbWUgZmllbGQgdHdpY2UgdG8gcHJldmVudCB0aGUgZXJyb3JcbiAgICAgICAgaWYgKGV4dGVuZGVkVHlwZS5nZXQoc2lzdGVyRmllbGQubmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHNpc3RlckZpZWxkLmRlY2xhcmluZ0ZpZWxkID0gZmllbGQ7XG4gICAgICAgIGZpZWxkLmV4dGVuc2lvbkZpZWxkID0gc2lzdGVyRmllbGQ7XG4gICAgICAgIGV4dGVuZGVkVHlwZS5hZGQoc2lzdGVyRmllbGQpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENhbGxlZCB3aGVuIGFueSBvYmplY3QgaXMgYWRkZWQgdG8gdGhpcyByb290IG9yIGl0cyBzdWItbmFtZXNwYWNlcy5cbiAqIEBwYXJhbSB7UmVmbGVjdGlvbk9iamVjdH0gb2JqZWN0IE9iamVjdCBhZGRlZFxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqIEBwcml2YXRlXG4gKi9cblJvb3QucHJvdG90eXBlLl9oYW5kbGVBZGQgPSBmdW5jdGlvbiBfaGFuZGxlQWRkKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBGaWVsZCkge1xuXG4gICAgICAgIGlmICgvKiBhbiBleHRlbnNpb24gZmllbGQgKGltcGxpZXMgbm90IHBhcnQgb2YgYSBvbmVvZikgKi8gb2JqZWN0LmV4dGVuZCAhPT0gdW5kZWZpbmVkICYmIC8qIG5vdCBhbHJlYWR5IGhhbmRsZWQgKi8gIW9iamVjdC5leHRlbnNpb25GaWVsZClcbiAgICAgICAgICAgIGlmICghdHJ5SGFuZGxlRXh0ZW5zaW9uKHRoaXMsIG9iamVjdCkpXG4gICAgICAgICAgICAgICAgdGhpcy5kZWZlcnJlZC5wdXNoKG9iamVjdCk7XG5cbiAgICB9IGVsc2UgaWYgKG9iamVjdCBpbnN0YW5jZW9mIEVudW0pIHtcblxuICAgICAgICBpZiAoZXhwb3NlUmUudGVzdChvYmplY3QubmFtZSkpXG4gICAgICAgICAgICBvYmplY3QucGFyZW50W29iamVjdC5uYW1lXSA9IG9iamVjdC52YWx1ZXM7IC8vIGV4cG9zZSBlbnVtIHZhbHVlcyBhcyBwcm9wZXJ0eSBvZiBpdHMgcGFyZW50XG5cbiAgICB9IGVsc2UgaWYgKCEob2JqZWN0IGluc3RhbmNlb2YgT25lT2YpKSAvKiBldmVyeXRoaW5nIGVsc2UgaXMgYSBuYW1lc3BhY2UgKi8ge1xuXG4gICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBUeXBlKSAvLyBUcnkgdG8gaGFuZGxlIGFueSBkZWZlcnJlZCBleHRlbnNpb25zXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGVmZXJyZWQubGVuZ3RoOylcbiAgICAgICAgICAgICAgICBpZiAodHJ5SGFuZGxlRXh0ZW5zaW9uKHRoaXMsIHRoaXMuZGVmZXJyZWRbaV0pKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlZmVycmVkLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICsraTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCAvKiBpbml0aWFsaXplcyAqLyBvYmplY3QubmVzdGVkQXJyYXkubGVuZ3RoOyArK2opIC8vIHJlY3Vyc2UgaW50byB0aGUgbmFtZXNwYWNlXG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVBZGQob2JqZWN0Ll9uZXN0ZWRBcnJheVtqXSk7XG4gICAgICAgIGlmIChleHBvc2VSZS50ZXN0KG9iamVjdC5uYW1lKSlcbiAgICAgICAgICAgIG9iamVjdC5wYXJlbnRbb2JqZWN0Lm5hbWVdID0gb2JqZWN0OyAvLyBleHBvc2UgbmFtZXNwYWNlIGFzIHByb3BlcnR5IG9mIGl0cyBwYXJlbnRcbiAgICB9XG5cbiAgICAvLyBUaGUgYWJvdmUgYWxzbyBhZGRzIHVwcGVyY2FzZWQgKGFuZCB0aHVzIGNvbmZsaWN0LWZyZWUpIG5lc3RlZCB0eXBlcywgc2VydmljZXMgYW5kIGVudW1zIGFzXG4gICAgLy8gcHJvcGVydGllcyBvZiBuYW1lc3BhY2VzIGp1c3QgbGlrZSBzdGF0aWMgY29kZSBkb2VzLiBUaGlzIGFsbG93cyB1c2luZyBhIC5kLnRzIGdlbmVyYXRlZCBmb3JcbiAgICAvLyBhIHN0YXRpYyBtb2R1bGUgd2l0aCByZWZsZWN0aW9uLWJhc2VkIHNvbHV0aW9ucyB3aGVyZSB0aGUgY29uZGl0aW9uIGlzIG1ldC5cbn07XG5cbi8qKlxuICogQ2FsbGVkIHdoZW4gYW55IG9iamVjdCBpcyByZW1vdmVkIGZyb20gdGhpcyByb290IG9yIGl0cyBzdWItbmFtZXNwYWNlcy5cbiAqIEBwYXJhbSB7UmVmbGVjdGlvbk9iamVjdH0gb2JqZWN0IE9iamVjdCByZW1vdmVkXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICogQHByaXZhdGVcbiAqL1xuUm9vdC5wcm90b3R5cGUuX2hhbmRsZVJlbW92ZSA9IGZ1bmN0aW9uIF9oYW5kbGVSZW1vdmUob2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIEZpZWxkKSB7XG5cbiAgICAgICAgaWYgKC8qIGFuIGV4dGVuc2lvbiBmaWVsZCAqLyBvYmplY3QuZXh0ZW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICgvKiBhbHJlYWR5IGhhbmRsZWQgKi8gb2JqZWN0LmV4dGVuc2lvbkZpZWxkKSB7IC8vIHJlbW92ZSBpdHMgc2lzdGVyIGZpZWxkXG4gICAgICAgICAgICAgICAgb2JqZWN0LmV4dGVuc2lvbkZpZWxkLnBhcmVudC5yZW1vdmUob2JqZWN0LmV4dGVuc2lvbkZpZWxkKTtcbiAgICAgICAgICAgICAgICBvYmplY3QuZXh0ZW5zaW9uRmllbGQgPSBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHsgLy8gY2FuY2VsIHRoZSBleHRlbnNpb25cbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmRlZmVycmVkLmluZGV4T2Yob2JqZWN0KTtcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlZmVycmVkLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAob2JqZWN0IGluc3RhbmNlb2YgRW51bSkge1xuXG4gICAgICAgIGlmIChleHBvc2VSZS50ZXN0KG9iamVjdC5uYW1lKSlcbiAgICAgICAgICAgIGRlbGV0ZSBvYmplY3QucGFyZW50W29iamVjdC5uYW1lXTsgLy8gdW5leHBvc2UgZW51bSB2YWx1ZXNcblxuICAgIH0gZWxzZSBpZiAob2JqZWN0IGluc3RhbmNlb2YgTmFtZXNwYWNlKSB7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAvKiBpbml0aWFsaXplcyAqLyBvYmplY3QubmVzdGVkQXJyYXkubGVuZ3RoOyArK2kpIC8vIHJlY3Vyc2UgaW50byB0aGUgbmFtZXNwYWNlXG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVSZW1vdmUob2JqZWN0Ll9uZXN0ZWRBcnJheVtpXSk7XG5cbiAgICAgICAgaWYgKGV4cG9zZVJlLnRlc3Qob2JqZWN0Lm5hbWUpKVxuICAgICAgICAgICAgZGVsZXRlIG9iamVjdC5wYXJlbnRbb2JqZWN0Lm5hbWVdOyAvLyB1bmV4cG9zZSBuYW1lc3BhY2VzXG5cbiAgICB9XG59O1xuXG4vLyBTZXRzIHVwIGN5Y2xpYyBkZXBlbmRlbmNpZXMgKGNhbGxlZCBpbiBpbmRleC1saWdodClcblJvb3QuX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uKFR5cGVfLCBwYXJzZV8sIGNvbW1vbl8pIHtcbiAgICBUeXBlICAgPSBUeXBlXztcbiAgICBwYXJzZSAgPSBwYXJzZV87XG4gICAgY29tbW9uID0gY29tbW9uXztcbn07XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsIlJvb3QiLCJOYW1lc3BhY2UiLCJyZXF1aXJlIiwicHJvdG90eXBlIiwiT2JqZWN0IiwiY3JlYXRlIiwiY29uc3RydWN0b3IiLCJjbGFzc05hbWUiLCJGaWVsZCIsIkVudW0iLCJPbmVPZiIsInV0aWwiLCJUeXBlIiwicGFyc2UiLCJjb21tb24iLCJvcHRpb25zIiwiY2FsbCIsImRlZmVycmVkIiwiZmlsZXMiLCJmcm9tSlNPTiIsImpzb24iLCJyb290Iiwic2V0T3B0aW9ucyIsImFkZEpTT04iLCJuZXN0ZWQiLCJyZXNvbHZlUGF0aCIsInBhdGgiLCJyZXNvbHZlIiwiZmV0Y2giLCJTWU5DIiwibG9hZCIsImZpbGVuYW1lIiwiY2FsbGJhY2siLCJ1bmRlZmluZWQiLCJzZWxmIiwiYXNQcm9taXNlIiwic3luYyIsImZpbmlzaCIsImVyciIsImNiIiwiZ2V0QnVuZGxlZEZpbGVOYW1lIiwiaWR4IiwibGFzdEluZGV4T2YiLCJhbHRuYW1lIiwic3Vic3RyaW5nIiwicHJvY2VzcyIsInNvdXJjZSIsImlzU3RyaW5nIiwiY2hhckF0IiwiSlNPTiIsInBhcnNlZCIsInJlc29sdmVkIiwiaSIsImltcG9ydHMiLCJsZW5ndGgiLCJ3ZWFrSW1wb3J0cyIsInF1ZXVlZCIsIndlYWsiLCJpbmRleE9mIiwicHVzaCIsInNldFRpbWVvdXQiLCJmcyIsInJlYWRGaWxlU3luYyIsInRvU3RyaW5nIiwibG9hZFN5bmMiLCJpc05vZGUiLCJFcnJvciIsInJlc29sdmVBbGwiLCJtYXAiLCJmaWVsZCIsImV4dGVuZCIsInBhcmVudCIsImZ1bGxOYW1lIiwiam9pbiIsImV4cG9zZVJlIiwidHJ5SGFuZGxlRXh0ZW5zaW9uIiwiZXh0ZW5kZWRUeXBlIiwibG9va3VwIiwic2lzdGVyRmllbGQiLCJpZCIsInR5cGUiLCJydWxlIiwiZ2V0IiwibmFtZSIsImRlY2xhcmluZ0ZpZWxkIiwiZXh0ZW5zaW9uRmllbGQiLCJhZGQiLCJfaGFuZGxlQWRkIiwib2JqZWN0IiwidGVzdCIsInZhbHVlcyIsInNwbGljZSIsImoiLCJuZXN0ZWRBcnJheSIsIl9uZXN0ZWRBcnJheSIsIl9oYW5kbGVSZW1vdmUiLCJyZW1vdmUiLCJpbmRleCIsIl9jb25maWd1cmUiLCJUeXBlXyIsInBhcnNlXyIsImNvbW1vbl8iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/protobufjs/src/root.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/src/roots.js":
/*!***********************************************!*\
  !*** ../node_modules/protobufjs/src/roots.js ***!
  \***********************************************/
/***/ ((module) => {

eval("\nmodule.exports = {}; /**\n * Named roots.\n * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).\n * Can also be used manually to make roots available across modules.\n * @name roots\n * @type {Object.<string,Root>}\n * @example\n * // pbjs -r myroot -o compiled.js ...\n *\n * // in another module:\n * require(\"./compiled.js\");\n *\n * // in any subsequent module:\n * var root = protobuf.roots[\"myroot\"];\n */ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3Jvb3RzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLE9BQU9DLE9BQU8sR0FBRyxDQUFDLEdBRWxCOzs7Ozs7Ozs7Ozs7OztDQWNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9yb290cy5qcz82NTc3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLyoqXG4gKiBOYW1lZCByb290cy5cbiAqIFRoaXMgaXMgd2hlcmUgcGJqcyBzdG9yZXMgZ2VuZXJhdGVkIHN0cnVjdHVyZXMgKHRoZSBvcHRpb24gYC1yLCAtLXJvb3RgIHNwZWNpZmllcyBhIG5hbWUpLlxuICogQ2FuIGFsc28gYmUgdXNlZCBtYW51YWxseSB0byBtYWtlIHJvb3RzIGF2YWlsYWJsZSBhY3Jvc3MgbW9kdWxlcy5cbiAqIEBuYW1lIHJvb3RzXG4gKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsUm9vdD59XG4gKiBAZXhhbXBsZVxuICogLy8gcGJqcyAtciBteXJvb3QgLW8gY29tcGlsZWQuanMgLi4uXG4gKlxuICogLy8gaW4gYW5vdGhlciBtb2R1bGU6XG4gKiByZXF1aXJlKFwiLi9jb21waWxlZC5qc1wiKTtcbiAqXG4gKiAvLyBpbiBhbnkgc3Vic2VxdWVudCBtb2R1bGU6XG4gKiB2YXIgcm9vdCA9IHByb3RvYnVmLnJvb3RzW1wibXlyb290XCJdO1xuICovXG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/protobufjs/src/roots.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/src/rpc.js":
/*!*********************************************!*\
  !*** ../node_modules/protobufjs/src/rpc.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Streaming RPC helpers.\n * @namespace\n */ var rpc = exports;\n/**\n * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.\n * @typedef RPCImpl\n * @type {function}\n * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called\n * @param {Uint8Array} requestData Request data\n * @param {RPCImplCallback} callback Callback function\n * @returns {undefined}\n * @example\n * function rpcImpl(method, requestData, callback) {\n *     if (protobuf.util.lcFirst(method.name) !== \"myMethod\") // compatible with static code\n *         throw Error(\"no such method\");\n *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {\n *         callback(err, responseData);\n *     });\n * }\n */ /**\n * Node-style callback as used by {@link RPCImpl}.\n * @typedef RPCImplCallback\n * @type {function}\n * @param {Error|null} error Error, if any, otherwise `null`\n * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error\n * @returns {undefined}\n */ rpc.Service = __webpack_require__(/*! ./rpc/service */ \"(ssr)/../node_modules/protobufjs/src/rpc/service.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3JwYy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViOzs7Q0FHQyxHQUNELElBQUlBLE1BQU1DO0FBRVY7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FnQkMsR0FFRDs7Ozs7OztDQU9DLEdBRURELElBQUlFLE9BQU8sR0FBR0MsbUJBQU9BLENBQUMsMEVBQWUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3JwYy5qcz8zYmYwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIFN0cmVhbWluZyBSUEMgaGVscGVycy5cbiAqIEBuYW1lc3BhY2VcbiAqL1xudmFyIHJwYyA9IGV4cG9ydHM7XG5cbi8qKlxuICogUlBDIGltcGxlbWVudGF0aW9uIHBhc3NlZCB0byB7QGxpbmsgU2VydmljZSNjcmVhdGV9IHBlcmZvcm1pbmcgYSBzZXJ2aWNlIHJlcXVlc3Qgb24gbmV0d29yayBsZXZlbCwgaS5lLiBieSB1dGlsaXppbmcgaHR0cCByZXF1ZXN0cyBvciB3ZWJzb2NrZXRzLlxuICogQHR5cGVkZWYgUlBDSW1wbFxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtNZXRob2R8cnBjLlNlcnZpY2VNZXRob2Q8TWVzc2FnZTx7fT4sTWVzc2FnZTx7fT4+fSBtZXRob2QgUmVmbGVjdGVkIG9yIHN0YXRpYyBtZXRob2QgYmVpbmcgY2FsbGVkXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHJlcXVlc3REYXRhIFJlcXVlc3QgZGF0YVxuICogQHBhcmFtIHtSUENJbXBsQ2FsbGJhY2t9IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICogQGV4YW1wbGVcbiAqIGZ1bmN0aW9uIHJwY0ltcGwobWV0aG9kLCByZXF1ZXN0RGF0YSwgY2FsbGJhY2spIHtcbiAqICAgICBpZiAocHJvdG9idWYudXRpbC5sY0ZpcnN0KG1ldGhvZC5uYW1lKSAhPT0gXCJteU1ldGhvZFwiKSAvLyBjb21wYXRpYmxlIHdpdGggc3RhdGljIGNvZGVcbiAqICAgICAgICAgdGhyb3cgRXJyb3IoXCJubyBzdWNoIG1ldGhvZFwiKTtcbiAqICAgICBhc3luY2hyb25vdXNseU9idGFpbkFSZXNwb25zZShyZXF1ZXN0RGF0YSwgZnVuY3Rpb24oZXJyLCByZXNwb25zZURhdGEpIHtcbiAqICAgICAgICAgY2FsbGJhY2soZXJyLCByZXNwb25zZURhdGEpO1xuICogICAgIH0pO1xuICogfVxuICovXG5cbi8qKlxuICogTm9kZS1zdHlsZSBjYWxsYmFjayBhcyB1c2VkIGJ5IHtAbGluayBSUENJbXBsfS5cbiAqIEB0eXBlZGVmIFJQQ0ltcGxDYWxsYmFja1xuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtFcnJvcnxudWxsfSBlcnJvciBFcnJvciwgaWYgYW55LCBvdGhlcndpc2UgYG51bGxgXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl8bnVsbH0gW3Jlc3BvbnNlXSBSZXNwb25zZSBkYXRhIG9yIGBudWxsYCB0byBzaWduYWwgZW5kIG9mIHN0cmVhbSwgaWYgdGhlcmUgaGFzbid0IGJlZW4gYW4gZXJyb3JcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cblxucnBjLlNlcnZpY2UgPSByZXF1aXJlKFwiLi9ycGMvc2VydmljZVwiKTtcbiJdLCJuYW1lcyI6WyJycGMiLCJleHBvcnRzIiwiU2VydmljZSIsInJlcXVpcmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/protobufjs/src/rpc.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/src/rpc/service.js":
/*!*****************************************************!*\
  !*** ../node_modules/protobufjs/src/rpc/service.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = Service;\nvar util = __webpack_require__(/*! ../util/minimal */ \"(ssr)/../node_modules/protobufjs/src/util/minimal.js\");\n// Extends EventEmitter\n(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;\n/**\n * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.\n *\n * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.\n * @typedef rpc.ServiceMethodCallback\n * @template TRes extends Message<TRes>\n * @type {function}\n * @param {Error|null} error Error, if any\n * @param {TRes} [response] Response message\n * @returns {undefined}\n */ /**\n * A service method part of a {@link rpc.Service} as created by {@link Service.create}.\n * @typedef rpc.ServiceMethod\n * @template TReq extends Message<TReq>\n * @template TRes extends Message<TRes>\n * @type {function}\n * @param {TReq|Properties<TReq>} request Request message or plain object\n * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message\n * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`\n */ /**\n * Constructs a new RPC service instance.\n * @classdesc An RPC service as returned by {@link Service#create}.\n * @exports rpc.Service\n * @extends util.EventEmitter\n * @constructor\n * @param {RPCImpl} rpcImpl RPC implementation\n * @param {boolean} [requestDelimited=false] Whether requests are length-delimited\n * @param {boolean} [responseDelimited=false] Whether responses are length-delimited\n */ function Service(rpcImpl, requestDelimited, responseDelimited) {\n    if (typeof rpcImpl !== \"function\") throw TypeError(\"rpcImpl must be a function\");\n    util.EventEmitter.call(this);\n    /**\n     * RPC implementation. Becomes `null` once the service is ended.\n     * @type {RPCImpl|null}\n     */ this.rpcImpl = rpcImpl;\n    /**\n     * Whether requests are length-delimited.\n     * @type {boolean}\n     */ this.requestDelimited = Boolean(requestDelimited);\n    /**\n     * Whether responses are length-delimited.\n     * @type {boolean}\n     */ this.responseDelimited = Boolean(responseDelimited);\n}\n/**\n * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.\n * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method\n * @param {Constructor<TReq>} requestCtor Request constructor\n * @param {Constructor<TRes>} responseCtor Response constructor\n * @param {TReq|Properties<TReq>} request Request message or plain object\n * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback\n * @returns {undefined}\n * @template TReq extends Message<TReq>\n * @template TRes extends Message<TRes>\n */ Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {\n    if (!request) throw TypeError(\"request must be specified\");\n    var self = this;\n    if (!callback) return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);\n    if (!self.rpcImpl) {\n        setTimeout(function() {\n            callback(Error(\"already ended\"));\n        }, 0);\n        return undefined;\n    }\n    try {\n        return self.rpcImpl(method, requestCtor[self.requestDelimited ? \"encodeDelimited\" : \"encode\"](request).finish(), function rpcCallback(err, response) {\n            if (err) {\n                self.emit(\"error\", err, method);\n                return callback(err);\n            }\n            if (response === null) {\n                self.end(/* endedByRPC */ true);\n                return undefined;\n            }\n            if (!(response instanceof responseCtor)) {\n                try {\n                    response = responseCtor[self.responseDelimited ? \"decodeDelimited\" : \"decode\"](response);\n                } catch (err) {\n                    self.emit(\"error\", err, method);\n                    return callback(err);\n                }\n            }\n            self.emit(\"data\", response, method);\n            return callback(null, response);\n        });\n    } catch (err) {\n        self.emit(\"error\", err, method);\n        setTimeout(function() {\n            callback(err);\n        }, 0);\n        return undefined;\n    }\n};\n/**\n * Ends this service and emits the `end` event.\n * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.\n * @returns {rpc.Service} `this`\n */ Service.prototype.end = function end(endedByRPC) {\n    if (this.rpcImpl) {\n        if (!endedByRPC) this.rpcImpl(null, null, null);\n        this.rpcImpl = null;\n        this.emit(\"end\").off();\n    }\n    return this;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3JwYy9zZXJ2aWNlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLE9BQU9DLE9BQU8sR0FBR0M7QUFFakIsSUFBSUMsT0FBT0MsbUJBQU9BLENBQUMsNkVBQWlCO0FBRXBDLHVCQUF1QjtBQUN0QkYsQ0FBQUEsUUFBUUcsU0FBUyxHQUFHQyxPQUFPQyxNQUFNLENBQUNKLEtBQUtLLFlBQVksQ0FBQ0gsU0FBUyxHQUFHSSxXQUFXLEdBQUdQO0FBRS9FOzs7Ozs7Ozs7O0NBVUMsR0FFRDs7Ozs7Ozs7O0NBU0MsR0FFRDs7Ozs7Ozs7O0NBU0MsR0FDRCxTQUFTQSxRQUFRUSxPQUFPLEVBQUVDLGdCQUFnQixFQUFFQyxpQkFBaUI7SUFFekQsSUFBSSxPQUFPRixZQUFZLFlBQ25CLE1BQU1HLFVBQVU7SUFFcEJWLEtBQUtLLFlBQVksQ0FBQ00sSUFBSSxDQUFDLElBQUk7SUFFM0I7OztLQUdDLEdBQ0QsSUFBSSxDQUFDSixPQUFPLEdBQUdBO0lBRWY7OztLQUdDLEdBQ0QsSUFBSSxDQUFDQyxnQkFBZ0IsR0FBR0ksUUFBUUo7SUFFaEM7OztLQUdDLEdBQ0QsSUFBSSxDQUFDQyxpQkFBaUIsR0FBR0csUUFBUUg7QUFDckM7QUFFQTs7Ozs7Ozs7OztDQVVDLEdBQ0RWLFFBQVFHLFNBQVMsQ0FBQ1csT0FBTyxHQUFHLFNBQVNBLFFBQVFDLE1BQU0sRUFBRUMsV0FBVyxFQUFFQyxZQUFZLEVBQUVDLE9BQU8sRUFBRUMsUUFBUTtJQUU3RixJQUFJLENBQUNELFNBQ0QsTUFBTVAsVUFBVTtJQUVwQixJQUFJUyxPQUFPLElBQUk7SUFDZixJQUFJLENBQUNELFVBQ0QsT0FBT2xCLEtBQUtvQixTQUFTLENBQUNQLFNBQVNNLE1BQU1MLFFBQVFDLGFBQWFDLGNBQWNDO0lBRTVFLElBQUksQ0FBQ0UsS0FBS1osT0FBTyxFQUFFO1FBQ2ZjLFdBQVc7WUFBYUgsU0FBU0ksTUFBTTtRQUFtQixHQUFHO1FBQzdELE9BQU9DO0lBQ1g7SUFFQSxJQUFJO1FBQ0EsT0FBT0osS0FBS1osT0FBTyxDQUNmTyxRQUNBQyxXQUFXLENBQUNJLEtBQUtYLGdCQUFnQixHQUFHLG9CQUFvQixTQUFTLENBQUNTLFNBQVNPLE1BQU0sSUFDakYsU0FBU0MsWUFBWUMsR0FBRyxFQUFFQyxRQUFRO1lBRTlCLElBQUlELEtBQUs7Z0JBQ0xQLEtBQUtTLElBQUksQ0FBQyxTQUFTRixLQUFLWjtnQkFDeEIsT0FBT0ksU0FBU1E7WUFDcEI7WUFFQSxJQUFJQyxhQUFhLE1BQU07Z0JBQ25CUixLQUFLVSxHQUFHLENBQUMsY0FBYyxHQUFHO2dCQUMxQixPQUFPTjtZQUNYO1lBRUEsSUFBSSxDQUFFSSxDQUFBQSxvQkFBb0JYLFlBQVcsR0FBSTtnQkFDckMsSUFBSTtvQkFDQVcsV0FBV1gsWUFBWSxDQUFDRyxLQUFLVixpQkFBaUIsR0FBRyxvQkFBb0IsU0FBUyxDQUFDa0I7Z0JBQ25GLEVBQUUsT0FBT0QsS0FBSztvQkFDVlAsS0FBS1MsSUFBSSxDQUFDLFNBQVNGLEtBQUtaO29CQUN4QixPQUFPSSxTQUFTUTtnQkFDcEI7WUFDSjtZQUVBUCxLQUFLUyxJQUFJLENBQUMsUUFBUUQsVUFBVWI7WUFDNUIsT0FBT0ksU0FBUyxNQUFNUztRQUMxQjtJQUVSLEVBQUUsT0FBT0QsS0FBSztRQUNWUCxLQUFLUyxJQUFJLENBQUMsU0FBU0YsS0FBS1o7UUFDeEJPLFdBQVc7WUFBYUgsU0FBU1E7UUFBTSxHQUFHO1FBQzFDLE9BQU9IO0lBQ1g7QUFDSjtBQUVBOzs7O0NBSUMsR0FDRHhCLFFBQVFHLFNBQVMsQ0FBQzJCLEdBQUcsR0FBRyxTQUFTQSxJQUFJQyxVQUFVO0lBQzNDLElBQUksSUFBSSxDQUFDdkIsT0FBTyxFQUFFO1FBQ2QsSUFBSSxDQUFDdUIsWUFDRCxJQUFJLENBQUN2QixPQUFPLENBQUMsTUFBTSxNQUFNO1FBQzdCLElBQUksQ0FBQ0EsT0FBTyxHQUFHO1FBQ2YsSUFBSSxDQUFDcUIsSUFBSSxDQUFDLE9BQU9HLEdBQUc7SUFDeEI7SUFDQSxPQUFPLElBQUk7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcnBjL3NlcnZpY2UuanM/ZmIwMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gU2VydmljZTtcblxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbC9taW5pbWFsXCIpO1xuXG4vLyBFeHRlbmRzIEV2ZW50RW1pdHRlclxuKFNlcnZpY2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh1dGlsLkV2ZW50RW1pdHRlci5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IFNlcnZpY2U7XG5cbi8qKlxuICogQSBzZXJ2aWNlIG1ldGhvZCBjYWxsYmFjayBhcyB1c2VkIGJ5IHtAbGluayBycGMuU2VydmljZU1ldGhvZHxTZXJ2aWNlTWV0aG9kfS5cbiAqXG4gKiBEaWZmZXJzIGZyb20ge0BsaW5rIFJQQ0ltcGxDYWxsYmFja30gaW4gdGhhdCBpdCBpcyBhbiBhY3R1YWwgY2FsbGJhY2sgb2YgYSBzZXJ2aWNlIG1ldGhvZCB3aGljaCBtYXkgbm90IHJldHVybiBgcmVzcG9uc2UgPSBudWxsYC5cbiAqIEB0eXBlZGVmIHJwYy5TZXJ2aWNlTWV0aG9kQ2FsbGJhY2tcbiAqIEB0ZW1wbGF0ZSBUUmVzIGV4dGVuZHMgTWVzc2FnZTxUUmVzPlxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtFcnJvcnxudWxsfSBlcnJvciBFcnJvciwgaWYgYW55XG4gKiBAcGFyYW0ge1RSZXN9IFtyZXNwb25zZV0gUmVzcG9uc2UgbWVzc2FnZVxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuXG4vKipcbiAqIEEgc2VydmljZSBtZXRob2QgcGFydCBvZiBhIHtAbGluayBycGMuU2VydmljZX0gYXMgY3JlYXRlZCBieSB7QGxpbmsgU2VydmljZS5jcmVhdGV9LlxuICogQHR5cGVkZWYgcnBjLlNlcnZpY2VNZXRob2RcbiAqIEB0ZW1wbGF0ZSBUUmVxIGV4dGVuZHMgTWVzc2FnZTxUUmVxPlxuICogQHRlbXBsYXRlIFRSZXMgZXh0ZW5kcyBNZXNzYWdlPFRSZXM+XG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcGFyYW0ge1RSZXF8UHJvcGVydGllczxUUmVxPn0gcmVxdWVzdCBSZXF1ZXN0IG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0XG4gKiBAcGFyYW0ge3JwYy5TZXJ2aWNlTWV0aG9kQ2FsbGJhY2s8VFJlcz59IFtjYWxsYmFja10gTm9kZS1zdHlsZSBjYWxsYmFjayBjYWxsZWQgd2l0aCB0aGUgZXJyb3IsIGlmIGFueSwgYW5kIHRoZSByZXNwb25zZSBtZXNzYWdlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxNZXNzYWdlPFRSZXM+Pn0gUHJvbWlzZSBpZiBgY2FsbGJhY2tgIGhhcyBiZWVuIG9taXR0ZWQsIG90aGVyd2lzZSBgdW5kZWZpbmVkYFxuICovXG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBSUEMgc2VydmljZSBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgQW4gUlBDIHNlcnZpY2UgYXMgcmV0dXJuZWQgYnkge0BsaW5rIFNlcnZpY2UjY3JlYXRlfS5cbiAqIEBleHBvcnRzIHJwYy5TZXJ2aWNlXG4gKiBAZXh0ZW5kcyB1dGlsLkV2ZW50RW1pdHRlclxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1JQQ0ltcGx9IHJwY0ltcGwgUlBDIGltcGxlbWVudGF0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXF1ZXN0RGVsaW1pdGVkPWZhbHNlXSBXaGV0aGVyIHJlcXVlc3RzIGFyZSBsZW5ndGgtZGVsaW1pdGVkXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXNwb25zZURlbGltaXRlZD1mYWxzZV0gV2hldGhlciByZXNwb25zZXMgYXJlIGxlbmd0aC1kZWxpbWl0ZWRcbiAqL1xuZnVuY3Rpb24gU2VydmljZShycGNJbXBsLCByZXF1ZXN0RGVsaW1pdGVkLCByZXNwb25zZURlbGltaXRlZCkge1xuXG4gICAgaWYgKHR5cGVvZiBycGNJbXBsICE9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcInJwY0ltcGwgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuXG4gICAgdXRpbC5FdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIFJQQyBpbXBsZW1lbnRhdGlvbi4gQmVjb21lcyBgbnVsbGAgb25jZSB0aGUgc2VydmljZSBpcyBlbmRlZC5cbiAgICAgKiBAdHlwZSB7UlBDSW1wbHxudWxsfVxuICAgICAqL1xuICAgIHRoaXMucnBjSW1wbCA9IHJwY0ltcGw7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHJlcXVlc3RzIGFyZSBsZW5ndGgtZGVsaW1pdGVkLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMucmVxdWVzdERlbGltaXRlZCA9IEJvb2xlYW4ocmVxdWVzdERlbGltaXRlZCk7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHJlc3BvbnNlcyBhcmUgbGVuZ3RoLWRlbGltaXRlZC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnJlc3BvbnNlRGVsaW1pdGVkID0gQm9vbGVhbihyZXNwb25zZURlbGltaXRlZCk7XG59XG5cbi8qKlxuICogQ2FsbHMgYSBzZXJ2aWNlIG1ldGhvZCB0aHJvdWdoIHtAbGluayBycGMuU2VydmljZSNycGNJbXBsfHJwY0ltcGx9LlxuICogQHBhcmFtIHtNZXRob2R8cnBjLlNlcnZpY2VNZXRob2Q8VFJlcSxUUmVzPn0gbWV0aG9kIFJlZmxlY3RlZCBvciBzdGF0aWMgbWV0aG9kXG4gKiBAcGFyYW0ge0NvbnN0cnVjdG9yPFRSZXE+fSByZXF1ZXN0Q3RvciBSZXF1ZXN0IGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0NvbnN0cnVjdG9yPFRSZXM+fSByZXNwb25zZUN0b3IgUmVzcG9uc2UgY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7VFJlcXxQcm9wZXJ0aWVzPFRSZXE+fSByZXF1ZXN0IFJlcXVlc3QgbWVzc2FnZSBvciBwbGFpbiBvYmplY3RcbiAqIEBwYXJhbSB7cnBjLlNlcnZpY2VNZXRob2RDYWxsYmFjazxUUmVzPn0gY2FsbGJhY2sgU2VydmljZSBjYWxsYmFja1xuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqIEB0ZW1wbGF0ZSBUUmVxIGV4dGVuZHMgTWVzc2FnZTxUUmVxPlxuICogQHRlbXBsYXRlIFRSZXMgZXh0ZW5kcyBNZXNzYWdlPFRSZXM+XG4gKi9cblNlcnZpY2UucHJvdG90eXBlLnJwY0NhbGwgPSBmdW5jdGlvbiBycGNDYWxsKG1ldGhvZCwgcmVxdWVzdEN0b3IsIHJlc3BvbnNlQ3RvciwgcmVxdWVzdCwgY2FsbGJhY2spIHtcblxuICAgIGlmICghcmVxdWVzdClcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwicmVxdWVzdCBtdXN0IGJlIHNwZWNpZmllZFwiKTtcblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAoIWNhbGxiYWNrKVxuICAgICAgICByZXR1cm4gdXRpbC5hc1Byb21pc2UocnBjQ2FsbCwgc2VsZiwgbWV0aG9kLCByZXF1ZXN0Q3RvciwgcmVzcG9uc2VDdG9yLCByZXF1ZXN0KTtcblxuICAgIGlmICghc2VsZi5ycGNJbXBsKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGNhbGxiYWNrKEVycm9yKFwiYWxyZWFkeSBlbmRlZFwiKSk7IH0sIDApO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBzZWxmLnJwY0ltcGwoXG4gICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICByZXF1ZXN0Q3RvcltzZWxmLnJlcXVlc3REZWxpbWl0ZWQgPyBcImVuY29kZURlbGltaXRlZFwiIDogXCJlbmNvZGVcIl0ocmVxdWVzdCkuZmluaXNoKCksXG4gICAgICAgICAgICBmdW5jdGlvbiBycGNDYWxsYmFjayhlcnIsIHJlc3BvbnNlKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZW1pdChcImVycm9yXCIsIGVyciwgbWV0aG9kKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZW5kKC8qIGVuZGVkQnlSUEMgKi8gdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCEocmVzcG9uc2UgaW5zdGFuY2VvZiByZXNwb25zZUN0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IHJlc3BvbnNlQ3RvcltzZWxmLnJlc3BvbnNlRGVsaW1pdGVkID8gXCJkZWNvZGVEZWxpbWl0ZWRcIiA6IFwiZGVjb2RlXCJdKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmVtaXQoXCJlcnJvclwiLCBlcnIsIG1ldGhvZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNlbGYuZW1pdChcImRhdGFcIiwgcmVzcG9uc2UsIG1ldGhvZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgc2VsZi5lbWl0KFwiZXJyb3JcIiwgZXJyLCBtZXRob2QpO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBjYWxsYmFjayhlcnIpOyB9LCAwKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59O1xuXG4vKipcbiAqIEVuZHMgdGhpcyBzZXJ2aWNlIGFuZCBlbWl0cyB0aGUgYGVuZGAgZXZlbnQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtlbmRlZEJ5UlBDPWZhbHNlXSBXaGV0aGVyIHRoZSBzZXJ2aWNlIGhhcyBiZWVuIGVuZGVkIGJ5IHRoZSBSUEMgaW1wbGVtZW50YXRpb24uXG4gKiBAcmV0dXJucyB7cnBjLlNlcnZpY2V9IGB0aGlzYFxuICovXG5TZXJ2aWNlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiBlbmQoZW5kZWRCeVJQQykge1xuICAgIGlmICh0aGlzLnJwY0ltcGwpIHtcbiAgICAgICAgaWYgKCFlbmRlZEJ5UlBDKSAvLyBzaWduYWwgZW5kIHRvIHJwY0ltcGxcbiAgICAgICAgICAgIHRoaXMucnBjSW1wbChudWxsLCBudWxsLCBudWxsKTtcbiAgICAgICAgdGhpcy5ycGNJbXBsID0gbnVsbDtcbiAgICAgICAgdGhpcy5lbWl0KFwiZW5kXCIpLm9mZigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsIlNlcnZpY2UiLCJ1dGlsIiwicmVxdWlyZSIsInByb3RvdHlwZSIsIk9iamVjdCIsImNyZWF0ZSIsIkV2ZW50RW1pdHRlciIsImNvbnN0cnVjdG9yIiwicnBjSW1wbCIsInJlcXVlc3REZWxpbWl0ZWQiLCJyZXNwb25zZURlbGltaXRlZCIsIlR5cGVFcnJvciIsImNhbGwiLCJCb29sZWFuIiwicnBjQ2FsbCIsIm1ldGhvZCIsInJlcXVlc3RDdG9yIiwicmVzcG9uc2VDdG9yIiwicmVxdWVzdCIsImNhbGxiYWNrIiwic2VsZiIsImFzUHJvbWlzZSIsInNldFRpbWVvdXQiLCJFcnJvciIsInVuZGVmaW5lZCIsImZpbmlzaCIsInJwY0NhbGxiYWNrIiwiZXJyIiwicmVzcG9uc2UiLCJlbWl0IiwiZW5kIiwiZW5kZWRCeVJQQyIsIm9mZiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/protobufjs/src/rpc/service.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/src/service.js":
/*!*************************************************!*\
  !*** ../node_modules/protobufjs/src/service.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = Service;\n// extends Namespace\nvar Namespace = __webpack_require__(/*! ./namespace */ \"(ssr)/../node_modules/protobufjs/src/namespace.js\");\n((Service.prototype = Object.create(Namespace.prototype)).constructor = Service).className = \"Service\";\nvar Method = __webpack_require__(/*! ./method */ \"(ssr)/../node_modules/protobufjs/src/method.js\"), util = __webpack_require__(/*! ./util */ \"(ssr)/../node_modules/protobufjs/src/util.js\"), rpc = __webpack_require__(/*! ./rpc */ \"(ssr)/../node_modules/protobufjs/src/rpc.js\");\n/**\n * Constructs a new service instance.\n * @classdesc Reflected service.\n * @extends NamespaceBase\n * @constructor\n * @param {string} name Service name\n * @param {Object.<string,*>} [options] Service options\n * @throws {TypeError} If arguments are invalid\n */ function Service(name, options) {\n    Namespace.call(this, name, options);\n    /**\n     * Service methods.\n     * @type {Object.<string,Method>}\n     */ this.methods = {}; // toJSON, marker\n    /**\n     * Cached methods as an array.\n     * @type {Method[]|null}\n     * @private\n     */ this._methodsArray = null;\n}\n/**\n * Service descriptor.\n * @interface IService\n * @extends INamespace\n * @property {Object.<string,IMethod>} methods Method descriptors\n */ /**\n * Constructs a service from a service descriptor.\n * @param {string} name Service name\n * @param {IService} json Service descriptor\n * @returns {Service} Created service\n * @throws {TypeError} If arguments are invalid\n */ Service.fromJSON = function fromJSON(name, json) {\n    var service = new Service(name, json.options);\n    /* istanbul ignore else */ if (json.methods) for(var names = Object.keys(json.methods), i = 0; i < names.length; ++i)service.add(Method.fromJSON(names[i], json.methods[names[i]]));\n    if (json.nested) service.addJSON(json.nested);\n    service.comment = json.comment;\n    return service;\n};\n/**\n * Converts this service to a service descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IService} Service descriptor\n */ Service.prototype.toJSON = function toJSON(toJSONOptions) {\n    var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n    return util.toObject([\n        \"options\",\n        inherited && inherited.options || undefined,\n        \"methods\",\n        Namespace.arrayToJSON(this.methodsArray, toJSONOptions) || /* istanbul ignore next */ {},\n        \"nested\",\n        inherited && inherited.nested || undefined,\n        \"comment\",\n        keepComments ? this.comment : undefined\n    ]);\n};\n/**\n * Methods of this service as an array for iteration.\n * @name Service#methodsArray\n * @type {Method[]}\n * @readonly\n */ Object.defineProperty(Service.prototype, \"methodsArray\", {\n    get: function() {\n        return this._methodsArray || (this._methodsArray = util.toArray(this.methods));\n    }\n});\nfunction clearCache(service) {\n    service._methodsArray = null;\n    return service;\n}\n/**\n * @override\n */ Service.prototype.get = function get(name) {\n    return this.methods[name] || Namespace.prototype.get.call(this, name);\n};\n/**\n * @override\n */ Service.prototype.resolveAll = function resolveAll() {\n    var methods = this.methodsArray;\n    for(var i = 0; i < methods.length; ++i)methods[i].resolve();\n    return Namespace.prototype.resolve.call(this);\n};\n/**\n * @override\n */ Service.prototype.add = function add(object) {\n    /* istanbul ignore if */ if (this.get(object.name)) throw Error(\"duplicate name '\" + object.name + \"' in \" + this);\n    if (object instanceof Method) {\n        this.methods[object.name] = object;\n        object.parent = this;\n        return clearCache(this);\n    }\n    return Namespace.prototype.add.call(this, object);\n};\n/**\n * @override\n */ Service.prototype.remove = function remove(object) {\n    if (object instanceof Method) {\n        /* istanbul ignore if */ if (this.methods[object.name] !== object) throw Error(object + \" is not a member of \" + this);\n        delete this.methods[object.name];\n        object.parent = null;\n        return clearCache(this);\n    }\n    return Namespace.prototype.remove.call(this, object);\n};\n/**\n * Creates a runtime service using the specified rpc implementation.\n * @param {RPCImpl} rpcImpl RPC implementation\n * @param {boolean} [requestDelimited=false] Whether requests are length-delimited\n * @param {boolean} [responseDelimited=false] Whether responses are length-delimited\n * @returns {rpc.Service} RPC service. Useful where requests and/or responses are streamed.\n */ Service.prototype.create = function create(rpcImpl, requestDelimited, responseDelimited) {\n    var rpcService = new rpc.Service(rpcImpl, requestDelimited, responseDelimited);\n    for(var i = 0, method; i < /* initializes */ this.methodsArray.length; ++i){\n        var methodName = util.lcFirst((method = this._methodsArray[i]).resolve().name).replace(/[^$\\w_]/g, \"\");\n        rpcService[methodName] = util.codegen([\n            \"r\",\n            \"c\"\n        ], util.isReserved(methodName) ? methodName + \"_\" : methodName)(\"return this.rpcCall(m,q,s,r,c)\")({\n            m: method,\n            q: method.resolvedRequestType.ctor,\n            s: method.resolvedResponseType.ctor\n        });\n    }\n    return rpcService;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3NlcnZpY2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsT0FBT0MsT0FBTyxHQUFHQztBQUVqQixvQkFBb0I7QUFDcEIsSUFBSUMsWUFBWUMsbUJBQU9BLENBQUMsc0VBQWE7QUFDcEMsRUFBQ0YsUUFBUUcsU0FBUyxHQUFHQyxPQUFPQyxNQUFNLENBQUNKLFVBQVVFLFNBQVMsR0FBR0csV0FBVyxHQUFHTixPQUFNLEVBQUdPLFNBQVMsR0FBRztBQUU3RixJQUFJQyxTQUFTTixtQkFBT0EsQ0FBQyxnRUFBVSxHQUMzQk8sT0FBU1AsbUJBQU9BLENBQUMsNERBQVEsR0FDekJRLE1BQVNSLG1CQUFPQSxDQUFDLDBEQUFPO0FBRTVCOzs7Ozs7OztDQVFDLEdBQ0QsU0FBU0YsUUFBUVcsSUFBSSxFQUFFQyxPQUFPO0lBQzFCWCxVQUFVWSxJQUFJLENBQUMsSUFBSSxFQUFFRixNQUFNQztJQUUzQjs7O0tBR0MsR0FDRCxJQUFJLENBQUNFLE9BQU8sR0FBRyxDQUFDLEdBQUcsaUJBQWlCO0lBRXBDOzs7O0tBSUMsR0FDRCxJQUFJLENBQUNDLGFBQWEsR0FBRztBQUN6QjtBQUVBOzs7OztDQUtDLEdBRUQ7Ozs7OztDQU1DLEdBQ0RmLFFBQVFnQixRQUFRLEdBQUcsU0FBU0EsU0FBU0wsSUFBSSxFQUFFTSxJQUFJO0lBQzNDLElBQUlDLFVBQVUsSUFBSWxCLFFBQVFXLE1BQU1NLEtBQUtMLE9BQU87SUFDNUMsd0JBQXdCLEdBQ3hCLElBQUlLLEtBQUtILE9BQU8sRUFDWixJQUFLLElBQUlLLFFBQVFmLE9BQU9nQixJQUFJLENBQUNILEtBQUtILE9BQU8sR0FBR08sSUFBSSxHQUFHQSxJQUFJRixNQUFNRyxNQUFNLEVBQUUsRUFBRUQsRUFDbkVILFFBQVFLLEdBQUcsQ0FBQ2YsT0FBT1EsUUFBUSxDQUFDRyxLQUFLLENBQUNFLEVBQUUsRUFBRUosS0FBS0gsT0FBTyxDQUFDSyxLQUFLLENBQUNFLEVBQUUs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QytCLE9BQU9FLE1BQU0sR0FBRztRQUNoQixPQUFPTCxXQUFXLElBQUk7SUFDMUI7SUFDQSxPQUFPdEMsVUFBVUUsU0FBUyxDQUFDMEMsTUFBTSxDQUFDaEMsSUFBSSxDQUFDLElBQUksRUFBRTZCO0FBQ2pEO0FBRUE7Ozs7OztDQU1DLEdBQ0QxQyxRQUFRRyxTQUFTLENBQUNFLE1BQU0sR0FBRyxTQUFTQSxPQUFPeUMsT0FBTyxFQUFFQyxnQkFBZ0IsRUFBRUMsaUJBQWlCO0lBQ25GLElBQUlDLGFBQWEsSUFBSXZDLElBQUlWLE9BQU8sQ0FBQzhDLFNBQVNDLGtCQUFrQkM7SUFDNUQsSUFBSyxJQUFJM0IsSUFBSSxHQUFHNkIsUUFBUTdCLElBQUksZUFBZSxHQUFHLElBQUksQ0FBQ2MsWUFBWSxDQUFDYixNQUFNLEVBQUUsRUFBRUQsRUFBRztRQUN6RSxJQUFJOEIsYUFBYTFDLEtBQUsyQyxPQUFPLENBQUMsQ0FBQ0YsU0FBUyxJQUFJLENBQUNuQyxhQUFhLENBQUNNLEVBQUUsRUFBRW9CLE9BQU8sR0FBRzlCLElBQUksRUFBRTBDLE9BQU8sQ0FBQyxZQUFZO1FBQ25HSixVQUFVLENBQUNFLFdBQVcsR0FBRzFDLEtBQUs2QyxPQUFPLENBQUM7WUFBQztZQUFJO1NBQUksRUFBRTdDLEtBQUs4QyxVQUFVLENBQUNKLGNBQWNBLGFBQWEsTUFBTUEsWUFBWSxrQ0FBa0M7WUFDNUlLLEdBQUdOO1lBQ0hPLEdBQUdQLE9BQU9RLG1CQUFtQixDQUFDQyxJQUFJO1lBQ2xDQyxHQUFHVixPQUFPVyxvQkFBb0IsQ0FBQ0YsSUFBSTtRQUN2QztJQUNKO0lBQ0EsT0FBT1Y7QUFDWCIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvc2VydmljZS5qcz9lOWNhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBTZXJ2aWNlO1xuXG4vLyBleHRlbmRzIE5hbWVzcGFjZVxudmFyIE5hbWVzcGFjZSA9IHJlcXVpcmUoXCIuL25hbWVzcGFjZVwiKTtcbigoU2VydmljZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE5hbWVzcGFjZS5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IFNlcnZpY2UpLmNsYXNzTmFtZSA9IFwiU2VydmljZVwiO1xuXG52YXIgTWV0aG9kID0gcmVxdWlyZShcIi4vbWV0aG9kXCIpLFxuICAgIHV0aWwgICA9IHJlcXVpcmUoXCIuL3V0aWxcIiksXG4gICAgcnBjICAgID0gcmVxdWlyZShcIi4vcnBjXCIpO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgc2VydmljZSBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgUmVmbGVjdGVkIHNlcnZpY2UuXG4gKiBAZXh0ZW5kcyBOYW1lc3BhY2VCYXNlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFNlcnZpY2UgbmFtZVxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gW29wdGlvbnNdIFNlcnZpY2Ugb3B0aW9uc1xuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBhcmd1bWVudHMgYXJlIGludmFsaWRcbiAqL1xuZnVuY3Rpb24gU2VydmljZShuYW1lLCBvcHRpb25zKSB7XG4gICAgTmFtZXNwYWNlLmNhbGwodGhpcywgbmFtZSwgb3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBTZXJ2aWNlIG1ldGhvZHMuXG4gICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLE1ldGhvZD59XG4gICAgICovXG4gICAgdGhpcy5tZXRob2RzID0ge307IC8vIHRvSlNPTiwgbWFya2VyXG5cbiAgICAvKipcbiAgICAgKiBDYWNoZWQgbWV0aG9kcyBhcyBhbiBhcnJheS5cbiAgICAgKiBAdHlwZSB7TWV0aG9kW118bnVsbH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX21ldGhvZHNBcnJheSA9IG51bGw7XG59XG5cbi8qKlxuICogU2VydmljZSBkZXNjcmlwdG9yLlxuICogQGludGVyZmFjZSBJU2VydmljZVxuICogQGV4dGVuZHMgSU5hbWVzcGFjZVxuICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZyxJTWV0aG9kPn0gbWV0aG9kcyBNZXRob2QgZGVzY3JpcHRvcnNcbiAqL1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBzZXJ2aWNlIGZyb20gYSBzZXJ2aWNlIGRlc2NyaXB0b3IuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBTZXJ2aWNlIG5hbWVcbiAqIEBwYXJhbSB7SVNlcnZpY2V9IGpzb24gU2VydmljZSBkZXNjcmlwdG9yXG4gKiBAcmV0dXJucyB7U2VydmljZX0gQ3JlYXRlZCBzZXJ2aWNlXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGFyZ3VtZW50cyBhcmUgaW52YWxpZFxuICovXG5TZXJ2aWNlLmZyb21KU09OID0gZnVuY3Rpb24gZnJvbUpTT04obmFtZSwganNvbikge1xuICAgIHZhciBzZXJ2aWNlID0gbmV3IFNlcnZpY2UobmFtZSwganNvbi5vcHRpb25zKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChqc29uLm1ldGhvZHMpXG4gICAgICAgIGZvciAodmFyIG5hbWVzID0gT2JqZWN0LmtleXMoanNvbi5tZXRob2RzKSwgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIHNlcnZpY2UuYWRkKE1ldGhvZC5mcm9tSlNPTihuYW1lc1tpXSwganNvbi5tZXRob2RzW25hbWVzW2ldXSkpO1xuICAgIGlmIChqc29uLm5lc3RlZClcbiAgICAgICAgc2VydmljZS5hZGRKU09OKGpzb24ubmVzdGVkKTtcbiAgICBzZXJ2aWNlLmNvbW1lbnQgPSBqc29uLmNvbW1lbnQ7XG4gICAgcmV0dXJuIHNlcnZpY2U7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgc2VydmljZSB0byBhIHNlcnZpY2UgZGVzY3JpcHRvci5cbiAqIEBwYXJhbSB7SVRvSlNPTk9wdGlvbnN9IFt0b0pTT05PcHRpb25zXSBKU09OIGNvbnZlcnNpb24gb3B0aW9uc1xuICogQHJldHVybnMge0lTZXJ2aWNlfSBTZXJ2aWNlIGRlc2NyaXB0b3JcbiAqL1xuU2VydmljZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKHRvSlNPTk9wdGlvbnMpIHtcbiAgICB2YXIgaW5oZXJpdGVkID0gTmFtZXNwYWNlLnByb3RvdHlwZS50b0pTT04uY2FsbCh0aGlzLCB0b0pTT05PcHRpb25zKTtcbiAgICB2YXIga2VlcENvbW1lbnRzID0gdG9KU09OT3B0aW9ucyA/IEJvb2xlYW4odG9KU09OT3B0aW9ucy5rZWVwQ29tbWVudHMpIDogZmFsc2U7XG4gICAgcmV0dXJuIHV0aWwudG9PYmplY3QoW1xuICAgICAgICBcIm9wdGlvbnNcIiAsIGluaGVyaXRlZCAmJiBpbmhlcml0ZWQub3B0aW9ucyB8fCB1bmRlZmluZWQsXG4gICAgICAgIFwibWV0aG9kc1wiICwgTmFtZXNwYWNlLmFycmF5VG9KU09OKHRoaXMubWV0aG9kc0FycmF5LCB0b0pTT05PcHRpb25zKSB8fCAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB7fSxcbiAgICAgICAgXCJuZXN0ZWRcIiAgLCBpbmhlcml0ZWQgJiYgaW5oZXJpdGVkLm5lc3RlZCB8fCB1bmRlZmluZWQsXG4gICAgICAgIFwiY29tbWVudFwiICwga2VlcENvbW1lbnRzID8gdGhpcy5jb21tZW50IDogdW5kZWZpbmVkXG4gICAgXSk7XG59O1xuXG4vKipcbiAqIE1ldGhvZHMgb2YgdGhpcyBzZXJ2aWNlIGFzIGFuIGFycmF5IGZvciBpdGVyYXRpb24uXG4gKiBAbmFtZSBTZXJ2aWNlI21ldGhvZHNBcnJheVxuICogQHR5cGUge01ldGhvZFtdfVxuICogQHJlYWRvbmx5XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZXJ2aWNlLnByb3RvdHlwZSwgXCJtZXRob2RzQXJyYXlcIiwge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZXRob2RzQXJyYXkgfHwgKHRoaXMuX21ldGhvZHNBcnJheSA9IHV0aWwudG9BcnJheSh0aGlzLm1ldGhvZHMpKTtcbiAgICB9XG59KTtcblxuZnVuY3Rpb24gY2xlYXJDYWNoZShzZXJ2aWNlKSB7XG4gICAgc2VydmljZS5fbWV0aG9kc0FycmF5ID0gbnVsbDtcbiAgICByZXR1cm4gc2VydmljZTtcbn1cblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuU2VydmljZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0KG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5tZXRob2RzW25hbWVdXG4gICAgICAgIHx8IE5hbWVzcGFjZS5wcm90b3R5cGUuZ2V0LmNhbGwodGhpcywgbmFtZSk7XG59O1xuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5TZXJ2aWNlLnByb3RvdHlwZS5yZXNvbHZlQWxsID0gZnVuY3Rpb24gcmVzb2x2ZUFsbCgpIHtcbiAgICB2YXIgbWV0aG9kcyA9IHRoaXMubWV0aG9kc0FycmF5O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWV0aG9kcy5sZW5ndGg7ICsraSlcbiAgICAgICAgbWV0aG9kc1tpXS5yZXNvbHZlKCk7XG4gICAgcmV0dXJuIE5hbWVzcGFjZS5wcm90b3R5cGUucmVzb2x2ZS5jYWxsKHRoaXMpO1xufTtcblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuU2VydmljZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKG9iamVjdCkge1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHRoaXMuZ2V0KG9iamVjdC5uYW1lKSlcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJkdXBsaWNhdGUgbmFtZSAnXCIgKyBvYmplY3QubmFtZSArIFwiJyBpbiBcIiArIHRoaXMpO1xuXG4gICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIE1ldGhvZCkge1xuICAgICAgICB0aGlzLm1ldGhvZHNbb2JqZWN0Lm5hbWVdID0gb2JqZWN0O1xuICAgICAgICBvYmplY3QucGFyZW50ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGNsZWFyQ2FjaGUodGhpcyk7XG4gICAgfVxuICAgIHJldHVybiBOYW1lc3BhY2UucHJvdG90eXBlLmFkZC5jYWxsKHRoaXMsIG9iamVjdCk7XG59O1xuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5TZXJ2aWNlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUob2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIE1ldGhvZCkge1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAodGhpcy5tZXRob2RzW29iamVjdC5uYW1lXSAhPT0gb2JqZWN0KVxuICAgICAgICAgICAgdGhyb3cgRXJyb3Iob2JqZWN0ICsgXCIgaXMgbm90IGEgbWVtYmVyIG9mIFwiICsgdGhpcyk7XG5cbiAgICAgICAgZGVsZXRlIHRoaXMubWV0aG9kc1tvYmplY3QubmFtZV07XG4gICAgICAgIG9iamVjdC5wYXJlbnQgPSBudWxsO1xuICAgICAgICByZXR1cm4gY2xlYXJDYWNoZSh0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIE5hbWVzcGFjZS5wcm90b3R5cGUucmVtb3ZlLmNhbGwodGhpcywgb2JqZWN0KTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIHJ1bnRpbWUgc2VydmljZSB1c2luZyB0aGUgc3BlY2lmaWVkIHJwYyBpbXBsZW1lbnRhdGlvbi5cbiAqIEBwYXJhbSB7UlBDSW1wbH0gcnBjSW1wbCBSUEMgaW1wbGVtZW50YXRpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlcXVlc3REZWxpbWl0ZWQ9ZmFsc2VdIFdoZXRoZXIgcmVxdWVzdHMgYXJlIGxlbmd0aC1kZWxpbWl0ZWRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Jlc3BvbnNlRGVsaW1pdGVkPWZhbHNlXSBXaGV0aGVyIHJlc3BvbnNlcyBhcmUgbGVuZ3RoLWRlbGltaXRlZFxuICogQHJldHVybnMge3JwYy5TZXJ2aWNlfSBSUEMgc2VydmljZS4gVXNlZnVsIHdoZXJlIHJlcXVlc3RzIGFuZC9vciByZXNwb25zZXMgYXJlIHN0cmVhbWVkLlxuICovXG5TZXJ2aWNlLnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocnBjSW1wbCwgcmVxdWVzdERlbGltaXRlZCwgcmVzcG9uc2VEZWxpbWl0ZWQpIHtcbiAgICB2YXIgcnBjU2VydmljZSA9IG5ldyBycGMuU2VydmljZShycGNJbXBsLCByZXF1ZXN0RGVsaW1pdGVkLCByZXNwb25zZURlbGltaXRlZCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIG1ldGhvZDsgaSA8IC8qIGluaXRpYWxpemVzICovIHRoaXMubWV0aG9kc0FycmF5Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBtZXRob2ROYW1lID0gdXRpbC5sY0ZpcnN0KChtZXRob2QgPSB0aGlzLl9tZXRob2RzQXJyYXlbaV0pLnJlc29sdmUoKS5uYW1lKS5yZXBsYWNlKC9bXiRcXHdfXS9nLCBcIlwiKTtcbiAgICAgICAgcnBjU2VydmljZVttZXRob2ROYW1lXSA9IHV0aWwuY29kZWdlbihbXCJyXCIsXCJjXCJdLCB1dGlsLmlzUmVzZXJ2ZWQobWV0aG9kTmFtZSkgPyBtZXRob2ROYW1lICsgXCJfXCIgOiBtZXRob2ROYW1lKShcInJldHVybiB0aGlzLnJwY0NhbGwobSxxLHMscixjKVwiKSh7XG4gICAgICAgICAgICBtOiBtZXRob2QsXG4gICAgICAgICAgICBxOiBtZXRob2QucmVzb2x2ZWRSZXF1ZXN0VHlwZS5jdG9yLFxuICAgICAgICAgICAgczogbWV0aG9kLnJlc29sdmVkUmVzcG9uc2VUeXBlLmN0b3JcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBycGNTZXJ2aWNlO1xufTtcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwiU2VydmljZSIsIk5hbWVzcGFjZSIsInJlcXVpcmUiLCJwcm90b3R5cGUiLCJPYmplY3QiLCJjcmVhdGUiLCJjb25zdHJ1Y3RvciIsImNsYXNzTmFtZSIsIk1ldGhvZCIsInV0aWwiLCJycGMiLCJuYW1lIiwib3B0aW9ucyIsImNhbGwiLCJtZXRob2RzIiwiX21ldGhvZHNBcnJheSIsImZyb21KU09OIiwianNvbiIsInNlcnZpY2UiLCJuYW1lcyIsImtleXMiLCJpIiwibGVuZ3RoIiwiYWRkIiwibmVzdGVkIiwiYWRkSlNPTiIsImNvbW1lbnQiLCJ0b0pTT04iLCJ0b0pTT05PcHRpb25zIiwiaW5oZXJpdGVkIiwia2VlcENvbW1lbnRzIiwiQm9vbGVhbiIsInRvT2JqZWN0IiwidW5kZWZpbmVkIiwiYXJyYXlUb0pTT04iLCJtZXRob2RzQXJyYXkiLCJkZWZpbmVQcm9wZXJ0eSIsImdldCIsInRvQXJyYXkiLCJjbGVhckNhY2hlIiwicmVzb2x2ZUFsbCIsInJlc29sdmUiLCJvYmplY3QiLCJFcnJvciIsInBhcmVudCIsInJlbW92ZSIsInJwY0ltcGwiLCJyZXF1ZXN0RGVsaW1pdGVkIiwicmVzcG9uc2VEZWxpbWl0ZWQiLCJycGNTZXJ2aWNlIiwibWV0aG9kIiwibWV0aG9kTmFtZSIsImxjRmlyc3QiLCJyZXBsYWNlIiwiY29kZWdlbiIsImlzUmVzZXJ2ZWQiLCJtIiwicSIsInJlc29sdmVkUmVxdWVzdFR5cGUiLCJjdG9yIiwicyIsInJlc29sdmVkUmVzcG9uc2VUeXBlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/protobufjs/src/service.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/src/tokenize.js":
/*!**************************************************!*\
  !*** ../node_modules/protobufjs/src/tokenize.js ***!
  \**************************************************/
/***/ ((module) => {

eval("\nmodule.exports = tokenize;\nvar delimRe = /[\\s{}=;:[\\],'\"()<>]/g, stringDoubleRe = /(?:\"([^\"\\\\]*(?:\\\\.[^\"\\\\]*)*)\")/g, stringSingleRe = /(?:'([^'\\\\]*(?:\\\\.[^'\\\\]*)*)')/g;\nvar setCommentRe = /^ *[*/]+ */, setCommentAltRe = /^\\s*\\*?\\/*/, setCommentSplitRe = /\\n/g, whitespaceRe = /\\s/, unescapeRe = /\\\\(.?)/g;\nvar unescapeMap = {\n    \"0\": \"\\x00\",\n    \"r\": \"\\r\",\n    \"n\": \"\\n\",\n    \"t\": \"\t\"\n};\n/**\n * Unescapes a string.\n * @param {string} str String to unescape\n * @returns {string} Unescaped string\n * @property {Object.<string,string>} map Special characters map\n * @memberof tokenize\n */ function unescape(str) {\n    return str.replace(unescapeRe, function($0, $1) {\n        switch($1){\n            case \"\\\\\":\n            case \"\":\n                return $1;\n            default:\n                return unescapeMap[$1] || \"\";\n        }\n    });\n}\ntokenize.unescape = unescape;\n/**\n * Gets the next token and advances.\n * @typedef TokenizerHandleNext\n * @type {function}\n * @returns {string|null} Next token or `null` on eof\n */ /**\n * Peeks for the next token.\n * @typedef TokenizerHandlePeek\n * @type {function}\n * @returns {string|null} Next token or `null` on eof\n */ /**\n * Pushes a token back to the stack.\n * @typedef TokenizerHandlePush\n * @type {function}\n * @param {string} token Token\n * @returns {undefined}\n */ /**\n * Skips the next token.\n * @typedef TokenizerHandleSkip\n * @type {function}\n * @param {string} expected Expected token\n * @param {boolean} [optional=false] If optional\n * @returns {boolean} Whether the token matched\n * @throws {Error} If the token didn't match and is not optional\n */ /**\n * Gets the comment on the previous line or, alternatively, the line comment on the specified line.\n * @typedef TokenizerHandleCmnt\n * @type {function}\n * @param {number} [line] Line number\n * @returns {string|null} Comment text or `null` if none\n */ /**\n * Handle object returned from {@link tokenize}.\n * @interface ITokenizerHandle\n * @property {TokenizerHandleNext} next Gets the next token and advances (`null` on eof)\n * @property {TokenizerHandlePeek} peek Peeks for the next token (`null` on eof)\n * @property {TokenizerHandlePush} push Pushes a token back to the stack\n * @property {TokenizerHandleSkip} skip Skips a token, returns its presence and advances or, if non-optional and not present, throws\n * @property {TokenizerHandleCmnt} cmnt Gets the comment on the previous line or the line comment on the specified line, if any\n * @property {number} line Current line number\n */ /**\n * Tokenizes the given .proto source and returns an object with useful utility functions.\n * @param {string} source Source contents\n * @param {boolean} alternateCommentMode Whether we should activate alternate comment parsing mode.\n * @returns {ITokenizerHandle} Tokenizer handle\n */ function tokenize(source, alternateCommentMode) {\n    /* eslint-disable callback-return */ source = source.toString();\n    var offset = 0, length = source.length, line = 1, lastCommentLine = 0, comments = {};\n    var stack = [];\n    var stringDelim = null;\n    /* istanbul ignore next */ /**\n     * Creates an error for illegal syntax.\n     * @param {string} subject Subject\n     * @returns {Error} Error created\n     * @inner\n     */ function illegal(subject) {\n        return Error(\"illegal \" + subject + \" (line \" + line + \")\");\n    }\n    /**\n     * Reads a string till its end.\n     * @returns {string} String read\n     * @inner\n     */ function readString() {\n        var re = stringDelim === \"'\" ? stringSingleRe : stringDoubleRe;\n        re.lastIndex = offset - 1;\n        var match = re.exec(source);\n        if (!match) throw illegal(\"string\");\n        offset = re.lastIndex;\n        push(stringDelim);\n        stringDelim = null;\n        return unescape(match[1]);\n    }\n    /**\n     * Gets the character at `pos` within the source.\n     * @param {number} pos Position\n     * @returns {string} Character\n     * @inner\n     */ function charAt(pos) {\n        return source.charAt(pos);\n    }\n    /**\n     * Sets the current comment text.\n     * @param {number} start Start offset\n     * @param {number} end End offset\n     * @param {boolean} isLeading set if a leading comment\n     * @returns {undefined}\n     * @inner\n     */ function setComment(start, end, isLeading) {\n        var comment = {\n            type: source.charAt(start++),\n            lineEmpty: false,\n            leading: isLeading\n        };\n        var lookback;\n        if (alternateCommentMode) {\n            lookback = 2; // alternate comment parsing: \"//\" or \"/*\"\n        } else {\n            lookback = 3; // \"///\" or \"/**\"\n        }\n        var commentOffset = start - lookback, c;\n        do {\n            if (--commentOffset < 0 || (c = source.charAt(commentOffset)) === \"\\n\") {\n                comment.lineEmpty = true;\n                break;\n            }\n        }while (c === \" \" || c === \"\t\");\n        var lines = source.substring(start, end).split(setCommentSplitRe);\n        for(var i = 0; i < lines.length; ++i)lines[i] = lines[i].replace(alternateCommentMode ? setCommentAltRe : setCommentRe, \"\").trim();\n        comment.text = lines.join(\"\\n\").trim();\n        comments[line] = comment;\n        lastCommentLine = line;\n    }\n    function isDoubleSlashCommentLine(startOffset) {\n        var endOffset = findEndOfLine(startOffset);\n        // see if remaining line matches comment pattern\n        var lineText = source.substring(startOffset, endOffset);\n        var isComment = /^\\s*\\/\\//.test(lineText);\n        return isComment;\n    }\n    function findEndOfLine(cursor) {\n        // find end of cursor's line\n        var endOffset = cursor;\n        while(endOffset < length && charAt(endOffset) !== \"\\n\"){\n            endOffset++;\n        }\n        return endOffset;\n    }\n    /**\n     * Obtains the next token.\n     * @returns {string|null} Next token or `null` on eof\n     * @inner\n     */ function next() {\n        if (stack.length > 0) return stack.shift();\n        if (stringDelim) return readString();\n        var repeat, prev, curr, start, isDoc, isLeadingComment = offset === 0;\n        do {\n            if (offset === length) return null;\n            repeat = false;\n            while(whitespaceRe.test(curr = charAt(offset))){\n                if (curr === \"\\n\") {\n                    isLeadingComment = true;\n                    ++line;\n                }\n                if (++offset === length) return null;\n            }\n            if (charAt(offset) === \"/\") {\n                if (++offset === length) {\n                    throw illegal(\"comment\");\n                }\n                if (charAt(offset) === \"/\") {\n                    if (!alternateCommentMode) {\n                        // check for triple-slash comment\n                        isDoc = charAt(start = offset + 1) === \"/\";\n                        while(charAt(++offset) !== \"\\n\"){\n                            if (offset === length) {\n                                return null;\n                            }\n                        }\n                        ++offset;\n                        if (isDoc) {\n                            setComment(start, offset - 1, isLeadingComment);\n                            // Trailing comment cannot not be multi-line,\n                            // so leading comment state should be reset to handle potential next comments\n                            isLeadingComment = true;\n                        }\n                        ++line;\n                        repeat = true;\n                    } else {\n                        // check for double-slash comments, consolidating consecutive lines\n                        start = offset;\n                        isDoc = false;\n                        if (isDoubleSlashCommentLine(offset - 1)) {\n                            isDoc = true;\n                            do {\n                                offset = findEndOfLine(offset);\n                                if (offset === length) {\n                                    break;\n                                }\n                                offset++;\n                                if (!isLeadingComment) {\n                                    break;\n                                }\n                            }while (isDoubleSlashCommentLine(offset));\n                        } else {\n                            offset = Math.min(length, findEndOfLine(offset) + 1);\n                        }\n                        if (isDoc) {\n                            setComment(start, offset, isLeadingComment);\n                            isLeadingComment = true;\n                        }\n                        line++;\n                        repeat = true;\n                    }\n                } else if ((curr = charAt(offset)) === \"*\") {\n                    // check for /** (regular comment mode) or /* (alternate comment mode)\n                    start = offset + 1;\n                    isDoc = alternateCommentMode || charAt(start) === \"*\";\n                    do {\n                        if (curr === \"\\n\") {\n                            ++line;\n                        }\n                        if (++offset === length) {\n                            throw illegal(\"comment\");\n                        }\n                        prev = curr;\n                        curr = charAt(offset);\n                    }while (prev !== \"*\" || curr !== \"/\");\n                    ++offset;\n                    if (isDoc) {\n                        setComment(start, offset - 2, isLeadingComment);\n                        isLeadingComment = true;\n                    }\n                    repeat = true;\n                } else {\n                    return \"/\";\n                }\n            }\n        }while (repeat);\n        // offset !== length if we got here\n        var end = offset;\n        delimRe.lastIndex = 0;\n        var delim = delimRe.test(charAt(end++));\n        if (!delim) while(end < length && !delimRe.test(charAt(end)))++end;\n        var token = source.substring(offset, offset = end);\n        if (token === '\"' || token === \"'\") stringDelim = token;\n        return token;\n    }\n    /**\n     * Pushes a token back to the stack.\n     * @param {string} token Token\n     * @returns {undefined}\n     * @inner\n     */ function push(token) {\n        stack.push(token);\n    }\n    /**\n     * Peeks for the next token.\n     * @returns {string|null} Token or `null` on eof\n     * @inner\n     */ function peek() {\n        if (!stack.length) {\n            var token = next();\n            if (token === null) return null;\n            push(token);\n        }\n        return stack[0];\n    }\n    /**\n     * Skips a token.\n     * @param {string} expected Expected token\n     * @param {boolean} [optional=false] Whether the token is optional\n     * @returns {boolean} `true` when skipped, `false` if not\n     * @throws {Error} When a required token is not present\n     * @inner\n     */ function skip(expected, optional) {\n        var actual = peek(), equals = actual === expected;\n        if (equals) {\n            next();\n            return true;\n        }\n        if (!optional) throw illegal(\"token '\" + actual + \"', '\" + expected + \"' expected\");\n        return false;\n    }\n    /**\n     * Gets a comment.\n     * @param {number} [trailingLine] Line number if looking for a trailing comment\n     * @returns {string|null} Comment text\n     * @inner\n     */ function cmnt(trailingLine) {\n        var ret = null;\n        var comment;\n        if (trailingLine === undefined) {\n            comment = comments[line - 1];\n            delete comments[line - 1];\n            if (comment && (alternateCommentMode || comment.type === \"*\" || comment.lineEmpty)) {\n                ret = comment.leading ? comment.text : null;\n            }\n        } else {\n            /* istanbul ignore else */ if (lastCommentLine < trailingLine) {\n                peek();\n            }\n            comment = comments[trailingLine];\n            delete comments[trailingLine];\n            if (comment && !comment.lineEmpty && (alternateCommentMode || comment.type === \"/\")) {\n                ret = comment.leading ? null : comment.text;\n            }\n        }\n        return ret;\n    }\n    return Object.defineProperty({\n        next: next,\n        peek: peek,\n        push: push,\n        skip: skip,\n        cmnt: cmnt\n    }, \"line\", {\n        get: function() {\n            return line;\n        }\n    });\n/* eslint-enable callback-return */ }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3Rva2VuaXplLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLE9BQU9DLE9BQU8sR0FBR0M7QUFFakIsSUFBSUMsVUFBaUIsd0JBQ2pCQyxpQkFBaUIsbUNBQ2pCQyxpQkFBaUI7QUFFckIsSUFBSUMsZUFBZSxjQUNmQyxrQkFBa0IsY0FDbEJDLG9CQUFvQixPQUNwQkMsZUFBZSxNQUNmQyxhQUFhO0FBRWpCLElBQUlDLGNBQWM7SUFDZCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0FBQ1Q7QUFFQTs7Ozs7O0NBTUMsR0FDRCxTQUFTQyxTQUFTQyxHQUFHO0lBQ2pCLE9BQU9BLElBQUlDLE9BQU8sQ0FBQ0osWUFBWSxTQUFTSyxFQUFFLEVBQUVDLEVBQUU7UUFDMUMsT0FBUUE7WUFDSixLQUFLO1lBQ0wsS0FBSztnQkFDRCxPQUFPQTtZQUNYO2dCQUNJLE9BQU9MLFdBQVcsQ0FBQ0ssR0FBRyxJQUFJO1FBQ2xDO0lBQ0o7QUFDSjtBQUVBZCxTQUFTVSxRQUFRLEdBQUdBO0FBRXBCOzs7OztDQUtDLEdBRUQ7Ozs7O0NBS0MsR0FFRDs7Ozs7O0NBTUMsR0FFRDs7Ozs7Ozs7Q0FRQyxHQUVEOzs7Ozs7Q0FNQyxHQUVEOzs7Ozs7Ozs7Q0FTQyxHQUVEOzs7OztDQUtDLEdBQ0QsU0FBU1YsU0FBU2UsTUFBTSxFQUFFQyxvQkFBb0I7SUFDMUMsa0NBQWtDLEdBQ2xDRCxTQUFTQSxPQUFPRSxRQUFRO0lBRXhCLElBQUlDLFNBQVMsR0FDVEMsU0FBU0osT0FBT0ksTUFBTSxFQUN0QkMsT0FBTyxHQUNQQyxrQkFBa0IsR0FDbEJDLFdBQVcsQ0FBQztJQUVoQixJQUFJQyxRQUFRLEVBQUU7SUFFZCxJQUFJQyxjQUFjO0lBRWxCLHdCQUF3QixHQUN4Qjs7Ozs7S0FLQyxHQUNELFNBQVNDLFFBQVFDLE9BQU87UUFDcEIsT0FBT0MsTUFBTSxhQUFhRCxVQUFVLFlBQVlOLE9BQU87SUFDM0Q7SUFF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QUFJLENBQUNjLFVBQ0QsTUFBTW5ELFFBQVEsWUFBWW9ELFNBQVMsU0FBU0YsV0FBVztRQUMzRCxPQUFPO0lBQ1g7SUFFQTs7Ozs7S0FLQyxHQUNELFNBQVNJLEtBQUtDLFlBQVk7UUFDdEIsSUFBSUMsTUFBTTtRQUNWLElBQUl6QztRQUNKLElBQUl3QyxpQkFBaUJFLFdBQVc7WUFDNUIxQyxVQUFVbEIsUUFBUSxDQUFDRixPQUFPLEVBQUU7WUFDNUIsT0FBT0UsUUFBUSxDQUFDRixPQUFPLEVBQUU7WUFDekIsSUFBSW9CLFdBQVl4QixDQUFBQSx3QkFBd0J3QixRQUFRQyxJQUFJLEtBQUssT0FBT0QsUUFBUUUsU0FBUyxHQUFHO2dCQUNoRnVDLE1BQU16QyxRQUFRRyxPQUFPLEdBQUdILFFBQVFZLElBQUksR0FBRztZQUMzQztRQUNKLE9BQU87WUFDSCx3QkFBd0IsR0FDeEIsSUFBSS9CLGtCQUFrQjJELGNBQWM7Z0JBQ2hDUDtZQUNKO1lBQ0FqQyxVQUFVbEIsUUFBUSxDQUFDMEQsYUFBYTtZQUNoQyxPQUFPMUQsUUFBUSxDQUFDMEQsYUFBYTtZQUM3QixJQUFJeEMsV0FBVyxDQUFDQSxRQUFRRSxTQUFTLElBQUsxQixDQUFBQSx3QkFBd0J3QixRQUFRQyxJQUFJLEtBQUssR0FBRSxHQUFJO2dCQUNqRndDLE1BQU16QyxRQUFRRyxPQUFPLEdBQUcsT0FBT0gsUUFBUVksSUFBSTtZQUMvQztRQUNKO1FBQ0EsT0FBTzZCO0lBQ1g7SUFFQSxPQUFPRSxPQUFPQyxjQUFjLENBQUM7UUFDekJ0QixNQUFNQTtRQUNOVyxNQUFNQTtRQUNOeEMsTUFBTUE7UUFDTnlDLE1BQU1BO1FBQ05LLE1BQU1BO0lBQ1YsR0FBRyxRQUFRO1FBQ1BNLEtBQUs7WUFBYSxPQUFPakU7UUFBTTtJQUNuQztBQUNBLGlDQUFpQyxHQUNyQyIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvdG9rZW5pemUuanM/NjBlNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gdG9rZW5pemU7XG5cbnZhciBkZWxpbVJlICAgICAgICA9IC9bXFxze309OzpbXFxdLCdcIigpPD5dL2csXG4gICAgc3RyaW5nRG91YmxlUmUgPSAvKD86XCIoW15cIlxcXFxdKig/OlxcXFwuW15cIlxcXFxdKikqKVwiKS9nLFxuICAgIHN0cmluZ1NpbmdsZVJlID0gLyg/OicoW14nXFxcXF0qKD86XFxcXC5bXidcXFxcXSopKiknKS9nO1xuXG52YXIgc2V0Q29tbWVudFJlID0gL14gKlsqL10rICovLFxuICAgIHNldENvbW1lbnRBbHRSZSA9IC9eXFxzKlxcKj9cXC8qLyxcbiAgICBzZXRDb21tZW50U3BsaXRSZSA9IC9cXG4vZyxcbiAgICB3aGl0ZXNwYWNlUmUgPSAvXFxzLyxcbiAgICB1bmVzY2FwZVJlID0gL1xcXFwoLj8pL2c7XG5cbnZhciB1bmVzY2FwZU1hcCA9IHtcbiAgICBcIjBcIjogXCJcXDBcIixcbiAgICBcInJcIjogXCJcXHJcIixcbiAgICBcIm5cIjogXCJcXG5cIixcbiAgICBcInRcIjogXCJcXHRcIlxufTtcblxuLyoqXG4gKiBVbmVzY2FwZXMgYSBzdHJpbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIFN0cmluZyB0byB1bmVzY2FwZVxuICogQHJldHVybnMge3N0cmluZ30gVW5lc2NhcGVkIHN0cmluZ1xuICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZyxzdHJpbmc+fSBtYXAgU3BlY2lhbCBjaGFyYWN0ZXJzIG1hcFxuICogQG1lbWJlcm9mIHRva2VuaXplXG4gKi9cbmZ1bmN0aW9uIHVuZXNjYXBlKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSh1bmVzY2FwZVJlLCBmdW5jdGlvbigkMCwgJDEpIHtcbiAgICAgICAgc3dpdGNoICgkMSkge1xuICAgICAgICAgICAgY2FzZSBcIlxcXFxcIjpcbiAgICAgICAgICAgIGNhc2UgXCJcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gJDE7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB1bmVzY2FwZU1hcFskMV0gfHwgXCJcIjtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG50b2tlbml6ZS51bmVzY2FwZSA9IHVuZXNjYXBlO1xuXG4vKipcbiAqIEdldHMgdGhlIG5leHQgdG9rZW4gYW5kIGFkdmFuY2VzLlxuICogQHR5cGVkZWYgVG9rZW5pemVySGFuZGxlTmV4dFxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHJldHVybnMge3N0cmluZ3xudWxsfSBOZXh0IHRva2VuIG9yIGBudWxsYCBvbiBlb2ZcbiAqL1xuXG4vKipcbiAqIFBlZWtzIGZvciB0aGUgbmV4dCB0b2tlbi5cbiAqIEB0eXBlZGVmIFRva2VuaXplckhhbmRsZVBlZWtcbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gTmV4dCB0b2tlbiBvciBgbnVsbGAgb24gZW9mXG4gKi9cblxuLyoqXG4gKiBQdXNoZXMgYSB0b2tlbiBiYWNrIHRvIHRoZSBzdGFjay5cbiAqIEB0eXBlZGVmIFRva2VuaXplckhhbmRsZVB1c2hcbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiBUb2tlblxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuXG4vKipcbiAqIFNraXBzIHRoZSBuZXh0IHRva2VuLlxuICogQHR5cGVkZWYgVG9rZW5pemVySGFuZGxlU2tpcFxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtzdHJpbmd9IGV4cGVjdGVkIEV4cGVjdGVkIHRva2VuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25hbD1mYWxzZV0gSWYgb3B0aW9uYWxcbiAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIHRoZSB0b2tlbiBtYXRjaGVkXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHRva2VuIGRpZG4ndCBtYXRjaCBhbmQgaXMgbm90IG9wdGlvbmFsXG4gKi9cblxuLyoqXG4gKiBHZXRzIHRoZSBjb21tZW50IG9uIHRoZSBwcmV2aW91cyBsaW5lIG9yLCBhbHRlcm5hdGl2ZWx5LCB0aGUgbGluZSBjb21tZW50IG9uIHRoZSBzcGVjaWZpZWQgbGluZS5cbiAqIEB0eXBlZGVmIFRva2VuaXplckhhbmRsZUNtbnRcbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGluZV0gTGluZSBudW1iZXJcbiAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gQ29tbWVudCB0ZXh0IG9yIGBudWxsYCBpZiBub25lXG4gKi9cblxuLyoqXG4gKiBIYW5kbGUgb2JqZWN0IHJldHVybmVkIGZyb20ge0BsaW5rIHRva2VuaXplfS5cbiAqIEBpbnRlcmZhY2UgSVRva2VuaXplckhhbmRsZVxuICogQHByb3BlcnR5IHtUb2tlbml6ZXJIYW5kbGVOZXh0fSBuZXh0IEdldHMgdGhlIG5leHQgdG9rZW4gYW5kIGFkdmFuY2VzIChgbnVsbGAgb24gZW9mKVxuICogQHByb3BlcnR5IHtUb2tlbml6ZXJIYW5kbGVQZWVrfSBwZWVrIFBlZWtzIGZvciB0aGUgbmV4dCB0b2tlbiAoYG51bGxgIG9uIGVvZilcbiAqIEBwcm9wZXJ0eSB7VG9rZW5pemVySGFuZGxlUHVzaH0gcHVzaCBQdXNoZXMgYSB0b2tlbiBiYWNrIHRvIHRoZSBzdGFja1xuICogQHByb3BlcnR5IHtUb2tlbml6ZXJIYW5kbGVTa2lwfSBza2lwIFNraXBzIGEgdG9rZW4sIHJldHVybnMgaXRzIHByZXNlbmNlIGFuZCBhZHZhbmNlcyBvciwgaWYgbm9uLW9wdGlvbmFsIGFuZCBub3QgcHJlc2VudCwgdGhyb3dzXG4gKiBAcHJvcGVydHkge1Rva2VuaXplckhhbmRsZUNtbnR9IGNtbnQgR2V0cyB0aGUgY29tbWVudCBvbiB0aGUgcHJldmlvdXMgbGluZSBvciB0aGUgbGluZSBjb21tZW50IG9uIHRoZSBzcGVjaWZpZWQgbGluZSwgaWYgYW55XG4gKiBAcHJvcGVydHkge251bWJlcn0gbGluZSBDdXJyZW50IGxpbmUgbnVtYmVyXG4gKi9cblxuLyoqXG4gKiBUb2tlbml6ZXMgdGhlIGdpdmVuIC5wcm90byBzb3VyY2UgYW5kIHJldHVybnMgYW4gb2JqZWN0IHdpdGggdXNlZnVsIHV0aWxpdHkgZnVuY3Rpb25zLlxuICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZSBTb3VyY2UgY29udGVudHNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYWx0ZXJuYXRlQ29tbWVudE1vZGUgV2hldGhlciB3ZSBzaG91bGQgYWN0aXZhdGUgYWx0ZXJuYXRlIGNvbW1lbnQgcGFyc2luZyBtb2RlLlxuICogQHJldHVybnMge0lUb2tlbml6ZXJIYW5kbGV9IFRva2VuaXplciBoYW5kbGVcbiAqL1xuZnVuY3Rpb24gdG9rZW5pemUoc291cmNlLCBhbHRlcm5hdGVDb21tZW50TW9kZSkge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIGNhbGxiYWNrLXJldHVybiAqL1xuICAgIHNvdXJjZSA9IHNvdXJjZS50b1N0cmluZygpO1xuXG4gICAgdmFyIG9mZnNldCA9IDAsXG4gICAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGgsXG4gICAgICAgIGxpbmUgPSAxLFxuICAgICAgICBsYXN0Q29tbWVudExpbmUgPSAwLFxuICAgICAgICBjb21tZW50cyA9IHt9O1xuXG4gICAgdmFyIHN0YWNrID0gW107XG5cbiAgICB2YXIgc3RyaW5nRGVsaW0gPSBudWxsO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGVycm9yIGZvciBpbGxlZ2FsIHN5bnRheC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3ViamVjdCBTdWJqZWN0XG4gICAgICogQHJldHVybnMge0Vycm9yfSBFcnJvciBjcmVhdGVkXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gaWxsZWdhbChzdWJqZWN0KSB7XG4gICAgICAgIHJldHVybiBFcnJvcihcImlsbGVnYWwgXCIgKyBzdWJqZWN0ICsgXCIgKGxpbmUgXCIgKyBsaW5lICsgXCIpXCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlYWRzIGEgc3RyaW5nIHRpbGwgaXRzIGVuZC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBTdHJpbmcgcmVhZFxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlYWRTdHJpbmcoKSB7XG4gICAgICAgIHZhciByZSA9IHN0cmluZ0RlbGltID09PSBcIidcIiA/IHN0cmluZ1NpbmdsZVJlIDogc3RyaW5nRG91YmxlUmU7XG4gICAgICAgIHJlLmxhc3RJbmRleCA9IG9mZnNldCAtIDE7XG4gICAgICAgIHZhciBtYXRjaCA9IHJlLmV4ZWMoc291cmNlKTtcbiAgICAgICAgaWYgKCFtYXRjaClcbiAgICAgICAgICAgIHRocm93IGlsbGVnYWwoXCJzdHJpbmdcIik7XG4gICAgICAgIG9mZnNldCA9IHJlLmxhc3RJbmRleDtcbiAgICAgICAgcHVzaChzdHJpbmdEZWxpbSk7XG4gICAgICAgIHN0cmluZ0RlbGltID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHVuZXNjYXBlKG1hdGNoWzFdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjaGFyYWN0ZXIgYXQgYHBvc2Agd2l0aGluIHRoZSBzb3VyY2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBvcyBQb3NpdGlvblxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IENoYXJhY3RlclxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNoYXJBdChwb3MpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5jaGFyQXQocG9zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjdXJyZW50IGNvbW1lbnQgdGV4dC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgU3RhcnQgb2Zmc2V0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQgb2Zmc2V0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc0xlYWRpbmcgc2V0IGlmIGEgbGVhZGluZyBjb21tZW50XG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRDb21tZW50KHN0YXJ0LCBlbmQsIGlzTGVhZGluZykge1xuICAgICAgICB2YXIgY29tbWVudCA9IHtcbiAgICAgICAgICAgIHR5cGU6IHNvdXJjZS5jaGFyQXQoc3RhcnQrKyksXG4gICAgICAgICAgICBsaW5lRW1wdHk6IGZhbHNlLFxuICAgICAgICAgICAgbGVhZGluZzogaXNMZWFkaW5nLFxuICAgICAgICB9O1xuICAgICAgICB2YXIgbG9va2JhY2s7XG4gICAgICAgIGlmIChhbHRlcm5hdGVDb21tZW50TW9kZSkge1xuICAgICAgICAgICAgbG9va2JhY2sgPSAyOyAgLy8gYWx0ZXJuYXRlIGNvbW1lbnQgcGFyc2luZzogXCIvL1wiIG9yIFwiLypcIlxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9va2JhY2sgPSAzOyAgLy8gXCIvLy9cIiBvciBcIi8qKlwiXG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbW1lbnRPZmZzZXQgPSBzdGFydCAtIGxvb2tiYWNrLFxuICAgICAgICAgICAgYztcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKC0tY29tbWVudE9mZnNldCA8IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgKGMgPSBzb3VyY2UuY2hhckF0KGNvbW1lbnRPZmZzZXQpKSA9PT0gXCJcXG5cIikge1xuICAgICAgICAgICAgICAgIGNvbW1lbnQubGluZUVtcHR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAoYyA9PT0gXCIgXCIgfHwgYyA9PT0gXCJcXHRcIik7XG4gICAgICAgIHZhciBsaW5lcyA9IHNvdXJjZVxuICAgICAgICAgICAgLnN1YnN0cmluZyhzdGFydCwgZW5kKVxuICAgICAgICAgICAgLnNwbGl0KHNldENvbW1lbnRTcGxpdFJlKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIGxpbmVzW2ldID0gbGluZXNbaV1cbiAgICAgICAgICAgICAgICAucmVwbGFjZShhbHRlcm5hdGVDb21tZW50TW9kZSA/IHNldENvbW1lbnRBbHRSZSA6IHNldENvbW1lbnRSZSwgXCJcIilcbiAgICAgICAgICAgICAgICAudHJpbSgpO1xuICAgICAgICBjb21tZW50LnRleHQgPSBsaW5lc1xuICAgICAgICAgICAgLmpvaW4oXCJcXG5cIilcbiAgICAgICAgICAgIC50cmltKCk7XG5cbiAgICAgICAgY29tbWVudHNbbGluZV0gPSBjb21tZW50O1xuICAgICAgICBsYXN0Q29tbWVudExpbmUgPSBsaW5lO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRG91YmxlU2xhc2hDb21tZW50TGluZShzdGFydE9mZnNldCkge1xuICAgICAgICB2YXIgZW5kT2Zmc2V0ID0gZmluZEVuZE9mTGluZShzdGFydE9mZnNldCk7XG5cbiAgICAgICAgLy8gc2VlIGlmIHJlbWFpbmluZyBsaW5lIG1hdGNoZXMgY29tbWVudCBwYXR0ZXJuXG4gICAgICAgIHZhciBsaW5lVGV4dCA9IHNvdXJjZS5zdWJzdHJpbmcoc3RhcnRPZmZzZXQsIGVuZE9mZnNldCk7XG4gICAgICAgIHZhciBpc0NvbW1lbnQgPSAvXlxccypcXC9cXC8vLnRlc3QobGluZVRleHQpO1xuICAgICAgICByZXR1cm4gaXNDb21tZW50O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbmRFbmRPZkxpbmUoY3Vyc29yKSB7XG4gICAgICAgIC8vIGZpbmQgZW5kIG9mIGN1cnNvcidzIGxpbmVcbiAgICAgICAgdmFyIGVuZE9mZnNldCA9IGN1cnNvcjtcbiAgICAgICAgd2hpbGUgKGVuZE9mZnNldCA8IGxlbmd0aCAmJiBjaGFyQXQoZW5kT2Zmc2V0KSAhPT0gXCJcXG5cIikge1xuICAgICAgICAgICAgZW5kT2Zmc2V0Kys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVuZE9mZnNldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPYnRhaW5zIHRoZSBuZXh0IHRva2VuLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gTmV4dCB0b2tlbiBvciBgbnVsbGAgb24gZW9mXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA+IDApXG4gICAgICAgICAgICByZXR1cm4gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgaWYgKHN0cmluZ0RlbGltKVxuICAgICAgICAgICAgcmV0dXJuIHJlYWRTdHJpbmcoKTtcbiAgICAgICAgdmFyIHJlcGVhdCxcbiAgICAgICAgICAgIHByZXYsXG4gICAgICAgICAgICBjdXJyLFxuICAgICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgICBpc0RvYyxcbiAgICAgICAgICAgIGlzTGVhZGluZ0NvbW1lbnQgPSBvZmZzZXQgPT09IDA7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPT09IGxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHJlcGVhdCA9IGZhbHNlO1xuICAgICAgICAgICAgd2hpbGUgKHdoaXRlc3BhY2VSZS50ZXN0KGN1cnIgPSBjaGFyQXQob2Zmc2V0KSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VyciA9PT0gXCJcXG5cIikge1xuICAgICAgICAgICAgICAgICAgICBpc0xlYWRpbmdDb21tZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgKytsaW5lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKytvZmZzZXQgPT09IGxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjaGFyQXQob2Zmc2V0KSA9PT0gXCIvXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoKytvZmZzZXQgPT09IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKFwiY29tbWVudFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNoYXJBdChvZmZzZXQpID09PSBcIi9cIikgeyAvLyBMaW5lXG4gICAgICAgICAgICAgICAgICAgIGlmICghYWx0ZXJuYXRlQ29tbWVudE1vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZvciB0cmlwbGUtc2xhc2ggY29tbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNEb2MgPSBjaGFyQXQoc3RhcnQgPSBvZmZzZXQgKyAxKSA9PT0gXCIvXCI7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChjaGFyQXQoKytvZmZzZXQpICE9PSBcIlxcblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9mZnNldCA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICsrb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRG9jKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0Q29tbWVudChzdGFydCwgb2Zmc2V0IC0gMSwgaXNMZWFkaW5nQ29tbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJhaWxpbmcgY29tbWVudCBjYW5ub3Qgbm90IGJlIG11bHRpLWxpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc28gbGVhZGluZyBjb21tZW50IHN0YXRlIHNob3VsZCBiZSByZXNldCB0byBoYW5kbGUgcG90ZW50aWFsIG5leHQgY29tbWVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0xlYWRpbmdDb21tZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICsrbGluZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcGVhdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3IgZG91YmxlLXNsYXNoIGNvbW1lbnRzLCBjb25zb2xpZGF0aW5nIGNvbnNlY3V0aXZlIGxpbmVzXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRG9jID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNEb3VibGVTbGFzaENvbW1lbnRMaW5lKG9mZnNldCAtIDEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNEb2MgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gZmluZEVuZE9mTGluZShvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2Zmc2V0ID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTGVhZGluZ0NvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyYWlsaW5nIGNvbW1lbnQgY2Fubm90IG5vdCBiZSBtdWx0aS1saW5lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKGlzRG91YmxlU2xhc2hDb21tZW50TGluZShvZmZzZXQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gTWF0aC5taW4obGVuZ3RoLCBmaW5kRW5kT2ZMaW5lKG9mZnNldCkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0RvYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldENvbW1lbnQoc3RhcnQsIG9mZnNldCwgaXNMZWFkaW5nQ29tbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNMZWFkaW5nQ29tbWVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lKys7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXBlYXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICgoY3VyciA9IGNoYXJBdChvZmZzZXQpKSA9PT0gXCIqXCIpIHsgLyogQmxvY2sgKi9cbiAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIC8qKiAocmVndWxhciBjb21tZW50IG1vZGUpIG9yIC8qIChhbHRlcm5hdGUgY29tbWVudCBtb2RlKVxuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IG9mZnNldCArIDE7XG4gICAgICAgICAgICAgICAgICAgIGlzRG9jID0gYWx0ZXJuYXRlQ29tbWVudE1vZGUgfHwgY2hhckF0KHN0YXJ0KSA9PT0gXCIqXCI7XG4gICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyID09PSBcIlxcblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKytsaW5lO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCsrb2Zmc2V0ID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKFwiY29tbWVudFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXYgPSBjdXJyO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VyciA9IGNoYXJBdChvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICB9IHdoaWxlIChwcmV2ICE9PSBcIipcIiB8fCBjdXJyICE9PSBcIi9cIik7XG4gICAgICAgICAgICAgICAgICAgICsrb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNEb2MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldENvbW1lbnQoc3RhcnQsIG9mZnNldCAtIDIsIGlzTGVhZGluZ0NvbW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNMZWFkaW5nQ29tbWVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVwZWF0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCIvXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChyZXBlYXQpO1xuXG4gICAgICAgIC8vIG9mZnNldCAhPT0gbGVuZ3RoIGlmIHdlIGdvdCBoZXJlXG5cbiAgICAgICAgdmFyIGVuZCA9IG9mZnNldDtcbiAgICAgICAgZGVsaW1SZS5sYXN0SW5kZXggPSAwO1xuICAgICAgICB2YXIgZGVsaW0gPSBkZWxpbVJlLnRlc3QoY2hhckF0KGVuZCsrKSk7XG4gICAgICAgIGlmICghZGVsaW0pXG4gICAgICAgICAgICB3aGlsZSAoZW5kIDwgbGVuZ3RoICYmICFkZWxpbVJlLnRlc3QoY2hhckF0KGVuZCkpKVxuICAgICAgICAgICAgICAgICsrZW5kO1xuICAgICAgICB2YXIgdG9rZW4gPSBzb3VyY2Uuc3Vic3RyaW5nKG9mZnNldCwgb2Zmc2V0ID0gZW5kKTtcbiAgICAgICAgaWYgKHRva2VuID09PSBcIlxcXCJcIiB8fCB0b2tlbiA9PT0gXCInXCIpXG4gICAgICAgICAgICBzdHJpbmdEZWxpbSA9IHRva2VuO1xuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHVzaGVzIGEgdG9rZW4gYmFjayB0byB0aGUgc3RhY2suXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIFRva2VuXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwdXNoKHRva2VuKSB7XG4gICAgICAgIHN0YWNrLnB1c2godG9rZW4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlZWtzIGZvciB0aGUgbmV4dCB0b2tlbi5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IFRva2VuIG9yIGBudWxsYCBvbiBlb2ZcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwZWVrKCkge1xuICAgICAgICBpZiAoIXN0YWNrLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHRva2VuID0gbmV4dCgpO1xuICAgICAgICAgICAgaWYgKHRva2VuID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcHVzaCh0b2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YWNrWzBdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNraXBzIGEgdG9rZW4uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV4cGVjdGVkIEV4cGVjdGVkIHRva2VuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9uYWw9ZmFsc2VdIFdoZXRoZXIgdGhlIHRva2VuIGlzIG9wdGlvbmFsXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCB3aGVuIHNraXBwZWQsIGBmYWxzZWAgaWYgbm90XG4gICAgICogQHRocm93cyB7RXJyb3J9IFdoZW4gYSByZXF1aXJlZCB0b2tlbiBpcyBub3QgcHJlc2VudFxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNraXAoZXhwZWN0ZWQsIG9wdGlvbmFsKSB7XG4gICAgICAgIHZhciBhY3R1YWwgPSBwZWVrKCksXG4gICAgICAgICAgICBlcXVhbHMgPSBhY3R1YWwgPT09IGV4cGVjdGVkO1xuICAgICAgICBpZiAoZXF1YWxzKSB7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW9wdGlvbmFsKVxuICAgICAgICAgICAgdGhyb3cgaWxsZWdhbChcInRva2VuICdcIiArIGFjdHVhbCArIFwiJywgJ1wiICsgZXhwZWN0ZWQgKyBcIicgZXhwZWN0ZWRcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgY29tbWVudC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3RyYWlsaW5nTGluZV0gTGluZSBudW1iZXIgaWYgbG9va2luZyBmb3IgYSB0cmFpbGluZyBjb21tZW50XG4gICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfSBDb21tZW50IHRleHRcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbW50KHRyYWlsaW5nTGluZSkge1xuICAgICAgICB2YXIgcmV0ID0gbnVsbDtcbiAgICAgICAgdmFyIGNvbW1lbnQ7XG4gICAgICAgIGlmICh0cmFpbGluZ0xpbmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29tbWVudCA9IGNvbW1lbnRzW2xpbmUgLSAxXTtcbiAgICAgICAgICAgIGRlbGV0ZSBjb21tZW50c1tsaW5lIC0gMV07XG4gICAgICAgICAgICBpZiAoY29tbWVudCAmJiAoYWx0ZXJuYXRlQ29tbWVudE1vZGUgfHwgY29tbWVudC50eXBlID09PSBcIipcIiB8fCBjb21tZW50LmxpbmVFbXB0eSkpIHtcbiAgICAgICAgICAgICAgICByZXQgPSBjb21tZW50LmxlYWRpbmcgPyBjb21tZW50LnRleHQgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmIChsYXN0Q29tbWVudExpbmUgPCB0cmFpbGluZ0xpbmUpIHtcbiAgICAgICAgICAgICAgICBwZWVrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb21tZW50ID0gY29tbWVudHNbdHJhaWxpbmdMaW5lXTtcbiAgICAgICAgICAgIGRlbGV0ZSBjb21tZW50c1t0cmFpbGluZ0xpbmVdO1xuICAgICAgICAgICAgaWYgKGNvbW1lbnQgJiYgIWNvbW1lbnQubGluZUVtcHR5ICYmIChhbHRlcm5hdGVDb21tZW50TW9kZSB8fCBjb21tZW50LnR5cGUgPT09IFwiL1wiKSkge1xuICAgICAgICAgICAgICAgIHJldCA9IGNvbW1lbnQubGVhZGluZyA/IG51bGwgOiBjb21tZW50LnRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHtcbiAgICAgICAgbmV4dDogbmV4dCxcbiAgICAgICAgcGVlazogcGVlayxcbiAgICAgICAgcHVzaDogcHVzaCxcbiAgICAgICAgc2tpcDogc2tpcCxcbiAgICAgICAgY21udDogY21udFxuICAgIH0sIFwibGluZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBsaW5lOyB9XG4gICAgfSk7XG4gICAgLyogZXNsaW50LWVuYWJsZSBjYWxsYmFjay1yZXR1cm4gKi9cbn1cbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwidG9rZW5pemUiLCJkZWxpbVJlIiwic3RyaW5nRG91YmxlUmUiLCJzdHJpbmdTaW5nbGVSZSIsInNldENvbW1lbnRSZSIsInNldENvbW1lbnRBbHRSZSIsInNldENvbW1lbnRTcGxpdFJlIiwid2hpdGVzcGFjZVJlIiwidW5lc2NhcGVSZSIsInVuZXNjYXBlTWFwIiwidW5lc2NhcGUiLCJzdHIiLCJyZXBsYWNlIiwiJDAiLCIkMSIsInNvdXJjZSIsImFsdGVybmF0ZUNvbW1lbnRNb2RlIiwidG9TdHJpbmciLCJvZmZzZXQiLCJsZW5ndGgiLCJsaW5lIiwibGFzdENvbW1lbnRMaW5lIiwiY29tbWVudHMiLCJzdGFjayIsInN0cmluZ0RlbGltIiwiaWxsZWdhbCIsInN1YmplY3QiLCJFcnJvciIsInJlYWRTdHJpbmciLCJyZSIsImxhc3RJbmRleCIsIm1hdGNoIiwiZXhlYyIsInB1c2giLCJjaGFyQXQiLCJwb3MiLCJzZXRDb21tZW50Iiwic3RhcnQiLCJlbmQiLCJpc0xlYWRpbmciLCJjb21tZW50IiwidHlwZSIsImxpbmVFbXB0eSIsImxlYWRpbmciLCJsb29rYmFjayIsImNvbW1lbnRPZmZzZXQiLCJjIiwibGluZXMiLCJzdWJzdHJpbmciLCJzcGxpdCIsImkiLCJ0cmltIiwidGV4dCIsImpvaW4iLCJpc0RvdWJsZVNsYXNoQ29tbWVudExpbmUiLCJzdGFydE9mZnNldCIsImVuZE9mZnNldCIsImZpbmRFbmRPZkxpbmUiLCJsaW5lVGV4dCIsImlzQ29tbWVudCIsInRlc3QiLCJjdXJzb3IiLCJuZXh0Iiwic2hpZnQiLCJyZXBlYXQiLCJwcmV2IiwiY3VyciIsImlzRG9jIiwiaXNMZWFkaW5nQ29tbWVudCIsIk1hdGgiLCJtaW4iLCJkZWxpbSIsInRva2VuIiwicGVlayIsInNraXAiLCJleHBlY3RlZCIsIm9wdGlvbmFsIiwiYWN0dWFsIiwiZXF1YWxzIiwiY21udCIsInRyYWlsaW5nTGluZSIsInJldCIsInVuZGVmaW5lZCIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZ2V0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/protobufjs/src/tokenize.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/src/type.js":
/*!**********************************************!*\
  !*** ../node_modules/protobufjs/src/type.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = Type;\n// extends Namespace\nvar Namespace = __webpack_require__(/*! ./namespace */ \"(ssr)/../node_modules/protobufjs/src/namespace.js\");\n((Type.prototype = Object.create(Namespace.prototype)).constructor = Type).className = \"Type\";\nvar Enum = __webpack_require__(/*! ./enum */ \"(ssr)/../node_modules/protobufjs/src/enum.js\"), OneOf = __webpack_require__(/*! ./oneof */ \"(ssr)/../node_modules/protobufjs/src/oneof.js\"), Field = __webpack_require__(/*! ./field */ \"(ssr)/../node_modules/protobufjs/src/field.js\"), MapField = __webpack_require__(/*! ./mapfield */ \"(ssr)/../node_modules/protobufjs/src/mapfield.js\"), Service = __webpack_require__(/*! ./service */ \"(ssr)/../node_modules/protobufjs/src/service.js\"), Message = __webpack_require__(/*! ./message */ \"(ssr)/../node_modules/protobufjs/src/message.js\"), Reader = __webpack_require__(/*! ./reader */ \"(ssr)/../node_modules/protobufjs/src/reader.js\"), Writer = __webpack_require__(/*! ./writer */ \"(ssr)/../node_modules/protobufjs/src/writer.js\"), util = __webpack_require__(/*! ./util */ \"(ssr)/../node_modules/protobufjs/src/util.js\"), encoder = __webpack_require__(/*! ./encoder */ \"(ssr)/../node_modules/protobufjs/src/encoder.js\"), decoder = __webpack_require__(/*! ./decoder */ \"(ssr)/../node_modules/protobufjs/src/decoder.js\"), verifier = __webpack_require__(/*! ./verifier */ \"(ssr)/../node_modules/protobufjs/src/verifier.js\"), converter = __webpack_require__(/*! ./converter */ \"(ssr)/../node_modules/protobufjs/src/converter.js\"), wrappers = __webpack_require__(/*! ./wrappers */ \"(ssr)/../node_modules/protobufjs/src/wrappers.js\");\n/**\n * Constructs a new reflected message type instance.\n * @classdesc Reflected message type.\n * @extends NamespaceBase\n * @constructor\n * @param {string} name Message name\n * @param {Object.<string,*>} [options] Declared options\n */ function Type(name, options) {\n    Namespace.call(this, name, options);\n    /**\n     * Message fields.\n     * @type {Object.<string,Field>}\n     */ this.fields = {}; // toJSON, marker\n    /**\n     * Oneofs declared within this namespace, if any.\n     * @type {Object.<string,OneOf>}\n     */ this.oneofs = undefined; // toJSON\n    /**\n     * Extension ranges, if any.\n     * @type {number[][]}\n     */ this.extensions = undefined; // toJSON\n    /**\n     * Reserved ranges, if any.\n     * @type {Array.<number[]|string>}\n     */ this.reserved = undefined; // toJSON\n    /*?\n     * Whether this type is a legacy group.\n     * @type {boolean|undefined}\n     */ this.group = undefined; // toJSON\n    /**\n     * Cached fields by id.\n     * @type {Object.<number,Field>|null}\n     * @private\n     */ this._fieldsById = null;\n    /**\n     * Cached fields as an array.\n     * @type {Field[]|null}\n     * @private\n     */ this._fieldsArray = null;\n    /**\n     * Cached oneofs as an array.\n     * @type {OneOf[]|null}\n     * @private\n     */ this._oneofsArray = null;\n    /**\n     * Cached constructor.\n     * @type {Constructor<{}>}\n     * @private\n     */ this._ctor = null;\n}\nObject.defineProperties(Type.prototype, {\n    /**\n     * Message fields by id.\n     * @name Type#fieldsById\n     * @type {Object.<number,Field>}\n     * @readonly\n     */ fieldsById: {\n        get: function() {\n            /* istanbul ignore if */ if (this._fieldsById) return this._fieldsById;\n            this._fieldsById = {};\n            for(var names = Object.keys(this.fields), i = 0; i < names.length; ++i){\n                var field = this.fields[names[i]], id = field.id;\n                /* istanbul ignore if */ if (this._fieldsById[id]) throw Error(\"duplicate id \" + id + \" in \" + this);\n                this._fieldsById[id] = field;\n            }\n            return this._fieldsById;\n        }\n    },\n    /**\n     * Fields of this message as an array for iteration.\n     * @name Type#fieldsArray\n     * @type {Field[]}\n     * @readonly\n     */ fieldsArray: {\n        get: function() {\n            return this._fieldsArray || (this._fieldsArray = util.toArray(this.fields));\n        }\n    },\n    /**\n     * Oneofs of this message as an array for iteration.\n     * @name Type#oneofsArray\n     * @type {OneOf[]}\n     * @readonly\n     */ oneofsArray: {\n        get: function() {\n            return this._oneofsArray || (this._oneofsArray = util.toArray(this.oneofs));\n        }\n    },\n    /**\n     * The registered constructor, if any registered, otherwise a generic constructor.\n     * Assigning a function replaces the internal constructor. If the function does not extend {@link Message} yet, its prototype will be setup accordingly and static methods will be populated. If it already extends {@link Message}, it will just replace the internal constructor.\n     * @name Type#ctor\n     * @type {Constructor<{}>}\n     */ ctor: {\n        get: function() {\n            return this._ctor || (this.ctor = Type.generateConstructor(this)());\n        },\n        set: function(ctor) {\n            // Ensure proper prototype\n            var prototype = ctor.prototype;\n            if (!(prototype instanceof Message)) {\n                (ctor.prototype = new Message()).constructor = ctor;\n                util.merge(ctor.prototype, prototype);\n            }\n            // Classes and messages reference their reflected type\n            ctor.$type = ctor.prototype.$type = this;\n            // Mix in static methods\n            util.merge(ctor, Message, true);\n            this._ctor = ctor;\n            // Messages have non-enumerable default values on their prototype\n            var i = 0;\n            for(; i < /* initializes */ this.fieldsArray.length; ++i)this._fieldsArray[i].resolve(); // ensures a proper value\n            // Messages have non-enumerable getters and setters for each virtual oneof field\n            var ctorProperties = {};\n            for(i = 0; i < /* initializes */ this.oneofsArray.length; ++i)ctorProperties[this._oneofsArray[i].resolve().name] = {\n                get: util.oneOfGetter(this._oneofsArray[i].oneof),\n                set: util.oneOfSetter(this._oneofsArray[i].oneof)\n            };\n            if (i) Object.defineProperties(ctor.prototype, ctorProperties);\n        }\n    }\n});\n/**\n * Generates a constructor function for the specified type.\n * @param {Type} mtype Message type\n * @returns {Codegen} Codegen instance\n */ Type.generateConstructor = function generateConstructor(mtype) {\n    /* eslint-disable no-unexpected-multiline */ var gen = util.codegen([\n        \"p\"\n    ], mtype.name);\n    // explicitly initialize mutable object/array fields so that these aren't just inherited from the prototype\n    for(var i = 0, field; i < mtype.fieldsArray.length; ++i)if ((field = mtype._fieldsArray[i]).map) gen(\"this%s={}\", util.safeProp(field.name));\n    else if (field.repeated) gen(\"this%s=[]\", util.safeProp(field.name));\n    return gen(\"if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)\") // omit undefined or null\n    (\"this[ks[i]]=p[ks[i]]\");\n/* eslint-enable no-unexpected-multiline */ };\nfunction clearCache(type) {\n    type._fieldsById = type._fieldsArray = type._oneofsArray = null;\n    delete type.encode;\n    delete type.decode;\n    delete type.verify;\n    return type;\n}\n/**\n * Message type descriptor.\n * @interface IType\n * @extends INamespace\n * @property {Object.<string,IOneOf>} [oneofs] Oneof descriptors\n * @property {Object.<string,IField>} fields Field descriptors\n * @property {number[][]} [extensions] Extension ranges\n * @property {number[][]} [reserved] Reserved ranges\n * @property {boolean} [group=false] Whether a legacy group or not\n */ /**\n * Creates a message type from a message type descriptor.\n * @param {string} name Message name\n * @param {IType} json Message type descriptor\n * @returns {Type} Created message type\n */ Type.fromJSON = function fromJSON(name, json) {\n    var type = new Type(name, json.options);\n    type.extensions = json.extensions;\n    type.reserved = json.reserved;\n    var names = Object.keys(json.fields), i = 0;\n    for(; i < names.length; ++i)type.add((typeof json.fields[names[i]].keyType !== \"undefined\" ? MapField.fromJSON : Field.fromJSON)(names[i], json.fields[names[i]]));\n    if (json.oneofs) for(names = Object.keys(json.oneofs), i = 0; i < names.length; ++i)type.add(OneOf.fromJSON(names[i], json.oneofs[names[i]]));\n    if (json.nested) for(names = Object.keys(json.nested), i = 0; i < names.length; ++i){\n        var nested = json.nested[names[i]];\n        type.add((nested.id !== undefined ? Field.fromJSON : nested.fields !== undefined ? Type.fromJSON : nested.values !== undefined ? Enum.fromJSON : nested.methods !== undefined ? Service.fromJSON : Namespace.fromJSON)(names[i], nested));\n    }\n    if (json.extensions && json.extensions.length) type.extensions = json.extensions;\n    if (json.reserved && json.reserved.length) type.reserved = json.reserved;\n    if (json.group) type.group = true;\n    if (json.comment) type.comment = json.comment;\n    return type;\n};\n/**\n * Converts this message type to a message type descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IType} Message type descriptor\n */ Type.prototype.toJSON = function toJSON(toJSONOptions) {\n    var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n    return util.toObject([\n        \"options\",\n        inherited && inherited.options || undefined,\n        \"oneofs\",\n        Namespace.arrayToJSON(this.oneofsArray, toJSONOptions),\n        \"fields\",\n        Namespace.arrayToJSON(this.fieldsArray.filter(function(obj) {\n            return !obj.declaringField;\n        }), toJSONOptions) || {},\n        \"extensions\",\n        this.extensions && this.extensions.length ? this.extensions : undefined,\n        \"reserved\",\n        this.reserved && this.reserved.length ? this.reserved : undefined,\n        \"group\",\n        this.group || undefined,\n        \"nested\",\n        inherited && inherited.nested || undefined,\n        \"comment\",\n        keepComments ? this.comment : undefined\n    ]);\n};\n/**\n * @override\n */ Type.prototype.resolveAll = function resolveAll() {\n    var fields = this.fieldsArray, i = 0;\n    while(i < fields.length)fields[i++].resolve();\n    var oneofs = this.oneofsArray;\n    i = 0;\n    while(i < oneofs.length)oneofs[i++].resolve();\n    return Namespace.prototype.resolveAll.call(this);\n};\n/**\n * @override\n */ Type.prototype.get = function get(name) {\n    return this.fields[name] || this.oneofs && this.oneofs[name] || this.nested && this.nested[name] || null;\n};\n/**\n * Adds a nested object to this type.\n * @param {ReflectionObject} object Nested object to add\n * @returns {Type} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If there is already a nested object with this name or, if a field, when there is already a field with this id\n */ Type.prototype.add = function add(object) {\n    if (this.get(object.name)) throw Error(\"duplicate name '\" + object.name + \"' in \" + this);\n    if (object instanceof Field && object.extend === undefined) {\n        // NOTE: Extension fields aren't actual fields on the declaring type, but nested objects.\n        // The root object takes care of adding distinct sister-fields to the respective extended\n        // type instead.\n        // avoids calling the getter if not absolutely necessary because it's called quite frequently\n        if (this._fieldsById ? /* istanbul ignore next */ this._fieldsById[object.id] : this.fieldsById[object.id]) throw Error(\"duplicate id \" + object.id + \" in \" + this);\n        if (this.isReservedId(object.id)) throw Error(\"id \" + object.id + \" is reserved in \" + this);\n        if (this.isReservedName(object.name)) throw Error(\"name '\" + object.name + \"' is reserved in \" + this);\n        if (object.parent) object.parent.remove(object);\n        this.fields[object.name] = object;\n        object.message = this;\n        object.onAdd(this);\n        return clearCache(this);\n    }\n    if (object instanceof OneOf) {\n        if (!this.oneofs) this.oneofs = {};\n        this.oneofs[object.name] = object;\n        object.onAdd(this);\n        return clearCache(this);\n    }\n    return Namespace.prototype.add.call(this, object);\n};\n/**\n * Removes a nested object from this type.\n * @param {ReflectionObject} object Nested object to remove\n * @returns {Type} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If `object` is not a member of this type\n */ Type.prototype.remove = function remove(object) {\n    if (object instanceof Field && object.extend === undefined) {\n        // See Type#add for the reason why extension fields are excluded here.\n        /* istanbul ignore if */ if (!this.fields || this.fields[object.name] !== object) throw Error(object + \" is not a member of \" + this);\n        delete this.fields[object.name];\n        object.parent = null;\n        object.onRemove(this);\n        return clearCache(this);\n    }\n    if (object instanceof OneOf) {\n        /* istanbul ignore if */ if (!this.oneofs || this.oneofs[object.name] !== object) throw Error(object + \" is not a member of \" + this);\n        delete this.oneofs[object.name];\n        object.parent = null;\n        object.onRemove(this);\n        return clearCache(this);\n    }\n    return Namespace.prototype.remove.call(this, object);\n};\n/**\n * Tests if the specified id is reserved.\n * @param {number} id Id to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */ Type.prototype.isReservedId = function isReservedId(id) {\n    return Namespace.isReservedId(this.reserved, id);\n};\n/**\n * Tests if the specified name is reserved.\n * @param {string} name Name to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */ Type.prototype.isReservedName = function isReservedName(name) {\n    return Namespace.isReservedName(this.reserved, name);\n};\n/**\n * Creates a new message of this type using the specified properties.\n * @param {Object.<string,*>} [properties] Properties to set\n * @returns {Message<{}>} Message instance\n */ Type.prototype.create = function create(properties) {\n    return new this.ctor(properties);\n};\n/**\n * Sets up {@link Type#encode|encode}, {@link Type#decode|decode} and {@link Type#verify|verify}.\n * @returns {Type} `this`\n */ Type.prototype.setup = function setup() {\n    // Sets up everything at once so that the prototype chain does not have to be re-evaluated\n    // multiple times (V8, soft-deopt prototype-check).\n    var fullName = this.fullName, types = [];\n    for(var i = 0; i < /* initializes */ this.fieldsArray.length; ++i)types.push(this._fieldsArray[i].resolve().resolvedType);\n    // Replace setup methods with type-specific generated functions\n    this.encode = encoder(this)({\n        Writer: Writer,\n        types: types,\n        util: util\n    });\n    this.decode = decoder(this)({\n        Reader: Reader,\n        types: types,\n        util: util\n    });\n    this.verify = verifier(this)({\n        types: types,\n        util: util\n    });\n    this.fromObject = converter.fromObject(this)({\n        types: types,\n        util: util\n    });\n    this.toObject = converter.toObject(this)({\n        types: types,\n        util: util\n    });\n    // Inject custom wrappers for common types\n    var wrapper = wrappers[fullName];\n    if (wrapper) {\n        var originalThis = Object.create(this);\n        // if (wrapper.fromObject) {\n        originalThis.fromObject = this.fromObject;\n        this.fromObject = wrapper.fromObject.bind(originalThis);\n        // }\n        // if (wrapper.toObject) {\n        originalThis.toObject = this.toObject;\n        this.toObject = wrapper.toObject.bind(originalThis);\n    // }\n    }\n    return this;\n};\n/**\n * Encodes a message of this type. Does not implicitly {@link Type#verify|verify} messages.\n * @param {Message<{}>|Object.<string,*>} message Message instance or plain object\n * @param {Writer} [writer] Writer to encode to\n * @returns {Writer} writer\n */ Type.prototype.encode = function encode_setup(message, writer) {\n    return this.setup().encode(message, writer); // overrides this method\n};\n/**\n * Encodes a message of this type preceeded by its byte length as a varint. Does not implicitly {@link Type#verify|verify} messages.\n * @param {Message<{}>|Object.<string,*>} message Message instance or plain object\n * @param {Writer} [writer] Writer to encode to\n * @returns {Writer} writer\n */ Type.prototype.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();\n};\n/**\n * Decodes a message of this type.\n * @param {Reader|Uint8Array} reader Reader or buffer to decode from\n * @param {number} [length] Length of the message, if known beforehand\n * @returns {Message<{}>} Decoded message\n * @throws {Error} If the payload is not a reader or valid buffer\n * @throws {util.ProtocolError<{}>} If required fields are missing\n */ Type.prototype.decode = function decode_setup(reader, length) {\n    return this.setup().decode(reader, length); // overrides this method\n};\n/**\n * Decodes a message of this type preceeded by its byte length as a varint.\n * @param {Reader|Uint8Array} reader Reader or buffer to decode from\n * @returns {Message<{}>} Decoded message\n * @throws {Error} If the payload is not a reader or valid buffer\n * @throws {util.ProtocolError} If required fields are missing\n */ Type.prototype.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof Reader)) reader = Reader.create(reader);\n    return this.decode(reader, reader.uint32());\n};\n/**\n * Verifies that field values are valid and that required fields are present.\n * @param {Object.<string,*>} message Plain object to verify\n * @returns {null|string} `null` if valid, otherwise the reason why it is not\n */ Type.prototype.verify = function verify_setup(message) {\n    return this.setup().verify(message); // overrides this method\n};\n/**\n * Creates a new message of this type from a plain object. Also converts values to their respective internal types.\n * @param {Object.<string,*>} object Plain object to convert\n * @returns {Message<{}>} Message instance\n */ Type.prototype.fromObject = function fromObject(object) {\n    return this.setup().fromObject(object);\n};\n/**\n * Conversion options as used by {@link Type#toObject} and {@link Message.toObject}.\n * @interface IConversionOptions\n * @property {Function} [longs] Long conversion type.\n * Valid values are `String` and `Number` (the global types).\n * Defaults to copy the present value, which is a possibly unsafe number without and a {@link Long} with a long library.\n * @property {Function} [enums] Enum value conversion type.\n * Only valid value is `String` (the global type).\n * Defaults to copy the present value, which is the numeric id.\n * @property {Function} [bytes] Bytes value conversion type.\n * Valid values are `Array` and (a base64 encoded) `String` (the global types).\n * Defaults to copy the present value, which usually is a Buffer under node and an Uint8Array in the browser.\n * @property {boolean} [defaults=false] Also sets default values on the resulting object\n * @property {boolean} [arrays=false] Sets empty arrays for missing repeated fields even if `defaults=false`\n * @property {boolean} [objects=false] Sets empty objects for missing map fields even if `defaults=false`\n * @property {boolean} [oneofs=false] Includes virtual oneof properties set to the present field's name, if any\n * @property {boolean} [json=false] Performs additional JSON compatibility conversions, i.e. NaN and Infinity to strings\n */ /**\n * Creates a plain object from a message of this type. Also converts values to other types if specified.\n * @param {Message<{}>} message Message instance\n * @param {IConversionOptions} [options] Conversion options\n * @returns {Object.<string,*>} Plain object\n */ Type.prototype.toObject = function toObject(message, options) {\n    return this.setup().toObject(message, options);\n};\n/**\n * Decorator function as returned by {@link Type.d} (TypeScript).\n * @typedef TypeDecorator\n * @type {function}\n * @param {Constructor<T>} target Target constructor\n * @returns {undefined}\n * @template T extends Message<T>\n */ /**\n * Type decorator (TypeScript).\n * @param {string} [typeName] Type name, defaults to the constructor's name\n * @returns {TypeDecorator<T>} Decorator function\n * @template T extends Message<T>\n */ Type.d = function decorateType(typeName) {\n    return function typeDecorator(target) {\n        util.decorateType(target, typeName);\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3R5cGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsT0FBT0MsT0FBTyxHQUFHQztBQUVqQixvQkFBb0I7QUFDcEIsSUFBSUMsWUFBWUMsbUJBQU9BLENBQUMsc0VBQWE7QUFDcEMsRUFBQ0YsS0FBS0csU0FBUyxHQUFHQyxPQUFPQyxNQUFNLENBQUNKLFVBQVVFLFNBQVMsR0FBR0csV0FBVyxHQUFHTixJQUFHLEVBQUdPLFNBQVMsR0FBRztBQUV2RixJQUFJQyxPQUFZTixtQkFBT0EsQ0FBQyw0REFBUSxHQUM1Qk8sUUFBWVAsbUJBQU9BLENBQUMsOERBQVMsR0FDN0JRLFFBQVlSLG1CQUFPQSxDQUFDLDhEQUFTLEdBQzdCUyxXQUFZVCxtQkFBT0EsQ0FBQyxvRUFBWSxHQUNoQ1UsVUFBWVYsbUJBQU9BLENBQUMsa0VBQVcsR0FDL0JXLFVBQVlYLG1CQUFPQSxDQUFDLGtFQUFXLEdBQy9CWSxTQUFZWixtQkFBT0EsQ0FBQyxnRUFBVSxHQUM5QmEsU0FBWWIsbUJBQU9BLENBQUMsZ0VBQVUsR0FDOUJjLE9BQVlkLG1CQUFPQSxDQUFDLDREQUFRLEdBQzVCZSxVQUFZZixtQkFBT0EsQ0FBQyxrRUFBVyxHQUMvQmdCLFVBQVloQixtQkFBT0EsQ0FBQyxrRUFBVyxHQUMvQmlCLFdBQVlqQixtQkFBT0EsQ0FBQyxvRUFBWSxHQUNoQ2tCLFlBQVlsQixtQkFBT0EsQ0FBQyxzRUFBYSxHQUNqQ21CLFdBQVluQixtQkFBT0EsQ0FBQyxvRUFBWTtBQUVwQzs7Ozs7OztDQU9DLEdBQ0QsU0FBU0YsS0FBS3NCLElBQUksRUFBRUMsT0FBTztJQUN2QnRCLFVBQVV1QixJQUFJLENBQUMsSUFBSSxFQUFFRixNQUFNQztJQUUzQjs7O0tBR0MsR0FDRCxJQUFJLENBQUNFLE1BQU0sR0FBRyxDQUFDLEdBQUksaUJBQWlCO0lBRXBDOzs7S0FHQyxHQUNELElBQUksQ0FBQ0MsTUFBTSxHQUFHQyxXQUFXLFNBQVM7SUFF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LEdBQ0R4RixLQUFLRyxTQUFTLENBQUMrRSxRQUFRLEdBQUcsU0FBU0EsU0FBU1ksT0FBTyxFQUFFdkUsT0FBTztJQUN4RCxPQUFPLElBQUksQ0FBQzJFLEtBQUssR0FBR2hCLFFBQVEsQ0FBQ1ksU0FBU3ZFO0FBQzFDO0FBRUE7Ozs7Ozs7Q0FPQyxHQUVEOzs7OztDQUtDLEdBQ0R2QixLQUFLc0gsQ0FBQyxHQUFHLFNBQVNDLGFBQWFDLFFBQVE7SUFDbkMsT0FBTyxTQUFTQyxjQUFjQyxNQUFNO1FBQ2hDMUcsS0FBS3VHLFlBQVksQ0FBQ0csUUFBUUY7SUFDOUI7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvdHlwZS5qcz82ZmE3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBUeXBlO1xuXG4vLyBleHRlbmRzIE5hbWVzcGFjZVxudmFyIE5hbWVzcGFjZSA9IHJlcXVpcmUoXCIuL25hbWVzcGFjZVwiKTtcbigoVHlwZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE5hbWVzcGFjZS5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IFR5cGUpLmNsYXNzTmFtZSA9IFwiVHlwZVwiO1xuXG52YXIgRW51bSAgICAgID0gcmVxdWlyZShcIi4vZW51bVwiKSxcbiAgICBPbmVPZiAgICAgPSByZXF1aXJlKFwiLi9vbmVvZlwiKSxcbiAgICBGaWVsZCAgICAgPSByZXF1aXJlKFwiLi9maWVsZFwiKSxcbiAgICBNYXBGaWVsZCAgPSByZXF1aXJlKFwiLi9tYXBmaWVsZFwiKSxcbiAgICBTZXJ2aWNlICAgPSByZXF1aXJlKFwiLi9zZXJ2aWNlXCIpLFxuICAgIE1lc3NhZ2UgICA9IHJlcXVpcmUoXCIuL21lc3NhZ2VcIiksXG4gICAgUmVhZGVyICAgID0gcmVxdWlyZShcIi4vcmVhZGVyXCIpLFxuICAgIFdyaXRlciAgICA9IHJlcXVpcmUoXCIuL3dyaXRlclwiKSxcbiAgICB1dGlsICAgICAgPSByZXF1aXJlKFwiLi91dGlsXCIpLFxuICAgIGVuY29kZXIgICA9IHJlcXVpcmUoXCIuL2VuY29kZXJcIiksXG4gICAgZGVjb2RlciAgID0gcmVxdWlyZShcIi4vZGVjb2RlclwiKSxcbiAgICB2ZXJpZmllciAgPSByZXF1aXJlKFwiLi92ZXJpZmllclwiKSxcbiAgICBjb252ZXJ0ZXIgPSByZXF1aXJlKFwiLi9jb252ZXJ0ZXJcIiksXG4gICAgd3JhcHBlcnMgID0gcmVxdWlyZShcIi4vd3JhcHBlcnNcIik7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyByZWZsZWN0ZWQgbWVzc2FnZSB0eXBlIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBSZWZsZWN0ZWQgbWVzc2FnZSB0eXBlLlxuICogQGV4dGVuZHMgTmFtZXNwYWNlQmFzZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBNZXNzYWdlIG5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IFtvcHRpb25zXSBEZWNsYXJlZCBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIFR5cGUobmFtZSwgb3B0aW9ucykge1xuICAgIE5hbWVzcGFjZS5jYWxsKHRoaXMsIG5hbWUsIG9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogTWVzc2FnZSBmaWVsZHMuXG4gICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLEZpZWxkPn1cbiAgICAgKi9cbiAgICB0aGlzLmZpZWxkcyA9IHt9OyAgLy8gdG9KU09OLCBtYXJrZXJcblxuICAgIC8qKlxuICAgICAqIE9uZW9mcyBkZWNsYXJlZCB3aXRoaW4gdGhpcyBuYW1lc3BhY2UsIGlmIGFueS5cbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsT25lT2Y+fVxuICAgICAqL1xuICAgIHRoaXMub25lb2ZzID0gdW5kZWZpbmVkOyAvLyB0b0pTT05cblxuICAgIC8qKlxuICAgICAqIEV4dGVuc2lvbiByYW5nZXMsIGlmIGFueS5cbiAgICAgKiBAdHlwZSB7bnVtYmVyW11bXX1cbiAgICAgKi9cbiAgICB0aGlzLmV4dGVuc2lvbnMgPSB1bmRlZmluZWQ7IC8vIHRvSlNPTlxuXG4gICAgLyoqXG4gICAgICogUmVzZXJ2ZWQgcmFuZ2VzLCBpZiBhbnkuXG4gICAgICogQHR5cGUge0FycmF5LjxudW1iZXJbXXxzdHJpbmc+fVxuICAgICAqL1xuICAgIHRoaXMucmVzZXJ2ZWQgPSB1bmRlZmluZWQ7IC8vIHRvSlNPTlxuXG4gICAgLyo/XG4gICAgICogV2hldGhlciB0aGlzIHR5cGUgaXMgYSBsZWdhY3kgZ3JvdXAuXG4gICAgICogQHR5cGUge2Jvb2xlYW58dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMuZ3JvdXAgPSB1bmRlZmluZWQ7IC8vIHRvSlNPTlxuXG4gICAgLyoqXG4gICAgICogQ2FjaGVkIGZpZWxkcyBieSBpZC5cbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxudW1iZXIsRmllbGQ+fG51bGx9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9maWVsZHNCeUlkID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIENhY2hlZCBmaWVsZHMgYXMgYW4gYXJyYXkuXG4gICAgICogQHR5cGUge0ZpZWxkW118bnVsbH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2ZpZWxkc0FycmF5ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIENhY2hlZCBvbmVvZnMgYXMgYW4gYXJyYXkuXG4gICAgICogQHR5cGUge09uZU9mW118bnVsbH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX29uZW9mc0FycmF5ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIENhY2hlZCBjb25zdHJ1Y3Rvci5cbiAgICAgKiBAdHlwZSB7Q29uc3RydWN0b3I8e30+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fY3RvciA9IG51bGw7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFR5cGUucHJvdG90eXBlLCB7XG5cbiAgICAvKipcbiAgICAgKiBNZXNzYWdlIGZpZWxkcyBieSBpZC5cbiAgICAgKiBAbmFtZSBUeXBlI2ZpZWxkc0J5SWRcbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxudW1iZXIsRmllbGQ+fVxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIGZpZWxkc0J5SWQ6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAodGhpcy5fZmllbGRzQnlJZClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZmllbGRzQnlJZDtcblxuICAgICAgICAgICAgdGhpcy5fZmllbGRzQnlJZCA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgbmFtZXMgPSBPYmplY3Qua2V5cyh0aGlzLmZpZWxkcyksIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmllbGQgPSB0aGlzLmZpZWxkc1tuYW1lc1tpXV0sXG4gICAgICAgICAgICAgICAgICAgIGlkID0gZmllbGQuaWQ7XG5cbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZmllbGRzQnlJZFtpZF0pXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiZHVwbGljYXRlIGlkIFwiICsgaWQgKyBcIiBpbiBcIiArIHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fZmllbGRzQnlJZFtpZF0gPSBmaWVsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9maWVsZHNCeUlkO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpZWxkcyBvZiB0aGlzIG1lc3NhZ2UgYXMgYW4gYXJyYXkgZm9yIGl0ZXJhdGlvbi5cbiAgICAgKiBAbmFtZSBUeXBlI2ZpZWxkc0FycmF5XG4gICAgICogQHR5cGUge0ZpZWxkW119XG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgZmllbGRzQXJyYXk6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9maWVsZHNBcnJheSB8fCAodGhpcy5fZmllbGRzQXJyYXkgPSB1dGlsLnRvQXJyYXkodGhpcy5maWVsZHMpKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPbmVvZnMgb2YgdGhpcyBtZXNzYWdlIGFzIGFuIGFycmF5IGZvciBpdGVyYXRpb24uXG4gICAgICogQG5hbWUgVHlwZSNvbmVvZnNBcnJheVxuICAgICAqIEB0eXBlIHtPbmVPZltdfVxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIG9uZW9mc0FycmF5OiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb25lb2ZzQXJyYXkgfHwgKHRoaXMuX29uZW9mc0FycmF5ID0gdXRpbC50b0FycmF5KHRoaXMub25lb2ZzKSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHJlZ2lzdGVyZWQgY29uc3RydWN0b3IsIGlmIGFueSByZWdpc3RlcmVkLCBvdGhlcndpc2UgYSBnZW5lcmljIGNvbnN0cnVjdG9yLlxuICAgICAqIEFzc2lnbmluZyBhIGZ1bmN0aW9uIHJlcGxhY2VzIHRoZSBpbnRlcm5hbCBjb25zdHJ1Y3Rvci4gSWYgdGhlIGZ1bmN0aW9uIGRvZXMgbm90IGV4dGVuZCB7QGxpbmsgTWVzc2FnZX0geWV0LCBpdHMgcHJvdG90eXBlIHdpbGwgYmUgc2V0dXAgYWNjb3JkaW5nbHkgYW5kIHN0YXRpYyBtZXRob2RzIHdpbGwgYmUgcG9wdWxhdGVkLiBJZiBpdCBhbHJlYWR5IGV4dGVuZHMge0BsaW5rIE1lc3NhZ2V9LCBpdCB3aWxsIGp1c3QgcmVwbGFjZSB0aGUgaW50ZXJuYWwgY29uc3RydWN0b3IuXG4gICAgICogQG5hbWUgVHlwZSNjdG9yXG4gICAgICogQHR5cGUge0NvbnN0cnVjdG9yPHt9Pn1cbiAgICAgKi9cbiAgICBjdG9yOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY3RvciB8fCAodGhpcy5jdG9yID0gVHlwZS5nZW5lcmF0ZUNvbnN0cnVjdG9yKHRoaXMpKCkpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKGN0b3IpIHtcblxuICAgICAgICAgICAgLy8gRW5zdXJlIHByb3BlciBwcm90b3R5cGVcbiAgICAgICAgICAgIHZhciBwcm90b3R5cGUgPSBjdG9yLnByb3RvdHlwZTtcbiAgICAgICAgICAgIGlmICghKHByb3RvdHlwZSBpbnN0YW5jZW9mIE1lc3NhZ2UpKSB7XG4gICAgICAgICAgICAgICAgKGN0b3IucHJvdG90eXBlID0gbmV3IE1lc3NhZ2UoKSkuY29uc3RydWN0b3IgPSBjdG9yO1xuICAgICAgICAgICAgICAgIHV0aWwubWVyZ2UoY3Rvci5wcm90b3R5cGUsIHByb3RvdHlwZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENsYXNzZXMgYW5kIG1lc3NhZ2VzIHJlZmVyZW5jZSB0aGVpciByZWZsZWN0ZWQgdHlwZVxuICAgICAgICAgICAgY3Rvci4kdHlwZSA9IGN0b3IucHJvdG90eXBlLiR0eXBlID0gdGhpcztcblxuICAgICAgICAgICAgLy8gTWl4IGluIHN0YXRpYyBtZXRob2RzXG4gICAgICAgICAgICB1dGlsLm1lcmdlKGN0b3IsIE1lc3NhZ2UsIHRydWUpO1xuXG4gICAgICAgICAgICB0aGlzLl9jdG9yID0gY3RvcjtcblxuICAgICAgICAgICAgLy8gTWVzc2FnZXMgaGF2ZSBub24tZW51bWVyYWJsZSBkZWZhdWx0IHZhbHVlcyBvbiB0aGVpciBwcm90b3R5cGVcbiAgICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICAgIGZvciAoOyBpIDwgLyogaW5pdGlhbGl6ZXMgKi8gdGhpcy5maWVsZHNBcnJheS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICB0aGlzLl9maWVsZHNBcnJheVtpXS5yZXNvbHZlKCk7IC8vIGVuc3VyZXMgYSBwcm9wZXIgdmFsdWVcblxuICAgICAgICAgICAgLy8gTWVzc2FnZXMgaGF2ZSBub24tZW51bWVyYWJsZSBnZXR0ZXJzIGFuZCBzZXR0ZXJzIGZvciBlYWNoIHZpcnR1YWwgb25lb2YgZmllbGRcbiAgICAgICAgICAgIHZhciBjdG9yUHJvcGVydGllcyA9IHt9O1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IC8qIGluaXRpYWxpemVzICovIHRoaXMub25lb2ZzQXJyYXkubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgY3RvclByb3BlcnRpZXNbdGhpcy5fb25lb2ZzQXJyYXlbaV0ucmVzb2x2ZSgpLm5hbWVdID0ge1xuICAgICAgICAgICAgICAgICAgICBnZXQ6IHV0aWwub25lT2ZHZXR0ZXIodGhpcy5fb25lb2ZzQXJyYXlbaV0ub25lb2YpLFxuICAgICAgICAgICAgICAgICAgICBzZXQ6IHV0aWwub25lT2ZTZXR0ZXIodGhpcy5fb25lb2ZzQXJyYXlbaV0ub25lb2YpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChpKVxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGN0b3IucHJvdG90eXBlLCBjdG9yUHJvcGVydGllcyk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBjb25zdHJ1Y3RvciBmdW5jdGlvbiBmb3IgdGhlIHNwZWNpZmllZCB0eXBlLlxuICogQHBhcmFtIHtUeXBlfSBtdHlwZSBNZXNzYWdlIHR5cGVcbiAqIEByZXR1cm5zIHtDb2RlZ2VufSBDb2RlZ2VuIGluc3RhbmNlXG4gKi9cblR5cGUuZ2VuZXJhdGVDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIGdlbmVyYXRlQ29uc3RydWN0b3IobXR5cGUpIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bmV4cGVjdGVkLW11bHRpbGluZSAqL1xuICAgIHZhciBnZW4gPSB1dGlsLmNvZGVnZW4oW1wicFwiXSwgbXR5cGUubmFtZSk7XG4gICAgLy8gZXhwbGljaXRseSBpbml0aWFsaXplIG11dGFibGUgb2JqZWN0L2FycmF5IGZpZWxkcyBzbyB0aGF0IHRoZXNlIGFyZW4ndCBqdXN0IGluaGVyaXRlZCBmcm9tIHRoZSBwcm90b3R5cGVcbiAgICBmb3IgKHZhciBpID0gMCwgZmllbGQ7IGkgPCBtdHlwZS5maWVsZHNBcnJheS5sZW5ndGg7ICsraSlcbiAgICAgICAgaWYgKChmaWVsZCA9IG10eXBlLl9maWVsZHNBcnJheVtpXSkubWFwKSBnZW5cbiAgICAgICAgICAgIChcInRoaXMlcz17fVwiLCB1dGlsLnNhZmVQcm9wKGZpZWxkLm5hbWUpKTtcbiAgICAgICAgZWxzZSBpZiAoZmllbGQucmVwZWF0ZWQpIGdlblxuICAgICAgICAgICAgKFwidGhpcyVzPVtdXCIsIHV0aWwuc2FmZVByb3AoZmllbGQubmFtZSkpO1xuICAgIHJldHVybiBnZW5cbiAgICAoXCJpZihwKWZvcih2YXIga3M9T2JqZWN0LmtleXMocCksaT0wO2k8a3MubGVuZ3RoOysraSlpZihwW2tzW2ldXSE9bnVsbClcIikgLy8gb21pdCB1bmRlZmluZWQgb3IgbnVsbFxuICAgICAgICAoXCJ0aGlzW2tzW2ldXT1wW2tzW2ldXVwiKTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVuZXhwZWN0ZWQtbXVsdGlsaW5lICovXG59O1xuXG5mdW5jdGlvbiBjbGVhckNhY2hlKHR5cGUpIHtcbiAgICB0eXBlLl9maWVsZHNCeUlkID0gdHlwZS5fZmllbGRzQXJyYXkgPSB0eXBlLl9vbmVvZnNBcnJheSA9IG51bGw7XG4gICAgZGVsZXRlIHR5cGUuZW5jb2RlO1xuICAgIGRlbGV0ZSB0eXBlLmRlY29kZTtcbiAgICBkZWxldGUgdHlwZS52ZXJpZnk7XG4gICAgcmV0dXJuIHR5cGU7XG59XG5cbi8qKlxuICogTWVzc2FnZSB0eXBlIGRlc2NyaXB0b3IuXG4gKiBAaW50ZXJmYWNlIElUeXBlXG4gKiBAZXh0ZW5kcyBJTmFtZXNwYWNlXG4gKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLElPbmVPZj59IFtvbmVvZnNdIE9uZW9mIGRlc2NyaXB0b3JzXG4gKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLElGaWVsZD59IGZpZWxkcyBGaWVsZCBkZXNjcmlwdG9yc1xuICogQHByb3BlcnR5IHtudW1iZXJbXVtdfSBbZXh0ZW5zaW9uc10gRXh0ZW5zaW9uIHJhbmdlc1xuICogQHByb3BlcnR5IHtudW1iZXJbXVtdfSBbcmVzZXJ2ZWRdIFJlc2VydmVkIHJhbmdlc1xuICogQHByb3BlcnR5IHtib29sZWFufSBbZ3JvdXA9ZmFsc2VdIFdoZXRoZXIgYSBsZWdhY3kgZ3JvdXAgb3Igbm90XG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWVzc2FnZSB0eXBlIGZyb20gYSBtZXNzYWdlIHR5cGUgZGVzY3JpcHRvci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE1lc3NhZ2UgbmFtZVxuICogQHBhcmFtIHtJVHlwZX0ganNvbiBNZXNzYWdlIHR5cGUgZGVzY3JpcHRvclxuICogQHJldHVybnMge1R5cGV9IENyZWF0ZWQgbWVzc2FnZSB0eXBlXG4gKi9cblR5cGUuZnJvbUpTT04gPSBmdW5jdGlvbiBmcm9tSlNPTihuYW1lLCBqc29uKSB7XG4gICAgdmFyIHR5cGUgPSBuZXcgVHlwZShuYW1lLCBqc29uLm9wdGlvbnMpO1xuICAgIHR5cGUuZXh0ZW5zaW9ucyA9IGpzb24uZXh0ZW5zaW9ucztcbiAgICB0eXBlLnJlc2VydmVkID0ganNvbi5yZXNlcnZlZDtcbiAgICB2YXIgbmFtZXMgPSBPYmplY3Qua2V5cyhqc29uLmZpZWxkcyksXG4gICAgICAgIGkgPSAwO1xuICAgIGZvciAoOyBpIDwgbmFtZXMubGVuZ3RoOyArK2kpXG4gICAgICAgIHR5cGUuYWRkKFxuICAgICAgICAgICAgKCB0eXBlb2YganNvbi5maWVsZHNbbmFtZXNbaV1dLmtleVR5cGUgIT09IFwidW5kZWZpbmVkXCJcbiAgICAgICAgICAgID8gTWFwRmllbGQuZnJvbUpTT05cbiAgICAgICAgICAgIDogRmllbGQuZnJvbUpTT04gKShuYW1lc1tpXSwganNvbi5maWVsZHNbbmFtZXNbaV1dKVxuICAgICAgICApO1xuICAgIGlmIChqc29uLm9uZW9mcylcbiAgICAgICAgZm9yIChuYW1lcyA9IE9iamVjdC5rZXlzKGpzb24ub25lb2ZzKSwgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIHR5cGUuYWRkKE9uZU9mLmZyb21KU09OKG5hbWVzW2ldLCBqc29uLm9uZW9mc1tuYW1lc1tpXV0pKTtcbiAgICBpZiAoanNvbi5uZXN0ZWQpXG4gICAgICAgIGZvciAobmFtZXMgPSBPYmplY3Qua2V5cyhqc29uLm5lc3RlZCksIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBuZXN0ZWQgPSBqc29uLm5lc3RlZFtuYW1lc1tpXV07XG4gICAgICAgICAgICB0eXBlLmFkZCggLy8gbW9zdCB0byBsZWFzdCBsaWtlbHlcbiAgICAgICAgICAgICAgICAoIG5lc3RlZC5pZCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBGaWVsZC5mcm9tSlNPTlxuICAgICAgICAgICAgICAgIDogbmVzdGVkLmZpZWxkcyAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBUeXBlLmZyb21KU09OXG4gICAgICAgICAgICAgICAgOiBuZXN0ZWQudmFsdWVzICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IEVudW0uZnJvbUpTT05cbiAgICAgICAgICAgICAgICA6IG5lc3RlZC5tZXRob2RzICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IFNlcnZpY2UuZnJvbUpTT05cbiAgICAgICAgICAgICAgICA6IE5hbWVzcGFjZS5mcm9tSlNPTiApKG5hbWVzW2ldLCBuZXN0ZWQpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgaWYgKGpzb24uZXh0ZW5zaW9ucyAmJiBqc29uLmV4dGVuc2lvbnMubGVuZ3RoKVxuICAgICAgICB0eXBlLmV4dGVuc2lvbnMgPSBqc29uLmV4dGVuc2lvbnM7XG4gICAgaWYgKGpzb24ucmVzZXJ2ZWQgJiYganNvbi5yZXNlcnZlZC5sZW5ndGgpXG4gICAgICAgIHR5cGUucmVzZXJ2ZWQgPSBqc29uLnJlc2VydmVkO1xuICAgIGlmIChqc29uLmdyb3VwKVxuICAgICAgICB0eXBlLmdyb3VwID0gdHJ1ZTtcbiAgICBpZiAoanNvbi5jb21tZW50KVxuICAgICAgICB0eXBlLmNvbW1lbnQgPSBqc29uLmNvbW1lbnQ7XG4gICAgcmV0dXJuIHR5cGU7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgbWVzc2FnZSB0eXBlIHRvIGEgbWVzc2FnZSB0eXBlIGRlc2NyaXB0b3IuXG4gKiBAcGFyYW0ge0lUb0pTT05PcHRpb25zfSBbdG9KU09OT3B0aW9uc10gSlNPTiBjb252ZXJzaW9uIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtJVHlwZX0gTWVzc2FnZSB0eXBlIGRlc2NyaXB0b3JcbiAqL1xuVHlwZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKHRvSlNPTk9wdGlvbnMpIHtcbiAgICB2YXIgaW5oZXJpdGVkID0gTmFtZXNwYWNlLnByb3RvdHlwZS50b0pTT04uY2FsbCh0aGlzLCB0b0pTT05PcHRpb25zKTtcbiAgICB2YXIga2VlcENvbW1lbnRzID0gdG9KU09OT3B0aW9ucyA/IEJvb2xlYW4odG9KU09OT3B0aW9ucy5rZWVwQ29tbWVudHMpIDogZmFsc2U7XG4gICAgcmV0dXJuIHV0aWwudG9PYmplY3QoW1xuICAgICAgICBcIm9wdGlvbnNcIiAgICAsIGluaGVyaXRlZCAmJiBpbmhlcml0ZWQub3B0aW9ucyB8fCB1bmRlZmluZWQsXG4gICAgICAgIFwib25lb2ZzXCIgICAgICwgTmFtZXNwYWNlLmFycmF5VG9KU09OKHRoaXMub25lb2ZzQXJyYXksIHRvSlNPTk9wdGlvbnMpLFxuICAgICAgICBcImZpZWxkc1wiICAgICAsIE5hbWVzcGFjZS5hcnJheVRvSlNPTih0aGlzLmZpZWxkc0FycmF5LmZpbHRlcihmdW5jdGlvbihvYmopIHsgcmV0dXJuICFvYmouZGVjbGFyaW5nRmllbGQ7IH0pLCB0b0pTT05PcHRpb25zKSB8fCB7fSxcbiAgICAgICAgXCJleHRlbnNpb25zXCIgLCB0aGlzLmV4dGVuc2lvbnMgJiYgdGhpcy5leHRlbnNpb25zLmxlbmd0aCA/IHRoaXMuZXh0ZW5zaW9ucyA6IHVuZGVmaW5lZCxcbiAgICAgICAgXCJyZXNlcnZlZFwiICAgLCB0aGlzLnJlc2VydmVkICYmIHRoaXMucmVzZXJ2ZWQubGVuZ3RoID8gdGhpcy5yZXNlcnZlZCA6IHVuZGVmaW5lZCxcbiAgICAgICAgXCJncm91cFwiICAgICAgLCB0aGlzLmdyb3VwIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgXCJuZXN0ZWRcIiAgICAgLCBpbmhlcml0ZWQgJiYgaW5oZXJpdGVkLm5lc3RlZCB8fCB1bmRlZmluZWQsXG4gICAgICAgIFwiY29tbWVudFwiICAgICwga2VlcENvbW1lbnRzID8gdGhpcy5jb21tZW50IDogdW5kZWZpbmVkXG4gICAgXSk7XG59O1xuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5UeXBlLnByb3RvdHlwZS5yZXNvbHZlQWxsID0gZnVuY3Rpb24gcmVzb2x2ZUFsbCgpIHtcbiAgICB2YXIgZmllbGRzID0gdGhpcy5maWVsZHNBcnJheSwgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBmaWVsZHMubGVuZ3RoKVxuICAgICAgICBmaWVsZHNbaSsrXS5yZXNvbHZlKCk7XG4gICAgdmFyIG9uZW9mcyA9IHRoaXMub25lb2ZzQXJyYXk7IGkgPSAwO1xuICAgIHdoaWxlIChpIDwgb25lb2ZzLmxlbmd0aClcbiAgICAgICAgb25lb2ZzW2krK10ucmVzb2x2ZSgpO1xuICAgIHJldHVybiBOYW1lc3BhY2UucHJvdG90eXBlLnJlc29sdmVBbGwuY2FsbCh0aGlzKTtcbn07XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cblR5cGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldChuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuZmllbGRzW25hbWVdXG4gICAgICAgIHx8IHRoaXMub25lb2ZzICYmIHRoaXMub25lb2ZzW25hbWVdXG4gICAgICAgIHx8IHRoaXMubmVzdGVkICYmIHRoaXMubmVzdGVkW25hbWVdXG4gICAgICAgIHx8IG51bGw7XG59O1xuXG4vKipcbiAqIEFkZHMgYSBuZXN0ZWQgb2JqZWN0IHRvIHRoaXMgdHlwZS5cbiAqIEBwYXJhbSB7UmVmbGVjdGlvbk9iamVjdH0gb2JqZWN0IE5lc3RlZCBvYmplY3QgdG8gYWRkXG4gKiBAcmV0dXJucyB7VHlwZX0gYHRoaXNgXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGFyZ3VtZW50cyBhcmUgaW52YWxpZFxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZXJlIGlzIGFscmVhZHkgYSBuZXN0ZWQgb2JqZWN0IHdpdGggdGhpcyBuYW1lIG9yLCBpZiBhIGZpZWxkLCB3aGVuIHRoZXJlIGlzIGFscmVhZHkgYSBmaWVsZCB3aXRoIHRoaXMgaWRcbiAqL1xuVHlwZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKG9iamVjdCkge1xuXG4gICAgaWYgKHRoaXMuZ2V0KG9iamVjdC5uYW1lKSlcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJkdXBsaWNhdGUgbmFtZSAnXCIgKyBvYmplY3QubmFtZSArIFwiJyBpbiBcIiArIHRoaXMpO1xuXG4gICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIEZpZWxkICYmIG9iamVjdC5leHRlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBOT1RFOiBFeHRlbnNpb24gZmllbGRzIGFyZW4ndCBhY3R1YWwgZmllbGRzIG9uIHRoZSBkZWNsYXJpbmcgdHlwZSwgYnV0IG5lc3RlZCBvYmplY3RzLlxuICAgICAgICAvLyBUaGUgcm9vdCBvYmplY3QgdGFrZXMgY2FyZSBvZiBhZGRpbmcgZGlzdGluY3Qgc2lzdGVyLWZpZWxkcyB0byB0aGUgcmVzcGVjdGl2ZSBleHRlbmRlZFxuICAgICAgICAvLyB0eXBlIGluc3RlYWQuXG5cbiAgICAgICAgLy8gYXZvaWRzIGNhbGxpbmcgdGhlIGdldHRlciBpZiBub3QgYWJzb2x1dGVseSBuZWNlc3NhcnkgYmVjYXVzZSBpdCdzIGNhbGxlZCBxdWl0ZSBmcmVxdWVudGx5XG4gICAgICAgIGlmICh0aGlzLl9maWVsZHNCeUlkID8gLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gdGhpcy5fZmllbGRzQnlJZFtvYmplY3QuaWRdIDogdGhpcy5maWVsZHNCeUlkW29iamVjdC5pZF0pXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcImR1cGxpY2F0ZSBpZCBcIiArIG9iamVjdC5pZCArIFwiIGluIFwiICsgdGhpcyk7XG4gICAgICAgIGlmICh0aGlzLmlzUmVzZXJ2ZWRJZChvYmplY3QuaWQpKVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpZCBcIiArIG9iamVjdC5pZCArIFwiIGlzIHJlc2VydmVkIGluIFwiICsgdGhpcyk7XG4gICAgICAgIGlmICh0aGlzLmlzUmVzZXJ2ZWROYW1lKG9iamVjdC5uYW1lKSlcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwibmFtZSAnXCIgKyBvYmplY3QubmFtZSArIFwiJyBpcyByZXNlcnZlZCBpbiBcIiArIHRoaXMpO1xuXG4gICAgICAgIGlmIChvYmplY3QucGFyZW50KVxuICAgICAgICAgICAgb2JqZWN0LnBhcmVudC5yZW1vdmUob2JqZWN0KTtcbiAgICAgICAgdGhpcy5maWVsZHNbb2JqZWN0Lm5hbWVdID0gb2JqZWN0O1xuICAgICAgICBvYmplY3QubWVzc2FnZSA9IHRoaXM7XG4gICAgICAgIG9iamVjdC5vbkFkZCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIGNsZWFyQ2FjaGUodGhpcyk7XG4gICAgfVxuICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBPbmVPZikge1xuICAgICAgICBpZiAoIXRoaXMub25lb2ZzKVxuICAgICAgICAgICAgdGhpcy5vbmVvZnMgPSB7fTtcbiAgICAgICAgdGhpcy5vbmVvZnNbb2JqZWN0Lm5hbWVdID0gb2JqZWN0O1xuICAgICAgICBvYmplY3Qub25BZGQodGhpcyk7XG4gICAgICAgIHJldHVybiBjbGVhckNhY2hlKHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gTmFtZXNwYWNlLnByb3RvdHlwZS5hZGQuY2FsbCh0aGlzLCBvYmplY3QpO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGEgbmVzdGVkIG9iamVjdCBmcm9tIHRoaXMgdHlwZS5cbiAqIEBwYXJhbSB7UmVmbGVjdGlvbk9iamVjdH0gb2JqZWN0IE5lc3RlZCBvYmplY3QgdG8gcmVtb3ZlXG4gKiBAcmV0dXJucyB7VHlwZX0gYHRoaXNgXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGFyZ3VtZW50cyBhcmUgaW52YWxpZFxuICogQHRocm93cyB7RXJyb3J9IElmIGBvYmplY3RgIGlzIG5vdCBhIG1lbWJlciBvZiB0aGlzIHR5cGVcbiAqL1xuVHlwZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBGaWVsZCAmJiBvYmplY3QuZXh0ZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gU2VlIFR5cGUjYWRkIGZvciB0aGUgcmVhc29uIHdoeSBleHRlbnNpb24gZmllbGRzIGFyZSBleGNsdWRlZCBoZXJlLlxuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIXRoaXMuZmllbGRzIHx8IHRoaXMuZmllbGRzW29iamVjdC5uYW1lXSAhPT0gb2JqZWN0KVxuICAgICAgICAgICAgdGhyb3cgRXJyb3Iob2JqZWN0ICsgXCIgaXMgbm90IGEgbWVtYmVyIG9mIFwiICsgdGhpcyk7XG5cbiAgICAgICAgZGVsZXRlIHRoaXMuZmllbGRzW29iamVjdC5uYW1lXTtcbiAgICAgICAgb2JqZWN0LnBhcmVudCA9IG51bGw7XG4gICAgICAgIG9iamVjdC5vblJlbW92ZSh0aGlzKTtcbiAgICAgICAgcmV0dXJuIGNsZWFyQ2FjaGUodGhpcyk7XG4gICAgfVxuICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBPbmVPZikge1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIXRoaXMub25lb2ZzIHx8IHRoaXMub25lb2ZzW29iamVjdC5uYW1lXSAhPT0gb2JqZWN0KVxuICAgICAgICAgICAgdGhyb3cgRXJyb3Iob2JqZWN0ICsgXCIgaXMgbm90IGEgbWVtYmVyIG9mIFwiICsgdGhpcyk7XG5cbiAgICAgICAgZGVsZXRlIHRoaXMub25lb2ZzW29iamVjdC5uYW1lXTtcbiAgICAgICAgb2JqZWN0LnBhcmVudCA9IG51bGw7XG4gICAgICAgIG9iamVjdC5vblJlbW92ZSh0aGlzKTtcbiAgICAgICAgcmV0dXJuIGNsZWFyQ2FjaGUodGhpcyk7XG4gICAgfVxuICAgIHJldHVybiBOYW1lc3BhY2UucHJvdG90eXBlLnJlbW92ZS5jYWxsKHRoaXMsIG9iamVjdCk7XG59O1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoZSBzcGVjaWZpZWQgaWQgaXMgcmVzZXJ2ZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gaWQgSWQgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiByZXNlcnZlZCwgb3RoZXJ3aXNlIGBmYWxzZWBcbiAqL1xuVHlwZS5wcm90b3R5cGUuaXNSZXNlcnZlZElkID0gZnVuY3Rpb24gaXNSZXNlcnZlZElkKGlkKSB7XG4gICAgcmV0dXJuIE5hbWVzcGFjZS5pc1Jlc2VydmVkSWQodGhpcy5yZXNlcnZlZCwgaWQpO1xufTtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIG5hbWUgaXMgcmVzZXJ2ZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgcmVzZXJ2ZWQsIG90aGVyd2lzZSBgZmFsc2VgXG4gKi9cblR5cGUucHJvdG90eXBlLmlzUmVzZXJ2ZWROYW1lID0gZnVuY3Rpb24gaXNSZXNlcnZlZE5hbWUobmFtZSkge1xuICAgIHJldHVybiBOYW1lc3BhY2UuaXNSZXNlcnZlZE5hbWUodGhpcy5yZXNlcnZlZCwgbmFtZSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbWVzc2FnZSBvZiB0aGlzIHR5cGUgdXNpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gKiBAcmV0dXJucyB7TWVzc2FnZTx7fT59IE1lc3NhZ2UgaW5zdGFuY2VcbiAqL1xuVHlwZS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMuY3Rvcihwcm9wZXJ0aWVzKTtcbn07XG5cbi8qKlxuICogU2V0cyB1cCB7QGxpbmsgVHlwZSNlbmNvZGV8ZW5jb2RlfSwge0BsaW5rIFR5cGUjZGVjb2RlfGRlY29kZX0gYW5kIHtAbGluayBUeXBlI3ZlcmlmeXx2ZXJpZnl9LlxuICogQHJldHVybnMge1R5cGV9IGB0aGlzYFxuICovXG5UeXBlLnByb3RvdHlwZS5zZXR1cCA9IGZ1bmN0aW9uIHNldHVwKCkge1xuICAgIC8vIFNldHMgdXAgZXZlcnl0aGluZyBhdCBvbmNlIHNvIHRoYXQgdGhlIHByb3RvdHlwZSBjaGFpbiBkb2VzIG5vdCBoYXZlIHRvIGJlIHJlLWV2YWx1YXRlZFxuICAgIC8vIG11bHRpcGxlIHRpbWVzIChWOCwgc29mdC1kZW9wdCBwcm90b3R5cGUtY2hlY2spLlxuXG4gICAgdmFyIGZ1bGxOYW1lID0gdGhpcy5mdWxsTmFtZSxcbiAgICAgICAgdHlwZXMgICAgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IC8qIGluaXRpYWxpemVzICovIHRoaXMuZmllbGRzQXJyYXkubGVuZ3RoOyArK2kpXG4gICAgICAgIHR5cGVzLnB1c2godGhpcy5fZmllbGRzQXJyYXlbaV0ucmVzb2x2ZSgpLnJlc29sdmVkVHlwZSk7XG5cbiAgICAvLyBSZXBsYWNlIHNldHVwIG1ldGhvZHMgd2l0aCB0eXBlLXNwZWNpZmljIGdlbmVyYXRlZCBmdW5jdGlvbnNcbiAgICB0aGlzLmVuY29kZSA9IGVuY29kZXIodGhpcykoe1xuICAgICAgICBXcml0ZXIgOiBXcml0ZXIsXG4gICAgICAgIHR5cGVzICA6IHR5cGVzLFxuICAgICAgICB1dGlsICAgOiB1dGlsXG4gICAgfSk7XG4gICAgdGhpcy5kZWNvZGUgPSBkZWNvZGVyKHRoaXMpKHtcbiAgICAgICAgUmVhZGVyIDogUmVhZGVyLFxuICAgICAgICB0eXBlcyAgOiB0eXBlcyxcbiAgICAgICAgdXRpbCAgIDogdXRpbFxuICAgIH0pO1xuICAgIHRoaXMudmVyaWZ5ID0gdmVyaWZpZXIodGhpcykoe1xuICAgICAgICB0eXBlcyA6IHR5cGVzLFxuICAgICAgICB1dGlsICA6IHV0aWxcbiAgICB9KTtcbiAgICB0aGlzLmZyb21PYmplY3QgPSBjb252ZXJ0ZXIuZnJvbU9iamVjdCh0aGlzKSh7XG4gICAgICAgIHR5cGVzIDogdHlwZXMsXG4gICAgICAgIHV0aWwgIDogdXRpbFxuICAgIH0pO1xuICAgIHRoaXMudG9PYmplY3QgPSBjb252ZXJ0ZXIudG9PYmplY3QodGhpcykoe1xuICAgICAgICB0eXBlcyA6IHR5cGVzLFxuICAgICAgICB1dGlsICA6IHV0aWxcbiAgICB9KTtcblxuICAgIC8vIEluamVjdCBjdXN0b20gd3JhcHBlcnMgZm9yIGNvbW1vbiB0eXBlc1xuICAgIHZhciB3cmFwcGVyID0gd3JhcHBlcnNbZnVsbE5hbWVdO1xuICAgIGlmICh3cmFwcGVyKSB7XG4gICAgICAgIHZhciBvcmlnaW5hbFRoaXMgPSBPYmplY3QuY3JlYXRlKHRoaXMpO1xuICAgICAgICAvLyBpZiAod3JhcHBlci5mcm9tT2JqZWN0KSB7XG4gICAgICAgICAgICBvcmlnaW5hbFRoaXMuZnJvbU9iamVjdCA9IHRoaXMuZnJvbU9iamVjdDtcbiAgICAgICAgICAgIHRoaXMuZnJvbU9iamVjdCA9IHdyYXBwZXIuZnJvbU9iamVjdC5iaW5kKG9yaWdpbmFsVGhpcyk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gaWYgKHdyYXBwZXIudG9PYmplY3QpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsVGhpcy50b09iamVjdCA9IHRoaXMudG9PYmplY3Q7XG4gICAgICAgICAgICB0aGlzLnRvT2JqZWN0ID0gd3JhcHBlci50b09iamVjdC5iaW5kKG9yaWdpbmFsVGhpcyk7XG4gICAgICAgIC8vIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRW5jb2RlcyBhIG1lc3NhZ2Ugb2YgdGhpcyB0eXBlLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBUeXBlI3ZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICogQHBhcmFtIHtNZXNzYWdlPHt9PnxPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBNZXNzYWdlIGluc3RhbmNlIG9yIHBsYWluIG9iamVjdFxuICogQHBhcmFtIHtXcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAqIEByZXR1cm5zIHtXcml0ZXJ9IHdyaXRlclxuICovXG5UeXBlLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGVfc2V0dXAobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0dXAoKS5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKTsgLy8gb3ZlcnJpZGVzIHRoaXMgbWV0aG9kXG59O1xuXG4vKipcbiAqIEVuY29kZXMgYSBtZXNzYWdlIG9mIHRoaXMgdHlwZSBwcmVjZWVkZWQgYnkgaXRzIGJ5dGUgbGVuZ3RoIGFzIGEgdmFyaW50LiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBUeXBlI3ZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICogQHBhcmFtIHtNZXNzYWdlPHt9PnxPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBNZXNzYWdlIGluc3RhbmNlIG9yIHBsYWluIG9iamVjdFxuICogQHBhcmFtIHtXcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAqIEByZXR1cm5zIHtXcml0ZXJ9IHdyaXRlclxuICovXG5UeXBlLnByb3RvdHlwZS5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciAmJiB3cml0ZXIubGVuID8gd3JpdGVyLmZvcmsoKSA6IHdyaXRlcikubGRlbGltKCk7XG59O1xuXG4vKipcbiAqIERlY29kZXMgYSBtZXNzYWdlIG9mIHRoaXMgdHlwZS5cbiAqIEBwYXJhbSB7UmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTGVuZ3RoIG9mIHRoZSBtZXNzYWdlLCBpZiBrbm93biBiZWZvcmVoYW5kXG4gKiBAcmV0dXJucyB7TWVzc2FnZTx7fT59IERlY29kZWQgbWVzc2FnZVxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAqIEB0aHJvd3Mge3V0aWwuUHJvdG9jb2xFcnJvcjx7fT59IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICovXG5UeXBlLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGVfc2V0dXAocmVhZGVyLCBsZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcy5zZXR1cCgpLmRlY29kZShyZWFkZXIsIGxlbmd0aCk7IC8vIG92ZXJyaWRlcyB0aGlzIG1ldGhvZFxufTtcblxuLyoqXG4gKiBEZWNvZGVzIGEgbWVzc2FnZSBvZiB0aGlzIHR5cGUgcHJlY2VlZGVkIGJ5IGl0cyBieXRlIGxlbmd0aCBhcyBhIHZhcmludC5cbiAqIEBwYXJhbSB7UmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gKiBAcmV0dXJucyB7TWVzc2FnZTx7fT59IERlY29kZWQgbWVzc2FnZVxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAqIEB0aHJvd3Mge3V0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gKi9cblR5cGUucHJvdG90eXBlLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiBSZWFkZXIpKVxuICAgICAgICByZWFkZXIgPSBSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbn07XG5cbi8qKlxuICogVmVyaWZpZXMgdGhhdCBmaWVsZCB2YWx1ZXMgYXJlIHZhbGlkIGFuZCB0aGF0IHJlcXVpcmVkIGZpZWxkcyBhcmUgcHJlc2VudC5cbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgUGxhaW4gb2JqZWN0IHRvIHZlcmlmeVxuICogQHJldHVybnMge251bGx8c3RyaW5nfSBgbnVsbGAgaWYgdmFsaWQsIG90aGVyd2lzZSB0aGUgcmVhc29uIHdoeSBpdCBpcyBub3RcbiAqL1xuVHlwZS5wcm90b3R5cGUudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5X3NldHVwKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5zZXR1cCgpLnZlcmlmeShtZXNzYWdlKTsgLy8gb3ZlcnJpZGVzIHRoaXMgbWV0aG9kXG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbWVzc2FnZSBvZiB0aGlzIHR5cGUgZnJvbSBhIHBsYWluIG9iamVjdC4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gdGhlaXIgcmVzcGVjdGl2ZSBpbnRlcm5hbCB0eXBlcy5cbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9iamVjdCBQbGFpbiBvYmplY3QgdG8gY29udmVydFxuICogQHJldHVybnMge01lc3NhZ2U8e30+fSBNZXNzYWdlIGluc3RhbmNlXG4gKi9cblR5cGUucHJvdG90eXBlLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgIHJldHVybiB0aGlzLnNldHVwKCkuZnJvbU9iamVjdChvYmplY3QpO1xufTtcblxuLyoqXG4gKiBDb252ZXJzaW9uIG9wdGlvbnMgYXMgdXNlZCBieSB7QGxpbmsgVHlwZSN0b09iamVjdH0gYW5kIHtAbGluayBNZXNzYWdlLnRvT2JqZWN0fS5cbiAqIEBpbnRlcmZhY2UgSUNvbnZlcnNpb25PcHRpb25zXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbbG9uZ3NdIExvbmcgY29udmVyc2lvbiB0eXBlLlxuICogVmFsaWQgdmFsdWVzIGFyZSBgU3RyaW5nYCBhbmQgYE51bWJlcmAgKHRoZSBnbG9iYWwgdHlwZXMpLlxuICogRGVmYXVsdHMgdG8gY29weSB0aGUgcHJlc2VudCB2YWx1ZSwgd2hpY2ggaXMgYSBwb3NzaWJseSB1bnNhZmUgbnVtYmVyIHdpdGhvdXQgYW5kIGEge0BsaW5rIExvbmd9IHdpdGggYSBsb25nIGxpYnJhcnkuXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbZW51bXNdIEVudW0gdmFsdWUgY29udmVyc2lvbiB0eXBlLlxuICogT25seSB2YWxpZCB2YWx1ZSBpcyBgU3RyaW5nYCAodGhlIGdsb2JhbCB0eXBlKS5cbiAqIERlZmF1bHRzIHRvIGNvcHkgdGhlIHByZXNlbnQgdmFsdWUsIHdoaWNoIGlzIHRoZSBudW1lcmljIGlkLlxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW2J5dGVzXSBCeXRlcyB2YWx1ZSBjb252ZXJzaW9uIHR5cGUuXG4gKiBWYWxpZCB2YWx1ZXMgYXJlIGBBcnJheWAgYW5kIChhIGJhc2U2NCBlbmNvZGVkKSBgU3RyaW5nYCAodGhlIGdsb2JhbCB0eXBlcykuXG4gKiBEZWZhdWx0cyB0byBjb3B5IHRoZSBwcmVzZW50IHZhbHVlLCB3aGljaCB1c3VhbGx5IGlzIGEgQnVmZmVyIHVuZGVyIG5vZGUgYW5kIGFuIFVpbnQ4QXJyYXkgaW4gdGhlIGJyb3dzZXIuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtkZWZhdWx0cz1mYWxzZV0gQWxzbyBzZXRzIGRlZmF1bHQgdmFsdWVzIG9uIHRoZSByZXN1bHRpbmcgb2JqZWN0XG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFthcnJheXM9ZmFsc2VdIFNldHMgZW1wdHkgYXJyYXlzIGZvciBtaXNzaW5nIHJlcGVhdGVkIGZpZWxkcyBldmVuIGlmIGBkZWZhdWx0cz1mYWxzZWBcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW29iamVjdHM9ZmFsc2VdIFNldHMgZW1wdHkgb2JqZWN0cyBmb3IgbWlzc2luZyBtYXAgZmllbGRzIGV2ZW4gaWYgYGRlZmF1bHRzPWZhbHNlYFxuICogQHByb3BlcnR5IHtib29sZWFufSBbb25lb2ZzPWZhbHNlXSBJbmNsdWRlcyB2aXJ0dWFsIG9uZW9mIHByb3BlcnRpZXMgc2V0IHRvIHRoZSBwcmVzZW50IGZpZWxkJ3MgbmFtZSwgaWYgYW55XG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtqc29uPWZhbHNlXSBQZXJmb3JtcyBhZGRpdGlvbmFsIEpTT04gY29tcGF0aWJpbGl0eSBjb252ZXJzaW9ucywgaS5lLiBOYU4gYW5kIEluZmluaXR5IHRvIHN0cmluZ3NcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSBwbGFpbiBvYmplY3QgZnJvbSBhIG1lc3NhZ2Ugb2YgdGhpcyB0eXBlLiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byBvdGhlciB0eXBlcyBpZiBzcGVjaWZpZWQuXG4gKiBAcGFyYW0ge01lc3NhZ2U8e30+fSBtZXNzYWdlIE1lc3NhZ2UgaW5zdGFuY2VcbiAqIEBwYXJhbSB7SUNvbnZlcnNpb25PcHRpb25zfSBbb3B0aW9uc10gQ29udmVyc2lvbiBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IFBsYWluIG9iamVjdFxuICovXG5UeXBlLnByb3RvdHlwZS50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5zZXR1cCgpLnRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBEZWNvcmF0b3IgZnVuY3Rpb24gYXMgcmV0dXJuZWQgYnkge0BsaW5rIFR5cGUuZH0gKFR5cGVTY3JpcHQpLlxuICogQHR5cGVkZWYgVHlwZURlY29yYXRvclxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtDb25zdHJ1Y3RvcjxUPn0gdGFyZ2V0IFRhcmdldCBjb25zdHJ1Y3RvclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqIEB0ZW1wbGF0ZSBUIGV4dGVuZHMgTWVzc2FnZTxUPlxuICovXG5cbi8qKlxuICogVHlwZSBkZWNvcmF0b3IgKFR5cGVTY3JpcHQpLlxuICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlTmFtZV0gVHlwZSBuYW1lLCBkZWZhdWx0cyB0byB0aGUgY29uc3RydWN0b3IncyBuYW1lXG4gKiBAcmV0dXJucyB7VHlwZURlY29yYXRvcjxUPn0gRGVjb3JhdG9yIGZ1bmN0aW9uXG4gKiBAdGVtcGxhdGUgVCBleHRlbmRzIE1lc3NhZ2U8VD5cbiAqL1xuVHlwZS5kID0gZnVuY3Rpb24gZGVjb3JhdGVUeXBlKHR5cGVOYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHR5cGVEZWNvcmF0b3IodGFyZ2V0KSB7XG4gICAgICAgIHV0aWwuZGVjb3JhdGVUeXBlKHRhcmdldCwgdHlwZU5hbWUpO1xuICAgIH07XG59O1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJUeXBlIiwiTmFtZXNwYWNlIiwicmVxdWlyZSIsInByb3RvdHlwZSIsIk9iamVjdCIsImNyZWF0ZSIsImNvbnN0cnVjdG9yIiwiY2xhc3NOYW1lIiwiRW51bSIsIk9uZU9mIiwiRmllbGQiLCJNYXBGaWVsZCIsIlNlcnZpY2UiLCJNZXNzYWdlIiwiUmVhZGVyIiwiV3JpdGVyIiwidXRpbCIsImVuY29kZXIiLCJkZWNvZGVyIiwidmVyaWZpZXIiLCJjb252ZXJ0ZXIiLCJ3cmFwcGVycyIsIm5hbWUiLCJvcHRpb25zIiwiY2FsbCIsImZpZWxkcyIsIm9uZW9mcyIsInVuZGVmaW5lZCIsImV4dGVuc2lvbnMiLCJyZXNlcnZlZCIsImdyb3VwIiwiX2ZpZWxkc0J5SWQiLCJfZmllbGRzQXJyYXkiLCJfb25lb2ZzQXJyYXkiLCJfY3RvciIsImRlZmluZVByb3BlcnRpZXMiLCJmaWVsZHNCeUlkIiwiZ2V0IiwibmFtZXMiLCJrZXlzIiwiaSIsImxlbmd0aCIsImZpZWxkIiwiaWQiLCJFcnJvciIsImZpZWxkc0FycmF5IiwidG9BcnJheSIsIm9uZW9mc0FycmF5IiwiY3RvciIsImdlbmVyYXRlQ29uc3RydWN0b3IiLCJzZXQiLCJtZXJnZSIsIiR0eXBlIiwicmVzb2x2ZSIsImN0b3JQcm9wZXJ0aWVzIiwib25lT2ZHZXR0ZXIiLCJvbmVvZiIsIm9uZU9mU2V0dGVyIiwibXR5cGUiLCJnZW4iLCJjb2RlZ2VuIiwibWFwIiwic2FmZVByb3AiLCJyZXBlYXRlZCIsImNsZWFyQ2FjaGUiLCJ0eXBlIiwiZW5jb2RlIiwiZGVjb2RlIiwidmVyaWZ5IiwiZnJvbUpTT04iLCJqc29uIiwiYWRkIiwia2V5VHlwZSIsIm5lc3RlZCIsInZhbHVlcyIsIm1ldGhvZHMiLCJjb21tZW50IiwidG9KU09OIiwidG9KU09OT3B0aW9ucyIsImluaGVyaXRlZCIsImtlZXBDb21tZW50cyIsIkJvb2xlYW4iLCJ0b09iamVjdCIsImFycmF5VG9KU09OIiwiZmlsdGVyIiwib2JqIiwiZGVjbGFyaW5nRmllbGQiLCJyZXNvbHZlQWxsIiwib2JqZWN0IiwiZXh0ZW5kIiwiaXNSZXNlcnZlZElkIiwiaXNSZXNlcnZlZE5hbWUiLCJwYXJlbnQiLCJyZW1vdmUiLCJtZXNzYWdlIiwib25BZGQiLCJvblJlbW92ZSIsInByb3BlcnRpZXMiLCJzZXR1cCIsImZ1bGxOYW1lIiwidHlwZXMiLCJwdXNoIiwicmVzb2x2ZWRUeXBlIiwiZnJvbU9iamVjdCIsIndyYXBwZXIiLCJvcmlnaW5hbFRoaXMiLCJiaW5kIiwiZW5jb2RlX3NldHVwIiwid3JpdGVyIiwiZW5jb2RlRGVsaW1pdGVkIiwibGVuIiwiZm9yayIsImxkZWxpbSIsImRlY29kZV9zZXR1cCIsInJlYWRlciIsImRlY29kZURlbGltaXRlZCIsInVpbnQzMiIsInZlcmlmeV9zZXR1cCIsImQiLCJkZWNvcmF0ZVR5cGUiLCJ0eXBlTmFtZSIsInR5cGVEZWNvcmF0b3IiLCJ0YXJnZXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/protobufjs/src/type.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/src/types.js":
/*!***********************************************!*\
  !*** ../node_modules/protobufjs/src/types.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Common type constants.\n * @namespace\n */ var types = exports;\nvar util = __webpack_require__(/*! ./util */ \"(ssr)/../node_modules/protobufjs/src/util.js\");\nvar s = [\n    \"double\",\n    \"float\",\n    \"int32\",\n    \"uint32\",\n    \"sint32\",\n    \"fixed32\",\n    \"sfixed32\",\n    \"int64\",\n    \"uint64\",\n    \"sint64\",\n    \"fixed64\",\n    \"sfixed64\",\n    \"bool\",\n    \"string\",\n    \"bytes\" // 14\n];\nfunction bake(values, offset) {\n    var i = 0, o = {};\n    offset |= 0;\n    while(i < values.length)o[s[i + offset]] = values[i++];\n    return o;\n}\n/**\n * Basic type wire types.\n * @type {Object.<string,number>}\n * @const\n * @property {number} double=1 Fixed64 wire type\n * @property {number} float=5 Fixed32 wire type\n * @property {number} int32=0 Varint wire type\n * @property {number} uint32=0 Varint wire type\n * @property {number} sint32=0 Varint wire type\n * @property {number} fixed32=5 Fixed32 wire type\n * @property {number} sfixed32=5 Fixed32 wire type\n * @property {number} int64=0 Varint wire type\n * @property {number} uint64=0 Varint wire type\n * @property {number} sint64=0 Varint wire type\n * @property {number} fixed64=1 Fixed64 wire type\n * @property {number} sfixed64=1 Fixed64 wire type\n * @property {number} bool=0 Varint wire type\n * @property {number} string=2 Ldelim wire type\n * @property {number} bytes=2 Ldelim wire type\n */ types.basic = bake([\n    /* double   */ 1,\n    /* float    */ 5,\n    /* int32    */ 0,\n    /* uint32   */ 0,\n    /* sint32   */ 0,\n    /* fixed32  */ 5,\n    /* sfixed32 */ 5,\n    /* int64    */ 0,\n    /* uint64   */ 0,\n    /* sint64   */ 0,\n    /* fixed64  */ 1,\n    /* sfixed64 */ 1,\n    /* bool     */ 0,\n    /* string   */ 2,\n    /* bytes    */ 2\n]);\n/**\n * Basic type defaults.\n * @type {Object.<string,*>}\n * @const\n * @property {number} double=0 Double default\n * @property {number} float=0 Float default\n * @property {number} int32=0 Int32 default\n * @property {number} uint32=0 Uint32 default\n * @property {number} sint32=0 Sint32 default\n * @property {number} fixed32=0 Fixed32 default\n * @property {number} sfixed32=0 Sfixed32 default\n * @property {number} int64=0 Int64 default\n * @property {number} uint64=0 Uint64 default\n * @property {number} sint64=0 Sint32 default\n * @property {number} fixed64=0 Fixed64 default\n * @property {number} sfixed64=0 Sfixed64 default\n * @property {boolean} bool=false Bool default\n * @property {string} string=\"\" String default\n * @property {Array.<number>} bytes=Array(0) Bytes default\n * @property {null} message=null Message default\n */ types.defaults = bake([\n    /* double   */ 0,\n    /* float    */ 0,\n    /* int32    */ 0,\n    /* uint32   */ 0,\n    /* sint32   */ 0,\n    /* fixed32  */ 0,\n    /* sfixed32 */ 0,\n    /* int64    */ 0,\n    /* uint64   */ 0,\n    /* sint64   */ 0,\n    /* fixed64  */ 0,\n    /* sfixed64 */ 0,\n    /* bool     */ false,\n    /* string   */ \"\",\n    /* bytes    */ util.emptyArray,\n    /* message  */ null\n]);\n/**\n * Basic long type wire types.\n * @type {Object.<string,number>}\n * @const\n * @property {number} int64=0 Varint wire type\n * @property {number} uint64=0 Varint wire type\n * @property {number} sint64=0 Varint wire type\n * @property {number} fixed64=1 Fixed64 wire type\n * @property {number} sfixed64=1 Fixed64 wire type\n */ types.long = bake([\n    /* int64    */ 0,\n    /* uint64   */ 0,\n    /* sint64   */ 0,\n    /* fixed64  */ 1,\n    /* sfixed64 */ 1\n], 7);\n/**\n * Allowed types for map keys with their associated wire type.\n * @type {Object.<string,number>}\n * @const\n * @property {number} int32=0 Varint wire type\n * @property {number} uint32=0 Varint wire type\n * @property {number} sint32=0 Varint wire type\n * @property {number} fixed32=5 Fixed32 wire type\n * @property {number} sfixed32=5 Fixed32 wire type\n * @property {number} int64=0 Varint wire type\n * @property {number} uint64=0 Varint wire type\n * @property {number} sint64=0 Varint wire type\n * @property {number} fixed64=1 Fixed64 wire type\n * @property {number} sfixed64=1 Fixed64 wire type\n * @property {number} bool=0 Varint wire type\n * @property {number} string=2 Ldelim wire type\n */ types.mapKey = bake([\n    /* int32    */ 0,\n    /* uint32   */ 0,\n    /* sint32   */ 0,\n    /* fixed32  */ 5,\n    /* sfixed32 */ 5,\n    /* int64    */ 0,\n    /* uint64   */ 0,\n    /* sint64   */ 0,\n    /* fixed64  */ 1,\n    /* sfixed64 */ 1,\n    /* bool     */ 0,\n    /* string   */ 2\n], 2);\n/**\n * Allowed types for packed repeated fields with their associated wire type.\n * @type {Object.<string,number>}\n * @const\n * @property {number} double=1 Fixed64 wire type\n * @property {number} float=5 Fixed32 wire type\n * @property {number} int32=0 Varint wire type\n * @property {number} uint32=0 Varint wire type\n * @property {number} sint32=0 Varint wire type\n * @property {number} fixed32=5 Fixed32 wire type\n * @property {number} sfixed32=5 Fixed32 wire type\n * @property {number} int64=0 Varint wire type\n * @property {number} uint64=0 Varint wire type\n * @property {number} sint64=0 Varint wire type\n * @property {number} fixed64=1 Fixed64 wire type\n * @property {number} sfixed64=1 Fixed64 wire type\n * @property {number} bool=0 Varint wire type\n */ types.packed = bake([\n    /* double   */ 1,\n    /* float    */ 5,\n    /* int32    */ 0,\n    /* uint32   */ 0,\n    /* sint32   */ 0,\n    /* fixed32  */ 5,\n    /* sfixed32 */ 5,\n    /* int64    */ 0,\n    /* uint64   */ 0,\n    /* sint64   */ 0,\n    /* fixed64  */ 1,\n    /* sfixed64 */ 1,\n    /* bool     */ 0\n]);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3R5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWI7OztDQUdDLEdBQ0QsSUFBSUEsUUFBUUM7QUFFWixJQUFJQyxPQUFPQyxtQkFBT0EsQ0FBQyw0REFBUTtBQUUzQixJQUFJQyxJQUFJO0lBQ0o7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFFBQVksS0FBSztDQUNwQjtBQUVELFNBQVNDLEtBQUtDLE1BQU0sRUFBRUMsTUFBTTtJQUN4QixJQUFJQyxJQUFJLEdBQUdDLElBQUksQ0FBQztJQUNoQkYsVUFBVTtJQUNWLE1BQU9DLElBQUlGLE9BQU9JLE1BQU0sQ0FBRUQsQ0FBQyxDQUFDTCxDQUFDLENBQUNJLElBQUlELE9BQU8sQ0FBQyxHQUFHRCxNQUFNLENBQUNFLElBQUk7SUFDeEQsT0FBT0M7QUFDWDtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBbUJDLEdBQ0RULE1BQU1XLEtBQUssR0FBR04sS0FBSztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztDQUNsQjtBQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW9CQyxHQUNETCxNQUFNWSxRQUFRLEdBQUdQLEtBQUs7SUFDbEIsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHSCxLQUFLVyxVQUFVO0lBQzlCLFlBQVksR0FBRztDQUNsQjtBQUVEOzs7Ozs7Ozs7Q0FTQyxHQUNEYixNQUFNYyxJQUFJLEdBQUdULEtBQUs7SUFDZCxZQUFZLEdBQUc7SUFDZixZQUFZLEdBQUc7SUFDZixZQUFZLEdBQUc7SUFDZixZQUFZLEdBQUc7SUFDZixZQUFZLEdBQUc7Q0FDbEIsRUFBRTtBQUVIOzs7Ozs7Ozs7Ozs7Ozs7O0NBZ0JDLEdBQ0RMLE1BQU1lLE1BQU0sR0FBR1YsS0FBSztJQUNoQixZQUFZLEdBQUc7SUFDZixZQUFZLEdBQUc7SUFDZixZQUFZLEdBQUc7SUFDZixZQUFZLEdBQUc7SUFDZixZQUFZLEdBQUc7SUFDZixZQUFZLEdBQUc7SUFDZixZQUFZLEdBQUc7SUFDZixZQUFZLEdBQUc7SUFDZixZQUFZLEdBQUc7SUFDZixZQUFZLEdBQUc7SUFDZixZQUFZLEdBQUc7SUFDZixZQUFZLEdBQUc7Q0FDbEIsRUFBRTtBQUVIOzs7Ozs7Ozs7Ozs7Ozs7OztDQWlCQyxHQUNETCxNQUFNZ0IsTUFBTSxHQUFHWCxLQUFLO0lBQ2hCLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztDQUNsQiIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvdHlwZXMuanM/NTc4ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBDb21tb24gdHlwZSBjb25zdGFudHMuXG4gKiBAbmFtZXNwYWNlXG4gKi9cbnZhciB0eXBlcyA9IGV4cG9ydHM7XG5cbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcblxudmFyIHMgPSBbXG4gICAgXCJkb3VibGVcIiwgICAvLyAwXG4gICAgXCJmbG9hdFwiLCAgICAvLyAxXG4gICAgXCJpbnQzMlwiLCAgICAvLyAyXG4gICAgXCJ1aW50MzJcIiwgICAvLyAzXG4gICAgXCJzaW50MzJcIiwgICAvLyA0XG4gICAgXCJmaXhlZDMyXCIsICAvLyA1XG4gICAgXCJzZml4ZWQzMlwiLCAvLyA2XG4gICAgXCJpbnQ2NFwiLCAgICAvLyA3XG4gICAgXCJ1aW50NjRcIiwgICAvLyA4XG4gICAgXCJzaW50NjRcIiwgICAvLyA5XG4gICAgXCJmaXhlZDY0XCIsICAvLyAxMFxuICAgIFwic2ZpeGVkNjRcIiwgLy8gMTFcbiAgICBcImJvb2xcIiwgICAgIC8vIDEyXG4gICAgXCJzdHJpbmdcIiwgICAvLyAxM1xuICAgIFwiYnl0ZXNcIiAgICAgLy8gMTRcbl07XG5cbmZ1bmN0aW9uIGJha2UodmFsdWVzLCBvZmZzZXQpIHtcbiAgICB2YXIgaSA9IDAsIG8gPSB7fTtcbiAgICBvZmZzZXQgfD0gMDtcbiAgICB3aGlsZSAoaSA8IHZhbHVlcy5sZW5ndGgpIG9bc1tpICsgb2Zmc2V0XV0gPSB2YWx1ZXNbaSsrXTtcbiAgICByZXR1cm4gbztcbn1cblxuLyoqXG4gKiBCYXNpYyB0eXBlIHdpcmUgdHlwZXMuXG4gKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsbnVtYmVyPn1cbiAqIEBjb25zdFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGRvdWJsZT0xIEZpeGVkNjQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gZmxvYXQ9NSBGaXhlZDMyIHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGludDMyPTAgVmFyaW50IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHVpbnQzMj0wIFZhcmludCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzaW50MzI9MCBWYXJpbnQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gZml4ZWQzMj01IEZpeGVkMzIgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2ZpeGVkMzI9NSBGaXhlZDMyIHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGludDY0PTAgVmFyaW50IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHVpbnQ2ND0wIFZhcmludCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzaW50NjQ9MCBWYXJpbnQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gZml4ZWQ2ND0xIEZpeGVkNjQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2ZpeGVkNjQ9MSBGaXhlZDY0IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGJvb2w9MCBWYXJpbnQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gc3RyaW5nPTIgTGRlbGltIHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGJ5dGVzPTIgTGRlbGltIHdpcmUgdHlwZVxuICovXG50eXBlcy5iYXNpYyA9IGJha2UoW1xuICAgIC8qIGRvdWJsZSAgICovIDEsXG4gICAgLyogZmxvYXQgICAgKi8gNSxcbiAgICAvKiBpbnQzMiAgICAqLyAwLFxuICAgIC8qIHVpbnQzMiAgICovIDAsXG4gICAgLyogc2ludDMyICAgKi8gMCxcbiAgICAvKiBmaXhlZDMyICAqLyA1LFxuICAgIC8qIHNmaXhlZDMyICovIDUsXG4gICAgLyogaW50NjQgICAgKi8gMCxcbiAgICAvKiB1aW50NjQgICAqLyAwLFxuICAgIC8qIHNpbnQ2NCAgICovIDAsXG4gICAgLyogZml4ZWQ2NCAgKi8gMSxcbiAgICAvKiBzZml4ZWQ2NCAqLyAxLFxuICAgIC8qIGJvb2wgICAgICovIDAsXG4gICAgLyogc3RyaW5nICAgKi8gMixcbiAgICAvKiBieXRlcyAgICAqLyAyXG5dKTtcblxuLyoqXG4gKiBCYXNpYyB0eXBlIGRlZmF1bHRzLlxuICogQHR5cGUge09iamVjdC48c3RyaW5nLCo+fVxuICogQGNvbnN0XG4gKiBAcHJvcGVydHkge251bWJlcn0gZG91YmxlPTAgRG91YmxlIGRlZmF1bHRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmbG9hdD0wIEZsb2F0IGRlZmF1bHRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbnQzMj0wIEludDMyIGRlZmF1bHRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB1aW50MzI9MCBVaW50MzIgZGVmYXVsdFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNpbnQzMj0wIFNpbnQzMiBkZWZhdWx0XG4gKiBAcHJvcGVydHkge251bWJlcn0gZml4ZWQzMj0wIEZpeGVkMzIgZGVmYXVsdFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNmaXhlZDMyPTAgU2ZpeGVkMzIgZGVmYXVsdFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGludDY0PTAgSW50NjQgZGVmYXVsdFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHVpbnQ2ND0wIFVpbnQ2NCBkZWZhdWx0XG4gKiBAcHJvcGVydHkge251bWJlcn0gc2ludDY0PTAgU2ludDMyIGRlZmF1bHRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmaXhlZDY0PTAgRml4ZWQ2NCBkZWZhdWx0XG4gKiBAcHJvcGVydHkge251bWJlcn0gc2ZpeGVkNjQ9MCBTZml4ZWQ2NCBkZWZhdWx0XG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGJvb2w9ZmFsc2UgQm9vbCBkZWZhdWx0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gc3RyaW5nPVwiXCIgU3RyaW5nIGRlZmF1bHRcbiAqIEBwcm9wZXJ0eSB7QXJyYXkuPG51bWJlcj59IGJ5dGVzPUFycmF5KDApIEJ5dGVzIGRlZmF1bHRcbiAqIEBwcm9wZXJ0eSB7bnVsbH0gbWVzc2FnZT1udWxsIE1lc3NhZ2UgZGVmYXVsdFxuICovXG50eXBlcy5kZWZhdWx0cyA9IGJha2UoW1xuICAgIC8qIGRvdWJsZSAgICovIDAsXG4gICAgLyogZmxvYXQgICAgKi8gMCxcbiAgICAvKiBpbnQzMiAgICAqLyAwLFxuICAgIC8qIHVpbnQzMiAgICovIDAsXG4gICAgLyogc2ludDMyICAgKi8gMCxcbiAgICAvKiBmaXhlZDMyICAqLyAwLFxuICAgIC8qIHNmaXhlZDMyICovIDAsXG4gICAgLyogaW50NjQgICAgKi8gMCxcbiAgICAvKiB1aW50NjQgICAqLyAwLFxuICAgIC8qIHNpbnQ2NCAgICovIDAsXG4gICAgLyogZml4ZWQ2NCAgKi8gMCxcbiAgICAvKiBzZml4ZWQ2NCAqLyAwLFxuICAgIC8qIGJvb2wgICAgICovIGZhbHNlLFxuICAgIC8qIHN0cmluZyAgICovIFwiXCIsXG4gICAgLyogYnl0ZXMgICAgKi8gdXRpbC5lbXB0eUFycmF5LFxuICAgIC8qIG1lc3NhZ2UgICovIG51bGxcbl0pO1xuXG4vKipcbiAqIEJhc2ljIGxvbmcgdHlwZSB3aXJlIHR5cGVzLlxuICogQHR5cGUge09iamVjdC48c3RyaW5nLG51bWJlcj59XG4gKiBAY29uc3RcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbnQ2ND0wIFZhcmludCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB1aW50NjQ9MCBWYXJpbnQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2ludDY0PTAgVmFyaW50IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGZpeGVkNjQ9MSBGaXhlZDY0IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNmaXhlZDY0PTEgRml4ZWQ2NCB3aXJlIHR5cGVcbiAqL1xudHlwZXMubG9uZyA9IGJha2UoW1xuICAgIC8qIGludDY0ICAgICovIDAsXG4gICAgLyogdWludDY0ICAgKi8gMCxcbiAgICAvKiBzaW50NjQgICAqLyAwLFxuICAgIC8qIGZpeGVkNjQgICovIDEsXG4gICAgLyogc2ZpeGVkNjQgKi8gMVxuXSwgNyk7XG5cbi8qKlxuICogQWxsb3dlZCB0eXBlcyBmb3IgbWFwIGtleXMgd2l0aCB0aGVpciBhc3NvY2lhdGVkIHdpcmUgdHlwZS5cbiAqIEB0eXBlIHtPYmplY3QuPHN0cmluZyxudW1iZXI+fVxuICogQGNvbnN0XG4gKiBAcHJvcGVydHkge251bWJlcn0gaW50MzI9MCBWYXJpbnQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gdWludDMyPTAgVmFyaW50IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNpbnQzMj0wIFZhcmludCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmaXhlZDMyPTUgRml4ZWQzMiB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzZml4ZWQzMj01IEZpeGVkMzIgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gaW50NjQ9MCBWYXJpbnQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gdWludDY0PTAgVmFyaW50IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNpbnQ2ND0wIFZhcmludCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmaXhlZDY0PTEgRml4ZWQ2NCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzZml4ZWQ2ND0xIEZpeGVkNjQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gYm9vbD0wIFZhcmludCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzdHJpbmc9MiBMZGVsaW0gd2lyZSB0eXBlXG4gKi9cbnR5cGVzLm1hcEtleSA9IGJha2UoW1xuICAgIC8qIGludDMyICAgICovIDAsXG4gICAgLyogdWludDMyICAgKi8gMCxcbiAgICAvKiBzaW50MzIgICAqLyAwLFxuICAgIC8qIGZpeGVkMzIgICovIDUsXG4gICAgLyogc2ZpeGVkMzIgKi8gNSxcbiAgICAvKiBpbnQ2NCAgICAqLyAwLFxuICAgIC8qIHVpbnQ2NCAgICovIDAsXG4gICAgLyogc2ludDY0ICAgKi8gMCxcbiAgICAvKiBmaXhlZDY0ICAqLyAxLFxuICAgIC8qIHNmaXhlZDY0ICovIDEsXG4gICAgLyogYm9vbCAgICAgKi8gMCxcbiAgICAvKiBzdHJpbmcgICAqLyAyXG5dLCAyKTtcblxuLyoqXG4gKiBBbGxvd2VkIHR5cGVzIGZvciBwYWNrZWQgcmVwZWF0ZWQgZmllbGRzIHdpdGggdGhlaXIgYXNzb2NpYXRlZCB3aXJlIHR5cGUuXG4gKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsbnVtYmVyPn1cbiAqIEBjb25zdFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGRvdWJsZT0xIEZpeGVkNjQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gZmxvYXQ9NSBGaXhlZDMyIHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGludDMyPTAgVmFyaW50IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHVpbnQzMj0wIFZhcmludCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzaW50MzI9MCBWYXJpbnQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gZml4ZWQzMj01IEZpeGVkMzIgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2ZpeGVkMzI9NSBGaXhlZDMyIHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGludDY0PTAgVmFyaW50IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHVpbnQ2ND0wIFZhcmludCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzaW50NjQ9MCBWYXJpbnQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gZml4ZWQ2ND0xIEZpeGVkNjQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2ZpeGVkNjQ9MSBGaXhlZDY0IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGJvb2w9MCBWYXJpbnQgd2lyZSB0eXBlXG4gKi9cbnR5cGVzLnBhY2tlZCA9IGJha2UoW1xuICAgIC8qIGRvdWJsZSAgICovIDEsXG4gICAgLyogZmxvYXQgICAgKi8gNSxcbiAgICAvKiBpbnQzMiAgICAqLyAwLFxuICAgIC8qIHVpbnQzMiAgICovIDAsXG4gICAgLyogc2ludDMyICAgKi8gMCxcbiAgICAvKiBmaXhlZDMyICAqLyA1LFxuICAgIC8qIHNmaXhlZDMyICovIDUsXG4gICAgLyogaW50NjQgICAgKi8gMCxcbiAgICAvKiB1aW50NjQgICAqLyAwLFxuICAgIC8qIHNpbnQ2NCAgICovIDAsXG4gICAgLyogZml4ZWQ2NCAgKi8gMSxcbiAgICAvKiBzZml4ZWQ2NCAqLyAxLFxuICAgIC8qIGJvb2wgICAgICovIDBcbl0pO1xuIl0sIm5hbWVzIjpbInR5cGVzIiwiZXhwb3J0cyIsInV0aWwiLCJyZXF1aXJlIiwicyIsImJha2UiLCJ2YWx1ZXMiLCJvZmZzZXQiLCJpIiwibyIsImxlbmd0aCIsImJhc2ljIiwiZGVmYXVsdHMiLCJlbXB0eUFycmF5IiwibG9uZyIsIm1hcEtleSIsInBhY2tlZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/protobufjs/src/types.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/src/util.js":
/*!**********************************************!*\
  !*** ../node_modules/protobufjs/src/util.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n/**\n * Various utility functions.\n * @namespace\n */ var util = module.exports = __webpack_require__(/*! ./util/minimal */ \"(ssr)/../node_modules/protobufjs/src/util/minimal.js\");\nvar roots = __webpack_require__(/*! ./roots */ \"(ssr)/../node_modules/protobufjs/src/roots.js\");\nvar Type, Enum;\nutil.codegen = __webpack_require__(/*! @protobufjs/codegen */ \"(ssr)/../node_modules/@protobufjs/codegen/index.js\");\nutil.fetch = __webpack_require__(/*! @protobufjs/fetch */ \"(ssr)/../node_modules/@protobufjs/fetch/index.js\");\nutil.path = __webpack_require__(/*! @protobufjs/path */ \"(ssr)/../node_modules/@protobufjs/path/index.js\");\n/**\n * Node's fs module if available.\n * @type {Object.<string,*>}\n */ util.fs = util.inquire(\"fs\");\n/**\n * Converts an object's values to an array.\n * @param {Object.<string,*>} object Object to convert\n * @returns {Array.<*>} Converted array\n */ util.toArray = function toArray(object) {\n    if (object) {\n        var keys = Object.keys(object), array = new Array(keys.length), index = 0;\n        while(index < keys.length)array[index] = object[keys[index++]];\n        return array;\n    }\n    return [];\n};\n/**\n * Converts an array of keys immediately followed by their respective value to an object, omitting undefined values.\n * @param {Array.<*>} array Array to convert\n * @returns {Object.<string,*>} Converted object\n */ util.toObject = function toObject(array) {\n    var object = {}, index = 0;\n    while(index < array.length){\n        var key = array[index++], val = array[index++];\n        if (val !== undefined) object[key] = val;\n    }\n    return object;\n};\nvar safePropBackslashRe = /\\\\/g, safePropQuoteRe = /\"/g;\n/**\n * Tests whether the specified name is a reserved word in JS.\n * @param {string} name Name to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */ util.isReserved = function isReserved(name) {\n    return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(name);\n};\n/**\n * Returns a safe property accessor for the specified property name.\n * @param {string} prop Property name\n * @returns {string} Safe accessor\n */ util.safeProp = function safeProp(prop) {\n    if (!/^[$\\w_]+$/.test(prop) || util.isReserved(prop)) return '[\"' + prop.replace(safePropBackslashRe, \"\\\\\\\\\").replace(safePropQuoteRe, '\\\\\"') + '\"]';\n    return \".\" + prop;\n};\n/**\n * Converts the first character of a string to upper case.\n * @param {string} str String to convert\n * @returns {string} Converted string\n */ util.ucFirst = function ucFirst(str) {\n    return str.charAt(0).toUpperCase() + str.substring(1);\n};\nvar camelCaseRe = /_([a-z])/g;\n/**\n * Converts a string to camel case.\n * @param {string} str String to convert\n * @returns {string} Converted string\n */ util.camelCase = function camelCase(str) {\n    return str.substring(0, 1) + str.substring(1).replace(camelCaseRe, function($0, $1) {\n        return $1.toUpperCase();\n    });\n};\n/**\n * Compares reflected fields by id.\n * @param {Field} a First field\n * @param {Field} b Second field\n * @returns {number} Comparison value\n */ util.compareFieldsById = function compareFieldsById(a, b) {\n    return a.id - b.id;\n};\n/**\n * Decorator helper for types (TypeScript).\n * @param {Constructor<T>} ctor Constructor function\n * @param {string} [typeName] Type name, defaults to the constructor's name\n * @returns {Type} Reflected type\n * @template T extends Message<T>\n * @property {Root} root Decorators root\n */ util.decorateType = function decorateType(ctor, typeName) {\n    /* istanbul ignore if */ if (ctor.$type) {\n        if (typeName && ctor.$type.name !== typeName) {\n            util.decorateRoot.remove(ctor.$type);\n            ctor.$type.name = typeName;\n            util.decorateRoot.add(ctor.$type);\n        }\n        return ctor.$type;\n    }\n    /* istanbul ignore next */ if (!Type) Type = __webpack_require__(/*! ./type */ \"(ssr)/../node_modules/protobufjs/src/type.js\");\n    var type = new Type(typeName || ctor.name);\n    util.decorateRoot.add(type);\n    type.ctor = ctor; // sets up .encode, .decode etc.\n    Object.defineProperty(ctor, \"$type\", {\n        value: type,\n        enumerable: false\n    });\n    Object.defineProperty(ctor.prototype, \"$type\", {\n        value: type,\n        enumerable: false\n    });\n    return type;\n};\nvar decorateEnumIndex = 0;\n/**\n * Decorator helper for enums (TypeScript).\n * @param {Object} object Enum object\n * @returns {Enum} Reflected enum\n */ util.decorateEnum = function decorateEnum(object) {\n    /* istanbul ignore if */ if (object.$type) return object.$type;\n    /* istanbul ignore next */ if (!Enum) Enum = __webpack_require__(/*! ./enum */ \"(ssr)/../node_modules/protobufjs/src/enum.js\");\n    var enm = new Enum(\"Enum\" + decorateEnumIndex++, object);\n    util.decorateRoot.add(enm);\n    Object.defineProperty(object, \"$type\", {\n        value: enm,\n        enumerable: false\n    });\n    return enm;\n};\n/**\n * Sets the value of a property by property path. If a value already exists, it is turned to an array\n * @param {Object.<string,*>} dst Destination object\n * @param {string} path dot '.' delimited path of the property to set\n * @param {Object} value the value to set\n * @returns {Object.<string,*>} Destination object\n */ util.setProperty = function setProperty(dst, path, value) {\n    function setProp(dst, path, value) {\n        var part = path.shift();\n        if (part === \"__proto__\" || part === \"prototype\") {\n            return dst;\n        }\n        if (path.length > 0) {\n            dst[part] = setProp(dst[part] || {}, path, value);\n        } else {\n            var prevValue = dst[part];\n            if (prevValue) value = [].concat(prevValue).concat(value);\n            dst[part] = value;\n        }\n        return dst;\n    }\n    if (typeof dst !== \"object\") throw TypeError(\"dst must be an object\");\n    if (!path) throw TypeError(\"path must be specified\");\n    path = path.split(\".\");\n    return setProp(dst, path, value);\n};\n/**\n * Decorator root (TypeScript).\n * @name util.decorateRoot\n * @type {Root}\n * @readonly\n */ Object.defineProperty(util, \"decorateRoot\", {\n    get: function() {\n        return roots[\"decorated\"] || (roots[\"decorated\"] = new (__webpack_require__(/*! ./root */ \"(ssr)/../node_modules/protobufjs/src/root.js\"))());\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3V0aWwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYjs7O0NBR0MsR0FDRCxJQUFJQSxPQUFPQyxrSEFBMEM7QUFFckQsSUFBSUcsUUFBUUQsbUJBQU9BLENBQUMsOERBQVM7QUFFN0IsSUFBSUUsTUFDQUM7QUFFSk4sS0FBS08sT0FBTyxHQUFHSixtQkFBT0EsQ0FBQywrRUFBcUI7QUFDNUNILEtBQUtRLEtBQUssR0FBS0wsbUJBQU9BLENBQUMsMkVBQW1CO0FBQzFDSCxLQUFLUyxJQUFJLEdBQU1OLG1CQUFPQSxDQUFDLHlFQUFrQjtBQUV6Qzs7O0NBR0MsR0FDREgsS0FBS1UsRUFBRSxHQUFHVixLQUFLVyxPQUFPLENBQUM7QUFFdkI7Ozs7Q0FJQyxHQUNEWCxLQUFLWSxPQUFPLEdBQUcsU0FBU0EsUUFBUUMsTUFBTTtJQUNsQyxJQUFJQSxRQUFRO1FBQ1IsSUFBSUMsT0FBUUMsT0FBT0QsSUFBSSxDQUFDRCxTQUNwQkcsUUFBUSxJQUFJQyxNQUFNSCxLQUFLSSxNQUFNLEdBQzdCQyxRQUFRO1FBQ1osTUFBT0EsUUFBUUwsS0FBS0ksTUFBTSxDQUN0QkYsS0FBSyxDQUFDRyxNQUFNLEdBQUdOLE1BQU0sQ0FBQ0MsSUFBSSxDQUFDSyxRQUFRLENBQUM7UUFDeEMsT0FBT0g7SUFDWDtJQUNBLE9BQU8sRUFBRTtBQUNiO0FBRUE7Ozs7Q0FJQyxHQUNEaEIsS0FBS29CLFFBQVEsR0FBRyxTQUFTQSxTQUFTSixLQUFLO0lBQ25DLElBQUlILFNBQVMsQ0FBQyxHQUNWTSxRQUFTO0lBQ2IsTUFBT0EsUUFBUUgsTUFBTUUsTUFBTSxDQUFFO1FBQ3pCLElBQUlHLE1BQU1MLEtBQUssQ0FBQ0csUUFBUSxFQUNwQkcsTUFBTU4sS0FBSyxDQUFDRyxRQUFRO1FBQ3hCLElBQUlHLFFBQVFDLFdBQ1JWLE1BQU0sQ0FBQ1EsSUFBSSxHQUFHQztJQUN0QjtJQUNBLE9BQU9UO0FBQ1g7QUFFQSxJQUFJVyxzQkFBc0IsT0FDdEJDLGtCQUFzQjtBQUUxQjs7OztDQUlDLEdBQ0R6QixLQUFLMEIsVUFBVSxHQUFHLFNBQVNBLFdBQVdDLElBQUk7SUFDdEMsT0FBTyx1VEFBdVRDLElBQUksQ0FBQ0Q7QUFDdlU7QUFFQTs7OztDQUlDLEdBQ0QzQixLQUFLNkIsUUFBUSxHQUFHLFNBQVNBLFNBQVNDLElBQUk7SUFDbEMsSUFBSSxDQUFDLFlBQVlGLElBQUksQ0FBQ0UsU0FBUzlCLEtBQUswQixVQUFVLENBQUNJLE9BQzNDLE9BQU8sT0FBUUEsS0FBS0MsT0FBTyxDQUFDUCxxQkFBcUIsUUFBUU8sT0FBTyxDQUFDTixpQkFBaUIsU0FBVTtJQUNoRyxPQUFPLE1BQU1LO0FBQ2pCO0FBRUE7Ozs7Q0FJQyxHQUNEOUIsS0FBS2dDLE9BQU8sR0FBRyxTQUFTQSxRQUFRQyxHQUFHO0lBQy9CLE9BQU9BLElBQUlDLE1BQU0sQ0FBQyxHQUFHQyxXQUFXLEtBQUtGLElBQUlHLFNBQVMsQ0FBQztBQUN2RDtBQUVBLElBQUlDLGNBQWM7QUFFbEI7Ozs7Q0FJQyxHQUNEckMsS0FBS3NDLFNBQVMsR0FBRyxTQUFTQSxVQUFVTCxHQUFHO0lBQ25DLE9BQU9BLElBQUlHLFNBQVMsQ0FBQyxHQUFHLEtBQ2pCSCxJQUFJRyxTQUFTLENBQUMsR0FDVEwsT0FBTyxDQUFDTSxhQUFhLFNBQVNFLEVBQUUsRUFBRUMsRUFBRTtRQUFJLE9BQU9BLEdBQUdMLFdBQVc7SUFBSTtBQUNqRjtBQUVBOzs7OztDQUtDLEdBQ0RuQyxLQUFLeUMsaUJBQWlCLEdBQUcsU0FBU0Esa0JBQWtCQyxDQUFDLEVBQUVDLENBQUM7SUFDcEQsT0FBT0QsRUFBRUUsRUFBRSxHQUFHRCxFQUFFQyxFQUFFO0FBQ3RCO0FBRUE7Ozs7Ozs7Q0FPQyxHQUNENUMsS0FBSzZDLFlBQVksR0FBRyxTQUFTQSxhQUFhQyxJQUFJLEVBQUVDLFFBQVE7SUFFcEQsc0JBQXNCLEdBQ3RCLElBQUlELEtBQUtFLEtBQUssRUFBRTtRQUNaLElBQUlELFlBQVlELEtBQUtFLEtBQUssQ0FBQ3JCLElBQUksS0FBS29CLFVBQVU7WUFDMUMvQyxLQUFLaUQsWUFBWSxDQUFDQyxNQUFNLENBQUNKLEtBQUtFLEtBQUs7WUFDbkNGLEtBQUtFLEtBQUssQ0FBQ3JCLElBQUksR0FBR29CO1lBQ2xCL0MsS0FBS2lELFlBQVksQ0FBQ0UsR0FBRyxDQUFDTCxLQUFLRSxLQUFLO1FBQ3BDO1FBQ0EsT0FBT0YsS0FBS0UsS0FBSztJQUNyQjtJQUVBLHdCQUF3QixHQUN4QixJQUFJLENBQUMzQyxNQUNEQSxPQUFPRixtQkFBT0EsQ0FBQyw0REFBUTtJQUUzQixJQUFJaUQsT0FBTyxJQUFJL0MsS0FBSzBDLFlBQVlELEtBQUtuQixJQUFJO0lBQ3pDM0IsS0FBS2lELFlBQVksQ0FBQ0UsR0FBRyxDQUFDQztJQUN0QkEsS0FBS04sSUFBSSxHQUFHQSxNQUFNLGdDQUFnQztJQUNsRC9CLE9BQU9zQyxjQUFjLENBQUNQLE1BQU0sU0FBUztRQUFFUSxPQUFPRjtRQUFNRyxZQUFZO0lBQU07SUFDdEV4QyxPQUFPc0MsY0FBYyxDQUFDUCxLQUFLVSxTQUFTLEVBQUUsU0FBUztRQUFFRixPQUFPRjtRQUFNRyxZQUFZO0lBQU07SUFDaEYsT0FBT0g7QUFDWDtBQUVBLElBQUlLLG9CQUFvQjtBQUV4Qjs7OztDQUlDLEdBQ0R6RCxLQUFLMEQsWUFBWSxHQUFHLFNBQVNBLGFBQWE3QyxNQUFNO0lBRTVDLHNCQUFzQixHQUN0QixJQUFJQSxPQUFPbUMsS0FBSyxFQUNaLE9BQU9uQyxPQUFPbUMsS0FBSztJQUV2Qix3QkFBd0IsR0FDeEIsSUFBSSxDQUFDMUMsTUFDREEsT0FBT0gsbUJBQU9BLENBQUMsNERBQVE7SUFFM0IsSUFBSXdELE1BQU0sSUFBSXJELEtBQUssU0FBU21ELHFCQUFxQjVDO0lBQ2pEYixLQUFLaUQsWUFBWSxDQUFDRSxHQUFHLENBQUNRO0lBQ3RCNUMsT0FBT3NDLGNBQWMsQ0FBQ3hDLFFBQVEsU0FBUztRQUFFeUMsT0FBT0s7UUFBS0osWUFBWTtJQUFNO0lBQ3ZFLE9BQU9JO0FBQ1g7QUFHQTs7Ozs7O0NBTUMsR0FDRDNELEtBQUs0RCxXQUFXLEdBQUcsU0FBU0EsWUFBWUMsR0FBRyxFQUFFcEQsSUFBSSxFQUFFNkMsS0FBSztJQUNwRCxTQUFTUSxRQUFRRCxHQUFHLEVBQUVwRCxJQUFJLEVBQUU2QyxLQUFLO1FBQzdCLElBQUlTLE9BQU90RCxLQUFLdUQsS0FBSztRQUNyQixJQUFJRCxTQUFTLGVBQWVBLFNBQVMsYUFBYTtZQUNoRCxPQUFPRjtRQUNUO1FBQ0EsSUFBSXBELEtBQUtTLE1BQU0sR0FBRyxHQUFHO1lBQ2pCMkMsR0FBRyxDQUFDRSxLQUFLLEdBQUdELFFBQVFELEdBQUcsQ0FBQ0UsS0FBSyxJQUFJLENBQUMsR0FBR3RELE1BQU02QztRQUMvQyxPQUFPO1lBQ0gsSUFBSVcsWUFBWUosR0FBRyxDQUFDRSxLQUFLO1lBQ3pCLElBQUlFLFdBQ0FYLFFBQVEsRUFBRSxDQUFDWSxNQUFNLENBQUNELFdBQVdDLE1BQU0sQ0FBQ1o7WUFDeENPLEdBQUcsQ0FBQ0UsS0FBSyxHQUFHVDtRQUNoQjtRQUNBLE9BQU9PO0lBQ1g7SUFFQSxJQUFJLE9BQU9BLFFBQVEsVUFDZixNQUFNTSxVQUFVO0lBQ3BCLElBQUksQ0FBQzFELE1BQ0QsTUFBTTBELFVBQVU7SUFFcEIxRCxPQUFPQSxLQUFLMkQsS0FBSyxDQUFDO0lBQ2xCLE9BQU9OLFFBQVFELEtBQUtwRCxNQUFNNkM7QUFDOUI7QUFFQTs7Ozs7Q0FLQyxHQUNEdkMsT0FBT3NDLGNBQWMsQ0FBQ3JELE1BQU0sZ0JBQWdCO0lBQ3hDcUUsS0FBSztRQUNELE9BQU9qRSxLQUFLLENBQUMsWUFBWSxJQUFLQSxDQUFBQSxLQUFLLENBQUMsWUFBWSxHQUFHLElBQUtELENBQUFBLG1CQUFPQSxDQUFDLDREQUFRLElBQUc7SUFDL0U7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvdXRpbC5qcz80YmYwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIFZhcmlvdXMgdXRpbGl0eSBmdW5jdGlvbnMuXG4gKiBAbmFtZXNwYWNlXG4gKi9cbnZhciB1dGlsID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi91dGlsL21pbmltYWxcIik7XG5cbnZhciByb290cyA9IHJlcXVpcmUoXCIuL3Jvb3RzXCIpO1xuXG52YXIgVHlwZSwgLy8gY3ljbGljXG4gICAgRW51bTtcblxudXRpbC5jb2RlZ2VuID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL2NvZGVnZW5cIik7XG51dGlsLmZldGNoICAgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvZmV0Y2hcIik7XG51dGlsLnBhdGggICAgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvcGF0aFwiKTtcblxuLyoqXG4gKiBOb2RlJ3MgZnMgbW9kdWxlIGlmIGF2YWlsYWJsZS5cbiAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywqPn1cbiAqL1xudXRpbC5mcyA9IHV0aWwuaW5xdWlyZShcImZzXCIpO1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCdzIHZhbHVlcyB0byBhbiBhcnJheS5cbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9iamVjdCBPYmplY3QgdG8gY29udmVydFxuICogQHJldHVybnMge0FycmF5LjwqPn0gQ29udmVydGVkIGFycmF5XG4gKi9cbnV0aWwudG9BcnJheSA9IGZ1bmN0aW9uIHRvQXJyYXkob2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdCkge1xuICAgICAgICB2YXIga2V5cyAgPSBPYmplY3Qua2V5cyhvYmplY3QpLFxuICAgICAgICAgICAgYXJyYXkgPSBuZXcgQXJyYXkoa2V5cy5sZW5ndGgpLFxuICAgICAgICAgICAgaW5kZXggPSAwO1xuICAgICAgICB3aGlsZSAoaW5kZXggPCBrZXlzLmxlbmd0aClcbiAgICAgICAgICAgIGFycmF5W2luZGV4XSA9IG9iamVjdFtrZXlzW2luZGV4KytdXTtcbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cbiAgICByZXR1cm4gW107XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIGFycmF5IG9mIGtleXMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgdGhlaXIgcmVzcGVjdGl2ZSB2YWx1ZSB0byBhbiBvYmplY3QsIG9taXR0aW5nIHVuZGVmaW5lZCB2YWx1ZXMuXG4gKiBAcGFyYW0ge0FycmF5LjwqPn0gYXJyYXkgQXJyYXkgdG8gY29udmVydFxuICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBDb252ZXJ0ZWQgb2JqZWN0XG4gKi9cbnV0aWwudG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChhcnJheSkge1xuICAgIHZhciBvYmplY3QgPSB7fSxcbiAgICAgICAgaW5kZXggID0gMDtcbiAgICB3aGlsZSAoaW5kZXggPCBhcnJheS5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGFycmF5W2luZGV4KytdLFxuICAgICAgICAgICAgdmFsID0gYXJyYXlbaW5kZXgrK107XG4gICAgICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIG9iamVjdFtrZXldID0gdmFsO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xufTtcblxudmFyIHNhZmVQcm9wQmFja3NsYXNoUmUgPSAvXFxcXC9nLFxuICAgIHNhZmVQcm9wUXVvdGVSZSAgICAgPSAvXCIvZztcblxuLyoqXG4gKiBUZXN0cyB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgbmFtZSBpcyBhIHJlc2VydmVkIHdvcmQgaW4gSlMuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgcmVzZXJ2ZWQsIG90aGVyd2lzZSBgZmFsc2VgXG4gKi9cbnV0aWwuaXNSZXNlcnZlZCA9IGZ1bmN0aW9uIGlzUmVzZXJ2ZWQobmFtZSkge1xuICAgIHJldHVybiAvXig/OmRvfGlmfGlufGZvcnxsZXR8bmV3fHRyeXx2YXJ8Y2FzZXxlbHNlfGVudW18ZXZhbHxmYWxzZXxudWxsfHRoaXN8dHJ1ZXx2b2lkfHdpdGh8YnJlYWt8Y2F0Y2h8Y2xhc3N8Y29uc3R8c3VwZXJ8dGhyb3d8d2hpbGV8eWllbGR8ZGVsZXRlfGV4cG9ydHxpbXBvcnR8cHVibGljfHJldHVybnxzdGF0aWN8c3dpdGNofHR5cGVvZnxkZWZhdWx0fGV4dGVuZHN8ZmluYWxseXxwYWNrYWdlfHByaXZhdGV8Y29udGludWV8ZGVidWdnZXJ8ZnVuY3Rpb258YXJndW1lbnRzfGludGVyZmFjZXxwcm90ZWN0ZWR8aW1wbGVtZW50c3xpbnN0YW5jZW9mKSQvLnRlc3QobmFtZSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBzYWZlIHByb3BlcnR5IGFjY2Vzc29yIGZvciB0aGUgc3BlY2lmaWVkIHByb3BlcnR5IG5hbWUuXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBQcm9wZXJ0eSBuYW1lXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBTYWZlIGFjY2Vzc29yXG4gKi9cbnV0aWwuc2FmZVByb3AgPSBmdW5jdGlvbiBzYWZlUHJvcChwcm9wKSB7XG4gICAgaWYgKCEvXlskXFx3X10rJC8udGVzdChwcm9wKSB8fCB1dGlsLmlzUmVzZXJ2ZWQocHJvcCkpXG4gICAgICAgIHJldHVybiBcIltcXFwiXCIgKyBwcm9wLnJlcGxhY2Uoc2FmZVByb3BCYWNrc2xhc2hSZSwgXCJcXFxcXFxcXFwiKS5yZXBsYWNlKHNhZmVQcm9wUXVvdGVSZSwgXCJcXFxcXFxcIlwiKSArIFwiXFxcIl1cIjtcbiAgICByZXR1cm4gXCIuXCIgKyBwcm9wO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGEgc3RyaW5nIHRvIHVwcGVyIGNhc2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIFN0cmluZyB0byBjb252ZXJ0XG4gKiBAcmV0dXJucyB7c3RyaW5nfSBDb252ZXJ0ZWQgc3RyaW5nXG4gKi9cbnV0aWwudWNGaXJzdCA9IGZ1bmN0aW9uIHVjRmlyc3Qoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zdWJzdHJpbmcoMSk7XG59O1xuXG52YXIgY2FtZWxDYXNlUmUgPSAvXyhbYS16XSkvZztcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHN0cmluZyB0byBjYW1lbCBjYXNlLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gY29udmVydFxuICogQHJldHVybnMge3N0cmluZ30gQ29udmVydGVkIHN0cmluZ1xuICovXG51dGlsLmNhbWVsQ2FzZSA9IGZ1bmN0aW9uIGNhbWVsQ2FzZShzdHIpIHtcbiAgICByZXR1cm4gc3RyLnN1YnN0cmluZygwLCAxKVxuICAgICAgICAgKyBzdHIuc3Vic3RyaW5nKDEpXG4gICAgICAgICAgICAgICAucmVwbGFjZShjYW1lbENhc2VSZSwgZnVuY3Rpb24oJDAsICQxKSB7IHJldHVybiAkMS50b1VwcGVyQ2FzZSgpOyB9KTtcbn07XG5cbi8qKlxuICogQ29tcGFyZXMgcmVmbGVjdGVkIGZpZWxkcyBieSBpZC5cbiAqIEBwYXJhbSB7RmllbGR9IGEgRmlyc3QgZmllbGRcbiAqIEBwYXJhbSB7RmllbGR9IGIgU2Vjb25kIGZpZWxkXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBDb21wYXJpc29uIHZhbHVlXG4gKi9cbnV0aWwuY29tcGFyZUZpZWxkc0J5SWQgPSBmdW5jdGlvbiBjb21wYXJlRmllbGRzQnlJZChhLCBiKSB7XG4gICAgcmV0dXJuIGEuaWQgLSBiLmlkO1xufTtcblxuLyoqXG4gKiBEZWNvcmF0b3IgaGVscGVyIGZvciB0eXBlcyAoVHlwZVNjcmlwdCkuXG4gKiBAcGFyYW0ge0NvbnN0cnVjdG9yPFQ+fSBjdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVOYW1lXSBUeXBlIG5hbWUsIGRlZmF1bHRzIHRvIHRoZSBjb25zdHJ1Y3RvcidzIG5hbWVcbiAqIEByZXR1cm5zIHtUeXBlfSBSZWZsZWN0ZWQgdHlwZVxuICogQHRlbXBsYXRlIFQgZXh0ZW5kcyBNZXNzYWdlPFQ+XG4gKiBAcHJvcGVydHkge1Jvb3R9IHJvb3QgRGVjb3JhdG9ycyByb290XG4gKi9cbnV0aWwuZGVjb3JhdGVUeXBlID0gZnVuY3Rpb24gZGVjb3JhdGVUeXBlKGN0b3IsIHR5cGVOYW1lKSB7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoY3Rvci4kdHlwZSkge1xuICAgICAgICBpZiAodHlwZU5hbWUgJiYgY3Rvci4kdHlwZS5uYW1lICE9PSB0eXBlTmFtZSkge1xuICAgICAgICAgICAgdXRpbC5kZWNvcmF0ZVJvb3QucmVtb3ZlKGN0b3IuJHR5cGUpO1xuICAgICAgICAgICAgY3Rvci4kdHlwZS5uYW1lID0gdHlwZU5hbWU7XG4gICAgICAgICAgICB1dGlsLmRlY29yYXRlUm9vdC5hZGQoY3Rvci4kdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN0b3IuJHR5cGU7XG4gICAgfVxuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAoIVR5cGUpXG4gICAgICAgIFR5cGUgPSByZXF1aXJlKFwiLi90eXBlXCIpO1xuXG4gICAgdmFyIHR5cGUgPSBuZXcgVHlwZSh0eXBlTmFtZSB8fCBjdG9yLm5hbWUpO1xuICAgIHV0aWwuZGVjb3JhdGVSb290LmFkZCh0eXBlKTtcbiAgICB0eXBlLmN0b3IgPSBjdG9yOyAvLyBzZXRzIHVwIC5lbmNvZGUsIC5kZWNvZGUgZXRjLlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdG9yLCBcIiR0eXBlXCIsIHsgdmFsdWU6IHR5cGUsIGVudW1lcmFibGU6IGZhbHNlIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdG9yLnByb3RvdHlwZSwgXCIkdHlwZVwiLCB7IHZhbHVlOiB0eXBlLCBlbnVtZXJhYmxlOiBmYWxzZSB9KTtcbiAgICByZXR1cm4gdHlwZTtcbn07XG5cbnZhciBkZWNvcmF0ZUVudW1JbmRleCA9IDA7XG5cbi8qKlxuICogRGVjb3JhdG9yIGhlbHBlciBmb3IgZW51bXMgKFR5cGVTY3JpcHQpLlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBFbnVtIG9iamVjdFxuICogQHJldHVybnMge0VudW19IFJlZmxlY3RlZCBlbnVtXG4gKi9cbnV0aWwuZGVjb3JhdGVFbnVtID0gZnVuY3Rpb24gZGVjb3JhdGVFbnVtKG9iamVjdCkge1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKG9iamVjdC4kdHlwZSlcbiAgICAgICAgcmV0dXJuIG9iamVjdC4kdHlwZTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgaWYgKCFFbnVtKVxuICAgICAgICBFbnVtID0gcmVxdWlyZShcIi4vZW51bVwiKTtcblxuICAgIHZhciBlbm0gPSBuZXcgRW51bShcIkVudW1cIiArIGRlY29yYXRlRW51bUluZGV4KyssIG9iamVjdCk7XG4gICAgdXRpbC5kZWNvcmF0ZVJvb3QuYWRkKGVubSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgXCIkdHlwZVwiLCB7IHZhbHVlOiBlbm0sIGVudW1lcmFibGU6IGZhbHNlIH0pO1xuICAgIHJldHVybiBlbm07XG59O1xuXG5cbi8qKlxuICogU2V0cyB0aGUgdmFsdWUgb2YgYSBwcm9wZXJ0eSBieSBwcm9wZXJ0eSBwYXRoLiBJZiBhIHZhbHVlIGFscmVhZHkgZXhpc3RzLCBpdCBpcyB0dXJuZWQgdG8gYW4gYXJyYXlcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IGRzdCBEZXN0aW5hdGlvbiBvYmplY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIGRvdCAnLicgZGVsaW1pdGVkIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldFxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIHRoZSB2YWx1ZSB0byBzZXRcbiAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gRGVzdGluYXRpb24gb2JqZWN0XG4gKi9cbnV0aWwuc2V0UHJvcGVydHkgPSBmdW5jdGlvbiBzZXRQcm9wZXJ0eShkc3QsIHBhdGgsIHZhbHVlKSB7XG4gICAgZnVuY3Rpb24gc2V0UHJvcChkc3QsIHBhdGgsIHZhbHVlKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gcGF0aC5zaGlmdCgpO1xuICAgICAgICBpZiAocGFydCA9PT0gXCJfX3Byb3RvX19cIiB8fCBwYXJ0ID09PSBcInByb3RvdHlwZVwiKSB7XG4gICAgICAgICAgcmV0dXJuIGRzdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0aC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBkc3RbcGFydF0gPSBzZXRQcm9wKGRzdFtwYXJ0XSB8fCB7fSwgcGF0aCwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHByZXZWYWx1ZSA9IGRzdFtwYXJ0XTtcbiAgICAgICAgICAgIGlmIChwcmV2VmFsdWUpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBbXS5jb25jYXQocHJldlZhbHVlKS5jb25jYXQodmFsdWUpO1xuICAgICAgICAgICAgZHN0W3BhcnRdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRzdDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRzdCAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiZHN0IG11c3QgYmUgYW4gb2JqZWN0XCIpO1xuICAgIGlmICghcGF0aClcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwicGF0aCBtdXN0IGJlIHNwZWNpZmllZFwiKTtcblxuICAgIHBhdGggPSBwYXRoLnNwbGl0KFwiLlwiKTtcbiAgICByZXR1cm4gc2V0UHJvcChkc3QsIHBhdGgsIHZhbHVlKTtcbn07XG5cbi8qKlxuICogRGVjb3JhdG9yIHJvb3QgKFR5cGVTY3JpcHQpLlxuICogQG5hbWUgdXRpbC5kZWNvcmF0ZVJvb3RcbiAqIEB0eXBlIHtSb290fVxuICogQHJlYWRvbmx5XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh1dGlsLCBcImRlY29yYXRlUm9vdFwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHJvb3RzW1wiZGVjb3JhdGVkXCJdIHx8IChyb290c1tcImRlY29yYXRlZFwiXSA9IG5ldyAocmVxdWlyZShcIi4vcm9vdFwiKSkoKSk7XG4gICAgfVxufSk7XG4iXSwibmFtZXMiOlsidXRpbCIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIiwicm9vdHMiLCJUeXBlIiwiRW51bSIsImNvZGVnZW4iLCJmZXRjaCIsInBhdGgiLCJmcyIsImlucXVpcmUiLCJ0b0FycmF5Iiwib2JqZWN0Iiwia2V5cyIsIk9iamVjdCIsImFycmF5IiwiQXJyYXkiLCJsZW5ndGgiLCJpbmRleCIsInRvT2JqZWN0Iiwia2V5IiwidmFsIiwidW5kZWZpbmVkIiwic2FmZVByb3BCYWNrc2xhc2hSZSIsInNhZmVQcm9wUXVvdGVSZSIsImlzUmVzZXJ2ZWQiLCJuYW1lIiwidGVzdCIsInNhZmVQcm9wIiwicHJvcCIsInJlcGxhY2UiLCJ1Y0ZpcnN0Iiwic3RyIiwiY2hhckF0IiwidG9VcHBlckNhc2UiLCJzdWJzdHJpbmciLCJjYW1lbENhc2VSZSIsImNhbWVsQ2FzZSIsIiQwIiwiJDEiLCJjb21wYXJlRmllbGRzQnlJZCIsImEiLCJiIiwiaWQiLCJkZWNvcmF0ZVR5cGUiLCJjdG9yIiwidHlwZU5hbWUiLCIkdHlwZSIsImRlY29yYXRlUm9vdCIsInJlbW92ZSIsImFkZCIsInR5cGUiLCJkZWZpbmVQcm9wZXJ0eSIsInZhbHVlIiwiZW51bWVyYWJsZSIsInByb3RvdHlwZSIsImRlY29yYXRlRW51bUluZGV4IiwiZGVjb3JhdGVFbnVtIiwiZW5tIiwic2V0UHJvcGVydHkiLCJkc3QiLCJzZXRQcm9wIiwicGFydCIsInNoaWZ0IiwicHJldlZhbHVlIiwiY29uY2F0IiwiVHlwZUVycm9yIiwic3BsaXQiLCJnZXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/protobufjs/src/util.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/src/util/longbits.js":
/*!*******************************************************!*\
  !*** ../node_modules/protobufjs/src/util/longbits.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = LongBits;\nvar util = __webpack_require__(/*! ../util/minimal */ \"(ssr)/../node_modules/protobufjs/src/util/minimal.js\");\n/**\n * Constructs new long bits.\n * @classdesc Helper class for working with the low and high bits of a 64 bit value.\n * @memberof util\n * @constructor\n * @param {number} lo Low 32 bits, unsigned\n * @param {number} hi High 32 bits, unsigned\n */ function LongBits(lo, hi) {\n    // note that the casts below are theoretically unnecessary as of today, but older statically\n    // generated converter code might still call the ctor with signed 32bits. kept for compat.\n    /**\n     * Low bits.\n     * @type {number}\n     */ this.lo = lo >>> 0;\n    /**\n     * High bits.\n     * @type {number}\n     */ this.hi = hi >>> 0;\n}\n/**\n * Zero bits.\n * @memberof util.LongBits\n * @type {util.LongBits}\n */ var zero = LongBits.zero = new LongBits(0, 0);\nzero.toNumber = function() {\n    return 0;\n};\nzero.zzEncode = zero.zzDecode = function() {\n    return this;\n};\nzero.length = function() {\n    return 1;\n};\n/**\n * Zero hash.\n * @memberof util.LongBits\n * @type {string}\n */ var zeroHash = LongBits.zeroHash = \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\";\n/**\n * Constructs new long bits from the specified number.\n * @param {number} value Value\n * @returns {util.LongBits} Instance\n */ LongBits.fromNumber = function fromNumber(value) {\n    if (value === 0) return zero;\n    var sign = value < 0;\n    if (sign) value = -value;\n    var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;\n    if (sign) {\n        hi = ~hi >>> 0;\n        lo = ~lo >>> 0;\n        if (++lo > 4294967295) {\n            lo = 0;\n            if (++hi > 4294967295) hi = 0;\n        }\n    }\n    return new LongBits(lo, hi);\n};\n/**\n * Constructs new long bits from a number, long or string.\n * @param {Long|number|string} value Value\n * @returns {util.LongBits} Instance\n */ LongBits.from = function from(value) {\n    if (typeof value === \"number\") return LongBits.fromNumber(value);\n    if (util.isString(value)) {\n        /* istanbul ignore else */ if (util.Long) value = util.Long.fromString(value);\n        else return LongBits.fromNumber(parseInt(value, 10));\n    }\n    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;\n};\n/**\n * Converts this long bits to a possibly unsafe JavaScript number.\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {number} Possibly unsafe number\n */ LongBits.prototype.toNumber = function toNumber(unsigned) {\n    if (!unsigned && this.hi >>> 31) {\n        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;\n        if (!lo) hi = hi + 1 >>> 0;\n        return -(lo + hi * 4294967296);\n    }\n    return this.lo + this.hi * 4294967296;\n};\n/**\n * Converts this long bits to a long.\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {Long} Long\n */ LongBits.prototype.toLong = function toLong(unsigned) {\n    return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : {\n        low: this.lo | 0,\n        high: this.hi | 0,\n        unsigned: Boolean(unsigned)\n    };\n};\nvar charCodeAt = String.prototype.charCodeAt;\n/**\n * Constructs new long bits from the specified 8 characters long hash.\n * @param {string} hash Hash\n * @returns {util.LongBits} Bits\n */ LongBits.fromHash = function fromHash(hash) {\n    if (hash === zeroHash) return zero;\n    return new LongBits((charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0, (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0);\n};\n/**\n * Converts this long bits to a 8 characters long hash.\n * @returns {string} Hash\n */ LongBits.prototype.toHash = function toHash() {\n    return String.fromCharCode(this.lo & 255, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, this.hi & 255, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);\n};\n/**\n * Zig-zag encodes this long bits.\n * @returns {util.LongBits} `this`\n */ LongBits.prototype.zzEncode = function zzEncode() {\n    var mask = this.hi >> 31;\n    this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;\n    this.lo = (this.lo << 1 ^ mask) >>> 0;\n    return this;\n};\n/**\n * Zig-zag decodes this long bits.\n * @returns {util.LongBits} `this`\n */ LongBits.prototype.zzDecode = function zzDecode() {\n    var mask = -(this.lo & 1);\n    this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;\n    this.hi = (this.hi >>> 1 ^ mask) >>> 0;\n    return this;\n};\n/**\n * Calculates the length of this longbits when encoded as a varint.\n * @returns {number} Length\n */ LongBits.prototype.length = function length() {\n    var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;\n    return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3V0aWwvbG9uZ2JpdHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsT0FBT0MsT0FBTyxHQUFHQztBQUVqQixJQUFJQyxPQUFPQyxtQkFBT0EsQ0FBQyw2RUFBaUI7QUFFcEM7Ozs7Ozs7Q0FPQyxHQUNELFNBQVNGLFNBQVNHLEVBQUUsRUFBRUMsRUFBRTtJQUVwQiw0RkFBNEY7SUFDNUYsMEZBQTBGO0lBRTFGOzs7S0FHQyxHQUNELElBQUksQ0FBQ0QsRUFBRSxHQUFHQSxPQUFPO0lBRWpCOzs7S0FHQyxHQUNELElBQUksQ0FBQ0MsRUFBRSxHQUFHQSxPQUFPO0FBQ3JCO0FBRUE7Ozs7Q0FJQyxHQUNELElBQUlDLE9BQU9MLFNBQVNLLElBQUksR0FBRyxJQUFJTCxTQUFTLEdBQUc7QUFFM0NLLEtBQUtDLFFBQVEsR0FBRztJQUFhLE9BQU87QUFBRztBQUN2Q0QsS0FBS0UsUUFBUSxHQUFHRixLQUFLRyxRQUFRLEdBQUc7SUFBYSxPQUFPLElBQUk7QUFBRTtBQUMxREgsS0FBS0ksTUFBTSxHQUFHO0lBQWEsT0FBTztBQUFHO0FBRXJDOzs7O0NBSUMsR0FDRCxJQUFJQyxXQUFXVixTQUFTVSxRQUFRLEdBQUc7QUFFbkM7Ozs7Q0FJQyxHQUNEVixTQUFTVyxVQUFVLEdBQUcsU0FBU0EsV0FBV0MsS0FBSztJQUMzQyxJQUFJQSxVQUFVLEdBQ1YsT0FBT1A7SUFDWCxJQUFJUSxPQUFPRCxRQUFRO0lBQ25CLElBQUlDLE1BQ0FELFFBQVEsQ0FBQ0E7SUFDYixJQUFJVCxLQUFLUyxVQUFVLEdBQ2ZSLEtBQUssQ0FBQ1EsUUFBUVQsRUFBQyxJQUFLLGVBQWU7SUFDdkMsSUFBSVUsTUFBTTtRQUNOVCxLQUFLLENBQUNBLE9BQU87UUFDYkQsS0FBSyxDQUFDQSxPQUFPO1FBQ2IsSUFBSSxFQUFFQSxLQUFLLFlBQVk7WUFDbkJBLEtBQUs7WUFDTCxJQUFJLEVBQUVDLEtBQUssWUFDUEEsS0FBSztRQUNiO0lB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QUMxQkMsUUFBUSxNQUFNLElBQUk7QUFDN0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3V0aWwvbG9uZ2JpdHMuanM/YWU1MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gTG9uZ0JpdHM7XG5cbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWwvbWluaW1hbFwiKTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIG5ldyBsb25nIGJpdHMuXG4gKiBAY2xhc3NkZXNjIEhlbHBlciBjbGFzcyBmb3Igd29ya2luZyB3aXRoIHRoZSBsb3cgYW5kIGhpZ2ggYml0cyBvZiBhIDY0IGJpdCB2YWx1ZS5cbiAqIEBtZW1iZXJvZiB1dGlsXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7bnVtYmVyfSBsbyBMb3cgMzIgYml0cywgdW5zaWduZWRcbiAqIEBwYXJhbSB7bnVtYmVyfSBoaSBIaWdoIDMyIGJpdHMsIHVuc2lnbmVkXG4gKi9cbmZ1bmN0aW9uIExvbmdCaXRzKGxvLCBoaSkge1xuXG4gICAgLy8gbm90ZSB0aGF0IHRoZSBjYXN0cyBiZWxvdyBhcmUgdGhlb3JldGljYWxseSB1bm5lY2Vzc2FyeSBhcyBvZiB0b2RheSwgYnV0IG9sZGVyIHN0YXRpY2FsbHlcbiAgICAvLyBnZW5lcmF0ZWQgY29udmVydGVyIGNvZGUgbWlnaHQgc3RpbGwgY2FsbCB0aGUgY3RvciB3aXRoIHNpZ25lZCAzMmJpdHMuIGtlcHQgZm9yIGNvbXBhdC5cblxuICAgIC8qKlxuICAgICAqIExvdyBiaXRzLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5sbyA9IGxvID4+PiAwO1xuXG4gICAgLyoqXG4gICAgICogSGlnaCBiaXRzLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5oaSA9IGhpID4+PiAwO1xufVxuXG4vKipcbiAqIFplcm8gYml0cy5cbiAqIEBtZW1iZXJvZiB1dGlsLkxvbmdCaXRzXG4gKiBAdHlwZSB7dXRpbC5Mb25nQml0c31cbiAqL1xudmFyIHplcm8gPSBMb25nQml0cy56ZXJvID0gbmV3IExvbmdCaXRzKDAsIDApO1xuXG56ZXJvLnRvTnVtYmVyID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuemVyby56ekVuY29kZSA9IHplcm8uenpEZWNvZGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH07XG56ZXJvLmxlbmd0aCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMTsgfTtcblxuLyoqXG4gKiBaZXJvIGhhc2guXG4gKiBAbWVtYmVyb2YgdXRpbC5Mb25nQml0c1xuICogQHR5cGUge3N0cmluZ31cbiAqL1xudmFyIHplcm9IYXNoID0gTG9uZ0JpdHMuemVyb0hhc2ggPSBcIlxcMFxcMFxcMFxcMFxcMFxcMFxcMFxcMFwiO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgbmV3IGxvbmcgYml0cyBmcm9tIHRoZSBzcGVjaWZpZWQgbnVtYmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlXG4gKiBAcmV0dXJucyB7dXRpbC5Mb25nQml0c30gSW5zdGFuY2VcbiAqL1xuTG9uZ0JpdHMuZnJvbU51bWJlciA9IGZ1bmN0aW9uIGZyb21OdW1iZXIodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IDApXG4gICAgICAgIHJldHVybiB6ZXJvO1xuICAgIHZhciBzaWduID0gdmFsdWUgPCAwO1xuICAgIGlmIChzaWduKVxuICAgICAgICB2YWx1ZSA9IC12YWx1ZTtcbiAgICB2YXIgbG8gPSB2YWx1ZSA+Pj4gMCxcbiAgICAgICAgaGkgPSAodmFsdWUgLSBsbykgLyA0Mjk0OTY3Mjk2ID4+PiAwO1xuICAgIGlmIChzaWduKSB7XG4gICAgICAgIGhpID0gfmhpID4+PiAwO1xuICAgICAgICBsbyA9IH5sbyA+Pj4gMDtcbiAgICAgICAgaWYgKCsrbG8gPiA0Mjk0OTY3Mjk1KSB7XG4gICAgICAgICAgICBsbyA9IDA7XG4gICAgICAgICAgICBpZiAoKytoaSA+IDQyOTQ5NjcyOTUpXG4gICAgICAgICAgICAgICAgaGkgPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgTG9uZ0JpdHMobG8sIGhpKTtcbn07XG5cbi8qKlxuICogQ29uc3RydWN0cyBuZXcgbG9uZyBiaXRzIGZyb20gYSBudW1iZXIsIGxvbmcgb3Igc3RyaW5nLlxuICogQHBhcmFtIHtMb25nfG51bWJlcnxzdHJpbmd9IHZhbHVlIFZhbHVlXG4gKiBAcmV0dXJucyB7dXRpbC5Mb25nQml0c30gSW5zdGFuY2VcbiAqL1xuTG9uZ0JpdHMuZnJvbSA9IGZ1bmN0aW9uIGZyb20odmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKVxuICAgICAgICByZXR1cm4gTG9uZ0JpdHMuZnJvbU51bWJlcih2YWx1ZSk7XG4gICAgaWYgKHV0aWwuaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmICh1dGlsLkxvbmcpXG4gICAgICAgICAgICB2YWx1ZSA9IHV0aWwuTG9uZy5mcm9tU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIExvbmdCaXRzLmZyb21OdW1iZXIocGFyc2VJbnQodmFsdWUsIDEwKSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZS5sb3cgfHwgdmFsdWUuaGlnaCA/IG5ldyBMb25nQml0cyh2YWx1ZS5sb3cgPj4+IDAsIHZhbHVlLmhpZ2ggPj4+IDApIDogemVybztcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBsb25nIGJpdHMgdG8gYSBwb3NzaWJseSB1bnNhZmUgSmF2YVNjcmlwdCBudW1iZXIuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt1bnNpZ25lZD1mYWxzZV0gV2hldGhlciB1bnNpZ25lZCBvciBub3RcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFBvc3NpYmx5IHVuc2FmZSBudW1iZXJcbiAqL1xuTG9uZ0JpdHMucHJvdG90eXBlLnRvTnVtYmVyID0gZnVuY3Rpb24gdG9OdW1iZXIodW5zaWduZWQpIHtcbiAgICBpZiAoIXVuc2lnbmVkICYmIHRoaXMuaGkgPj4+IDMxKSB7XG4gICAgICAgIHZhciBsbyA9IH50aGlzLmxvICsgMSA+Pj4gMCxcbiAgICAgICAgICAgIGhpID0gfnRoaXMuaGkgICAgID4+PiAwO1xuICAgICAgICBpZiAoIWxvKVxuICAgICAgICAgICAgaGkgPSBoaSArIDEgPj4+IDA7XG4gICAgICAgIHJldHVybiAtKGxvICsgaGkgKiA0Mjk0OTY3Mjk2KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubG8gKyB0aGlzLmhpICogNDI5NDk2NzI5Njtcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBsb25nIGJpdHMgdG8gYSBsb25nLlxuICogQHBhcmFtIHtib29sZWFufSBbdW5zaWduZWQ9ZmFsc2VdIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90XG4gKiBAcmV0dXJucyB7TG9uZ30gTG9uZ1xuICovXG5Mb25nQml0cy5wcm90b3R5cGUudG9Mb25nID0gZnVuY3Rpb24gdG9Mb25nKHVuc2lnbmVkKSB7XG4gICAgcmV0dXJuIHV0aWwuTG9uZ1xuICAgICAgICA/IG5ldyB1dGlsLkxvbmcodGhpcy5sbyB8IDAsIHRoaXMuaGkgfCAwLCBCb29sZWFuKHVuc2lnbmVkKSlcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgOiB7IGxvdzogdGhpcy5sbyB8IDAsIGhpZ2g6IHRoaXMuaGkgfCAwLCB1bnNpZ25lZDogQm9vbGVhbih1bnNpZ25lZCkgfTtcbn07XG5cbnZhciBjaGFyQ29kZUF0ID0gU3RyaW5nLnByb3RvdHlwZS5jaGFyQ29kZUF0O1xuXG4vKipcbiAqIENvbnN0cnVjdHMgbmV3IGxvbmcgYml0cyBmcm9tIHRoZSBzcGVjaWZpZWQgOCBjaGFyYWN0ZXJzIGxvbmcgaGFzaC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBoYXNoIEhhc2hcbiAqIEByZXR1cm5zIHt1dGlsLkxvbmdCaXRzfSBCaXRzXG4gKi9cbkxvbmdCaXRzLmZyb21IYXNoID0gZnVuY3Rpb24gZnJvbUhhc2goaGFzaCkge1xuICAgIGlmIChoYXNoID09PSB6ZXJvSGFzaClcbiAgICAgICAgcmV0dXJuIHplcm87XG4gICAgcmV0dXJuIG5ldyBMb25nQml0cyhcbiAgICAgICAgKCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgMClcbiAgICAgICAgfCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgMSkgPDwgOFxuICAgICAgICB8IGNoYXJDb2RlQXQuY2FsbChoYXNoLCAyKSA8PCAxNlxuICAgICAgICB8IGNoYXJDb2RlQXQuY2FsbChoYXNoLCAzKSA8PCAyNCkgPj4+IDBcbiAgICAsXG4gICAgICAgICggY2hhckNvZGVBdC5jYWxsKGhhc2gsIDQpXG4gICAgICAgIHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDUpIDw8IDhcbiAgICAgICAgfCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgNikgPDwgMTZcbiAgICAgICAgfCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgNykgPDwgMjQpID4+PiAwXG4gICAgKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBsb25nIGJpdHMgdG8gYSA4IGNoYXJhY3RlcnMgbG9uZyBoYXNoLlxuICogQHJldHVybnMge3N0cmluZ30gSGFzaFxuICovXG5Mb25nQml0cy5wcm90b3R5cGUudG9IYXNoID0gZnVuY3Rpb24gdG9IYXNoKCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKFxuICAgICAgICB0aGlzLmxvICAgICAgICAmIDI1NSxcbiAgICAgICAgdGhpcy5sbyA+Pj4gOCAgJiAyNTUsXG4gICAgICAgIHRoaXMubG8gPj4+IDE2ICYgMjU1LFxuICAgICAgICB0aGlzLmxvID4+PiAyNCAgICAgICxcbiAgICAgICAgdGhpcy5oaSAgICAgICAgJiAyNTUsXG4gICAgICAgIHRoaXMuaGkgPj4+IDggICYgMjU1LFxuICAgICAgICB0aGlzLmhpID4+PiAxNiAmIDI1NSxcbiAgICAgICAgdGhpcy5oaSA+Pj4gMjRcbiAgICApO1xufTtcblxuLyoqXG4gKiBaaWctemFnIGVuY29kZXMgdGhpcyBsb25nIGJpdHMuXG4gKiBAcmV0dXJucyB7dXRpbC5Mb25nQml0c30gYHRoaXNgXG4gKi9cbkxvbmdCaXRzLnByb3RvdHlwZS56ekVuY29kZSA9IGZ1bmN0aW9uIHp6RW5jb2RlKCkge1xuICAgIHZhciBtYXNrID0gICB0aGlzLmhpID4+IDMxO1xuICAgIHRoaXMuaGkgID0gKCh0aGlzLmhpIDw8IDEgfCB0aGlzLmxvID4+PiAzMSkgXiBtYXNrKSA+Pj4gMDtcbiAgICB0aGlzLmxvICA9ICggdGhpcy5sbyA8PCAxICAgICAgICAgICAgICAgICAgIF4gbWFzaykgPj4+IDA7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFppZy16YWcgZGVjb2RlcyB0aGlzIGxvbmcgYml0cy5cbiAqIEByZXR1cm5zIHt1dGlsLkxvbmdCaXRzfSBgdGhpc2BcbiAqL1xuTG9uZ0JpdHMucHJvdG90eXBlLnp6RGVjb2RlID0gZnVuY3Rpb24genpEZWNvZGUoKSB7XG4gICAgdmFyIG1hc2sgPSAtKHRoaXMubG8gJiAxKTtcbiAgICB0aGlzLmxvICA9ICgodGhpcy5sbyA+Pj4gMSB8IHRoaXMuaGkgPDwgMzEpIF4gbWFzaykgPj4+IDA7XG4gICAgdGhpcy5oaSAgPSAoIHRoaXMuaGkgPj4+IDEgICAgICAgICAgICAgICAgICBeIG1hc2spID4+PiAwO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgdGhpcyBsb25nYml0cyB3aGVuIGVuY29kZWQgYXMgYSB2YXJpbnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBMZW5ndGhcbiAqL1xuTG9uZ0JpdHMucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uIGxlbmd0aCgpIHtcbiAgICB2YXIgcGFydDAgPSAgdGhpcy5sbyxcbiAgICAgICAgcGFydDEgPSAodGhpcy5sbyA+Pj4gMjggfCB0aGlzLmhpIDw8IDQpID4+PiAwLFxuICAgICAgICBwYXJ0MiA9ICB0aGlzLmhpID4+PiAyNDtcbiAgICByZXR1cm4gcGFydDIgPT09IDBcbiAgICAgICAgID8gcGFydDEgPT09IDBcbiAgICAgICAgICAgPyBwYXJ0MCA8IDE2Mzg0XG4gICAgICAgICAgICAgPyBwYXJ0MCA8IDEyOCA/IDEgOiAyXG4gICAgICAgICAgICAgOiBwYXJ0MCA8IDIwOTcxNTIgPyAzIDogNFxuICAgICAgICAgICA6IHBhcnQxIDwgMTYzODRcbiAgICAgICAgICAgICA/IHBhcnQxIDwgMTI4ID8gNSA6IDZcbiAgICAgICAgICAgICA6IHBhcnQxIDwgMjA5NzE1MiA/IDcgOiA4XG4gICAgICAgICA6IHBhcnQyIDwgMTI4ID8gOSA6IDEwO1xufTtcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwiTG9uZ0JpdHMiLCJ1dGlsIiwicmVxdWlyZSIsImxvIiwiaGkiLCJ6ZXJvIiwidG9OdW1iZXIiLCJ6ekVuY29kZSIsInp6RGVjb2RlIiwibGVuZ3RoIiwiemVyb0hhc2giLCJmcm9tTnVtYmVyIiwidmFsdWUiLCJzaWduIiwiZnJvbSIsImlzU3RyaW5nIiwiTG9uZyIsImZyb21TdHJpbmciLCJwYXJzZUludCIsImxvdyIsImhpZ2giLCJwcm90b3R5cGUiLCJ1bnNpZ25lZCIsInRvTG9uZyIsIkJvb2xlYW4iLCJjaGFyQ29kZUF0IiwiU3RyaW5nIiwiZnJvbUhhc2giLCJoYXNoIiwiY2FsbCIsInRvSGFzaCIsImZyb21DaGFyQ29kZSIsIm1hc2siLCJwYXJ0MCIsInBhcnQxIiwicGFydDIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/protobufjs/src/util/longbits.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/src/util/minimal.js":
/*!******************************************************!*\
  !*** ../node_modules/protobufjs/src/util/minimal.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar util = exports;\n// used to return a Promise where callback is omitted\nutil.asPromise = __webpack_require__(/*! @protobufjs/aspromise */ \"(ssr)/../node_modules/@protobufjs/aspromise/index.js\");\n// converts to / from base64 encoded strings\nutil.base64 = __webpack_require__(/*! @protobufjs/base64 */ \"(ssr)/../node_modules/@protobufjs/base64/index.js\");\n// base class of rpc.Service\nutil.EventEmitter = __webpack_require__(/*! @protobufjs/eventemitter */ \"(ssr)/../node_modules/@protobufjs/eventemitter/index.js\");\n// float handling accross browsers\nutil.float = __webpack_require__(/*! @protobufjs/float */ \"(ssr)/../node_modules/@protobufjs/float/index.js\");\n// requires modules optionally and hides the call from bundlers\nutil.inquire = __webpack_require__(/*! @protobufjs/inquire */ \"(ssr)/../node_modules/@protobufjs/inquire/index.js\");\n// converts to / from utf8 encoded strings\nutil.utf8 = __webpack_require__(/*! @protobufjs/utf8 */ \"(ssr)/../node_modules/@protobufjs/utf8/index.js\");\n// provides a node-like buffer pool in the browser\nutil.pool = __webpack_require__(/*! @protobufjs/pool */ \"(ssr)/../node_modules/@protobufjs/pool/index.js\");\n// utility to work with the low and high bits of a 64 bit value\nutil.LongBits = __webpack_require__(/*! ./longbits */ \"(ssr)/../node_modules/protobufjs/src/util/longbits.js\");\n/**\n * Whether running within node or not.\n * @memberof util\n * @type {boolean}\n */ util.isNode = Boolean(typeof global !== \"undefined\" && global && global.process && global.process.versions && global.process.versions.node);\n/**\n * Global object reference.\n * @memberof util\n * @type {Object}\n */ util.global = util.isNode && global ||  false && 0 || typeof self !== \"undefined\" && self || this; // eslint-disable-line no-invalid-this\n/**\n * An immuable empty array.\n * @memberof util\n * @type {Array.<*>}\n * @const\n */ util.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes\n/**\n * An immutable empty object.\n * @type {Object}\n * @const\n */ util.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes\n/**\n * Tests if the specified value is an integer.\n * @function\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is an integer\n */ util.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {\n    return typeof value === \"number\" && isFinite(value) && Math.floor(value) === value;\n};\n/**\n * Tests if the specified value is a string.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a string\n */ util.isString = function isString(value) {\n    return typeof value === \"string\" || value instanceof String;\n};\n/**\n * Tests if the specified value is a non-null object.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a non-null object\n */ util.isObject = function isObject(value) {\n    return value && typeof value === \"object\";\n};\n/**\n * Checks if a property on a message is considered to be present.\n * This is an alias of {@link util.isSet}.\n * @function\n * @param {Object} obj Plain object or message instance\n * @param {string} prop Property name\n * @returns {boolean} `true` if considered to be present, otherwise `false`\n */ util.isset = /**\n * Checks if a property on a message is considered to be present.\n * @param {Object} obj Plain object or message instance\n * @param {string} prop Property name\n * @returns {boolean} `true` if considered to be present, otherwise `false`\n */ util.isSet = function isSet(obj, prop) {\n    var value = obj[prop];\n    if (value != null && obj.hasOwnProperty(prop)) return typeof value !== \"object\" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;\n    return false;\n};\n/**\n * Any compatible Buffer instance.\n * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.\n * @interface Buffer\n * @extends Uint8Array\n */ /**\n * Node's Buffer class if available.\n * @type {Constructor<Buffer>}\n */ util.Buffer = function() {\n    try {\n        var Buffer = util.inquire(\"buffer\").Buffer;\n        // refuse to use non-node buffers if not explicitly assigned (perf reasons):\n        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;\n    } catch (e) {\n        /* istanbul ignore next */ return null;\n    }\n}();\n// Internal alias of or polyfull for Buffer.from.\nutil._Buffer_from = null;\n// Internal alias of or polyfill for Buffer.allocUnsafe.\nutil._Buffer_allocUnsafe = null;\n/**\n * Creates a new buffer of whatever type supported by the environment.\n * @param {number|number[]} [sizeOrArray=0] Buffer size or number array\n * @returns {Uint8Array|Buffer} Buffer\n */ util.newBuffer = function newBuffer(sizeOrArray) {\n    /* istanbul ignore next */ return typeof sizeOrArray === \"number\" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === \"undefined\" ? sizeOrArray : new Uint8Array(sizeOrArray);\n};\n/**\n * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.\n * @type {Constructor<Uint8Array>}\n */ util.Array = typeof Uint8Array !== \"undefined\" ? Uint8Array /* istanbul ignore next */  : Array;\n/**\n * Any compatible Long instance.\n * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.\n * @interface Long\n * @property {number} low Low bits\n * @property {number} high High bits\n * @property {boolean} unsigned Whether unsigned or not\n */ /**\n * Long.js's Long class if available.\n * @type {Constructor<Long>}\n */ util.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long || /* istanbul ignore next */ util.global.Long || util.inquire(\"long\");\n/**\n * Regular expression used to verify 2 bit (`bool`) map keys.\n * @type {RegExp}\n * @const\n */ util.key2Re = /^true|false|0|1$/;\n/**\n * Regular expression used to verify 32 bit (`int32` etc.) map keys.\n * @type {RegExp}\n * @const\n */ util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;\n/**\n * Regular expression used to verify 64 bit (`int64` etc.) map keys.\n * @type {RegExp}\n * @const\n */ util.key64Re = /^(?:[\\\\x00-\\\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;\n/**\n * Converts a number or long to an 8 characters long hash string.\n * @param {Long|number} value Value to convert\n * @returns {string} Hash\n */ util.longToHash = function longToHash(value) {\n    return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;\n};\n/**\n * Converts an 8 characters long hash string to a long or number.\n * @param {string} hash Hash\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {Long|number} Original value\n */ util.longFromHash = function longFromHash(hash, unsigned) {\n    var bits = util.LongBits.fromHash(hash);\n    if (util.Long) return util.Long.fromBits(bits.lo, bits.hi, unsigned);\n    return bits.toNumber(Boolean(unsigned));\n};\n/**\n * Merges the properties of the source object into the destination object.\n * @memberof util\n * @param {Object.<string,*>} dst Destination object\n * @param {Object.<string,*>} src Source object\n * @param {boolean} [ifNotSet=false] Merges only if the key is not already set\n * @returns {Object.<string,*>} Destination object\n */ function merge(dst, src, ifNotSet) {\n    for(var keys = Object.keys(src), i = 0; i < keys.length; ++i)if (dst[keys[i]] === undefined || !ifNotSet) dst[keys[i]] = src[keys[i]];\n    return dst;\n}\nutil.merge = merge;\n/**\n * Converts the first character of a string to lower case.\n * @param {string} str String to convert\n * @returns {string} Converted string\n */ util.lcFirst = function lcFirst(str) {\n    return str.charAt(0).toLowerCase() + str.substring(1);\n};\n/**\n * Creates a custom error constructor.\n * @memberof util\n * @param {string} name Error name\n * @returns {Constructor<Error>} Custom error constructor\n */ function newError(name) {\n    function CustomError(message, properties) {\n        if (!(this instanceof CustomError)) return new CustomError(message, properties);\n        // Error.call(this, message);\n        // ^ just returns a new error instance because the ctor can be called as a function\n        Object.defineProperty(this, \"message\", {\n            get: function() {\n                return message;\n            }\n        });\n        /* istanbul ignore next */ if (Error.captureStackTrace) Error.captureStackTrace(this, CustomError);\n        else Object.defineProperty(this, \"stack\", {\n            value: new Error().stack || \"\"\n        });\n        if (properties) merge(this, properties);\n    }\n    CustomError.prototype = Object.create(Error.prototype, {\n        constructor: {\n            value: CustomError,\n            writable: true,\n            enumerable: false,\n            configurable: true\n        },\n        name: {\n            get: function get() {\n                return name;\n            },\n            set: undefined,\n            enumerable: false,\n            // configurable: false would accurately preserve the behavior of\n            // the original, but I'm guessing that was not intentional.\n            // For an actual error subclass, this property would\n            // be configurable.\n            configurable: true\n        },\n        toString: {\n            value: function value() {\n                return this.name + \": \" + this.message;\n            },\n            writable: true,\n            enumerable: false,\n            configurable: true\n        }\n    });\n    return CustomError;\n}\nutil.newError = newError;\n/**\n * Constructs a new protocol error.\n * @classdesc Error subclass indicating a protocol specifc error.\n * @memberof util\n * @extends Error\n * @template T extends Message<T>\n * @constructor\n * @param {string} message Error message\n * @param {Object.<string,*>} [properties] Additional properties\n * @example\n * try {\n *     MyMessage.decode(someBuffer); // throws if required fields are missing\n * } catch (e) {\n *     if (e instanceof ProtocolError && e.instance)\n *         console.log(\"decoded so far: \" + JSON.stringify(e.instance));\n * }\n */ util.ProtocolError = newError(\"ProtocolError\");\n/**\n * So far decoded message instance.\n * @name util.ProtocolError#instance\n * @type {Message<T>}\n */ /**\n * A OneOf getter as returned by {@link util.oneOfGetter}.\n * @typedef OneOfGetter\n * @type {function}\n * @returns {string|undefined} Set field name, if any\n */ /**\n * Builds a getter for a oneof's present field name.\n * @param {string[]} fieldNames Field names\n * @returns {OneOfGetter} Unbound getter\n */ util.oneOfGetter = function getOneOf(fieldNames) {\n    var fieldMap = {};\n    for(var i = 0; i < fieldNames.length; ++i)fieldMap[fieldNames[i]] = 1;\n    /**\n     * @returns {string|undefined} Set field name, if any\n     * @this Object\n     * @ignore\n     */ return function() {\n        for(var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null) return keys[i];\n    };\n};\n/**\n * A OneOf setter as returned by {@link util.oneOfSetter}.\n * @typedef OneOfSetter\n * @type {function}\n * @param {string|undefined} value Field name\n * @returns {undefined}\n */ /**\n * Builds a setter for a oneof's present field name.\n * @param {string[]} fieldNames Field names\n * @returns {OneOfSetter} Unbound setter\n */ util.oneOfSetter = function setOneOf(fieldNames) {\n    /**\n     * @param {string} name Field name\n     * @returns {undefined}\n     * @this Object\n     * @ignore\n     */ return function(name) {\n        for(var i = 0; i < fieldNames.length; ++i)if (fieldNames[i] !== name) delete this[fieldNames[i]];\n    };\n};\n/**\n * Default conversion options used for {@link Message#toJSON} implementations.\n *\n * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:\n *\n * - Longs become strings\n * - Enums become string keys\n * - Bytes become base64 encoded strings\n * - (Sub-)Messages become plain objects\n * - Maps become plain objects with all string keys\n * - Repeated fields become arrays\n * - NaN and Infinity for float and double fields become strings\n *\n * @type {IConversionOptions}\n * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json\n */ util.toJSONOptions = {\n    longs: String,\n    enums: String,\n    bytes: String,\n    json: true\n};\n// Sets up buffer utility according to the environment (called in index-minimal)\nutil._configure = function() {\n    var Buffer = util.Buffer;\n    /* istanbul ignore if */ if (!Buffer) {\n        util._Buffer_from = util._Buffer_allocUnsafe = null;\n        return;\n    }\n    // because node 4.x buffers are incompatible & immutable\n    // see: https://github.com/dcodeIO/protobuf.js/pull/665\n    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from || /* istanbul ignore next */ function Buffer_from(value, encoding) {\n        return new Buffer(value, encoding);\n    };\n    util._Buffer_allocUnsafe = Buffer.allocUnsafe || /* istanbul ignore next */ function Buffer_allocUnsafe(size) {\n        return new Buffer(size);\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3V0aWwvbWluaW1hbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLE9BQU9DO0FBRVgscURBQXFEO0FBQ3JERCxLQUFLRSxTQUFTLEdBQUdDLG1CQUFPQSxDQUFDLG1GQUF1QjtBQUVoRCw0Q0FBNEM7QUFDNUNILEtBQUtJLE1BQU0sR0FBR0QsbUJBQU9BLENBQUMsNkVBQW9CO0FBRTFDLDRCQUE0QjtBQUM1QkgsS0FBS0ssWUFBWSxHQUFHRixtQkFBT0EsQ0FBQyx5RkFBMEI7QUFFdEQsa0NBQWtDO0FBQ2xDSCxLQUFLTSxLQUFLLEdBQUdILG1CQUFPQSxDQUFDLDJFQUFtQjtBQUV4QywrREFBK0Q7QUFDL0RILEtBQUtPLE9BQU8sR0FBR0osbUJBQU9BLENBQUMsK0VBQXFCO0FBRTVDLDBDQUEwQztBQUMxQ0gsS0FBS1EsSUFBSSxHQUFHTCxtQkFBT0EsQ0FBQyx5RUFBa0I7QUFFdEMsa0RBQWtEO0FBQ2xESCxLQUFLUyxJQUFJLEdBQUdOLG1CQUFPQSxDQUFDLHlFQUFrQjtBQUV0QywrREFBK0Q7QUFDL0RILEtBQUtVLFFBQVEsR0FBR1AsbUJBQU9BLENBQUMseUVBQVk7QUFFcEM7Ozs7Q0FJQyxHQUNESCxLQUFLVyxNQUFNLEdBQUdDLFFBQVEsT0FBT0MsV0FBVyxlQUNsQkEsVUFDQUEsT0FBT0MsT0FBTyxJQUNkRCxPQUFPQyxPQUFPLENBQUNDLFFBQVEsSUFDdkJGLE9BQU9DLE9BQU8sQ0FBQ0MsUUFBUSxDQUFDQyxJQUFJO0FBRWxEOzs7O0NBSUMsR0FDRGhCLEtBQUthLE1BQU0sR0FBR2IsS0FBS1csTUFBTSxJQUFJRSxVQUNmLE1BQTZCLElBQUlJLENBQU1BLElBQ3ZDLE9BQU9DLFNBQVcsZUFBZUEsUUFDakMsSUFBSSxFQUFFLHNDQUFzQztBQUUxRDs7Ozs7Q0FLQyxHQUNEbEIsS0FBS21CLFVBQVUsR0FBR0MsT0FBT0MsTUFBTSxHQUFHRCxPQUFPQyxNQUFNLENBQUMsRUFB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LEdBQ3RCLElBQUksQ0FBQ0EsUUFBUTtRQUNUekMsS0FBSzZDLFlBQVksR0FBRzdDLEtBQUs4QyxtQkFBbUIsR0FBRztRQUMvQztJQUNKO0lBQ0Esd0RBQXdEO0lBQ3hELHVEQUF1RDtJQUN2RDlDLEtBQUs2QyxZQUFZLEdBQUdKLE9BQU9lLElBQUksS0FBS1AsV0FBV08sSUFBSSxJQUFJZixPQUFPZSxJQUFJLElBQzlELHdCQUF3QixHQUN4QixTQUFTcUQsWUFBWXBGLEtBQUssRUFBRXFGLFFBQVE7UUFDaEMsT0FBTyxJQUFJckUsT0FBT2hCLE9BQU9xRjtJQUM3QjtJQUNKOUcsS0FBSzhDLG1CQUFtQixHQUFHTCxPQUFPc0UsV0FBVyxJQUN6Qyx3QkFBd0IsR0FDeEIsU0FBU0MsbUJBQW1CQyxJQUFJO1FBQzVCLE9BQU8sSUFBSXhFLE9BQU93RTtJQUN0QjtBQUNSIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy91dGlsL21pbmltYWwuanM/MDNkZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciB1dGlsID0gZXhwb3J0cztcblxuLy8gdXNlZCB0byByZXR1cm4gYSBQcm9taXNlIHdoZXJlIGNhbGxiYWNrIGlzIG9taXR0ZWRcbnV0aWwuYXNQcm9taXNlID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL2FzcHJvbWlzZVwiKTtcblxuLy8gY29udmVydHMgdG8gLyBmcm9tIGJhc2U2NCBlbmNvZGVkIHN0cmluZ3NcbnV0aWwuYmFzZTY0ID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL2Jhc2U2NFwiKTtcblxuLy8gYmFzZSBjbGFzcyBvZiBycGMuU2VydmljZVxudXRpbC5FdmVudEVtaXR0ZXIgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvZXZlbnRlbWl0dGVyXCIpO1xuXG4vLyBmbG9hdCBoYW5kbGluZyBhY2Nyb3NzIGJyb3dzZXJzXG51dGlsLmZsb2F0ID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL2Zsb2F0XCIpO1xuXG4vLyByZXF1aXJlcyBtb2R1bGVzIG9wdGlvbmFsbHkgYW5kIGhpZGVzIHRoZSBjYWxsIGZyb20gYnVuZGxlcnNcbnV0aWwuaW5xdWlyZSA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9pbnF1aXJlXCIpO1xuXG4vLyBjb252ZXJ0cyB0byAvIGZyb20gdXRmOCBlbmNvZGVkIHN0cmluZ3NcbnV0aWwudXRmOCA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy91dGY4XCIpO1xuXG4vLyBwcm92aWRlcyBhIG5vZGUtbGlrZSBidWZmZXIgcG9vbCBpbiB0aGUgYnJvd3NlclxudXRpbC5wb29sID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL3Bvb2xcIik7XG5cbi8vIHV0aWxpdHkgdG8gd29yayB3aXRoIHRoZSBsb3cgYW5kIGhpZ2ggYml0cyBvZiBhIDY0IGJpdCB2YWx1ZVxudXRpbC5Mb25nQml0cyA9IHJlcXVpcmUoXCIuL2xvbmdiaXRzXCIpO1xuXG4vKipcbiAqIFdoZXRoZXIgcnVubmluZyB3aXRoaW4gbm9kZSBvciBub3QuXG4gKiBAbWVtYmVyb2YgdXRpbFxuICogQHR5cGUge2Jvb2xlYW59XG4gKi9cbnV0aWwuaXNOb2RlID0gQm9vbGVhbih0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiXG4gICAgICAgICAgICAgICAgICAgJiYgZ2xvYmFsXG4gICAgICAgICAgICAgICAgICAgJiYgZ2xvYmFsLnByb2Nlc3NcbiAgICAgICAgICAgICAgICAgICAmJiBnbG9iYWwucHJvY2Vzcy52ZXJzaW9uc1xuICAgICAgICAgICAgICAgICAgICYmIGdsb2JhbC5wcm9jZXNzLnZlcnNpb25zLm5vZGUpO1xuXG4vKipcbiAqIEdsb2JhbCBvYmplY3QgcmVmZXJlbmNlLlxuICogQG1lbWJlcm9mIHV0aWxcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbnV0aWwuZ2xvYmFsID0gdXRpbC5pc05vZGUgJiYgZ2xvYmFsXG4gICAgICAgICAgIHx8IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93XG4gICAgICAgICAgIHx8IHR5cGVvZiBzZWxmICAgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZlxuICAgICAgICAgICB8fCB0aGlzOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWludmFsaWQtdGhpc1xuXG4vKipcbiAqIEFuIGltbXVhYmxlIGVtcHR5IGFycmF5LlxuICogQG1lbWJlcm9mIHV0aWxcbiAqIEB0eXBlIHtBcnJheS48Kj59XG4gKiBAY29uc3RcbiAqL1xudXRpbC5lbXB0eUFycmF5ID0gT2JqZWN0LmZyZWV6ZSA/IE9iamVjdC5mcmVlemUoW10pIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gW107IC8vIHVzZWQgb24gcHJvdG90eXBlc1xuXG4vKipcbiAqIEFuIGltbXV0YWJsZSBlbXB0eSBvYmplY3QuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQGNvbnN0XG4gKi9cbnV0aWwuZW1wdHlPYmplY3QgPSBPYmplY3QuZnJlZXplID8gT2JqZWN0LmZyZWV6ZSh7fSkgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB7fTsgLy8gdXNlZCBvbiBwcm90b3R5cGVzXG5cbi8qKlxuICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhbiBpbnRlZ2VyLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIGFuIGludGVnZXJcbiAqL1xudXRpbC5pc0ludGVnZXIgPSBOdW1iZXIuaXNJbnRlZ2VyIHx8IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGZ1bmN0aW9uIGlzSW50ZWdlcih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgJiYgaXNGaW5pdGUodmFsdWUpICYmIE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZTtcbn07XG5cbi8qKlxuICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhIHN0cmluZy5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgYSBzdHJpbmdcbiAqL1xudXRpbC5pc1N0cmluZyA9IGZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiB8fCB2YWx1ZSBpbnN0YW5jZW9mIFN0cmluZztcbn07XG5cbi8qKlxuICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhIG5vbi1udWxsIG9iamVjdC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgYSBub24tbnVsbCBvYmplY3RcbiAqL1xudXRpbC5pc09iamVjdCA9IGZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIjtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgcHJvcGVydHkgb24gYSBtZXNzYWdlIGlzIGNvbnNpZGVyZWQgdG8gYmUgcHJlc2VudC5cbiAqIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIHV0aWwuaXNTZXR9LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFBsYWluIG9iamVjdCBvciBtZXNzYWdlIGluc3RhbmNlXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBQcm9wZXJ0eSBuYW1lXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIGNvbnNpZGVyZWQgdG8gYmUgcHJlc2VudCwgb3RoZXJ3aXNlIGBmYWxzZWBcbiAqL1xudXRpbC5pc3NldCA9XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgcHJvcGVydHkgb24gYSBtZXNzYWdlIGlzIGNvbnNpZGVyZWQgdG8gYmUgcHJlc2VudC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogUGxhaW4gb2JqZWN0IG9yIG1lc3NhZ2UgaW5zdGFuY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIFByb3BlcnR5IG5hbWVcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgY29uc2lkZXJlZCB0byBiZSBwcmVzZW50LCBvdGhlcndpc2UgYGZhbHNlYFxuICovXG51dGlsLmlzU2V0ID0gZnVuY3Rpb24gaXNTZXQob2JqLCBwcm9wKSB7XG4gICAgdmFyIHZhbHVlID0gb2JqW3Byb3BdO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsICYmIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXEsIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IChBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLmxlbmd0aCA6IE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGgpID4gMDtcbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIEFueSBjb21wYXRpYmxlIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIFRoaXMgaXMgYSBtaW5pbWFsIHN0YW5kLWFsb25lIGRlZmluaXRpb24gb2YgYSBCdWZmZXIgaW5zdGFuY2UuIFRoZSBhY3R1YWwgdHlwZSBpcyB0aGF0IGV4cG9ydGVkIGJ5IG5vZGUncyB0eXBpbmdzLlxuICogQGludGVyZmFjZSBCdWZmZXJcbiAqIEBleHRlbmRzIFVpbnQ4QXJyYXlcbiAqL1xuXG4vKipcbiAqIE5vZGUncyBCdWZmZXIgY2xhc3MgaWYgYXZhaWxhYmxlLlxuICogQHR5cGUge0NvbnN0cnVjdG9yPEJ1ZmZlcj59XG4gKi9cbnV0aWwuQnVmZmVyID0gKGZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICAgIHZhciBCdWZmZXIgPSB1dGlsLmlucXVpcmUoXCJidWZmZXJcIikuQnVmZmVyO1xuICAgICAgICAvLyByZWZ1c2UgdG8gdXNlIG5vbi1ub2RlIGJ1ZmZlcnMgaWYgbm90IGV4cGxpY2l0bHkgYXNzaWduZWQgKHBlcmYgcmVhc29ucyk6XG4gICAgICAgIHJldHVybiBCdWZmZXIucHJvdG90eXBlLnV0ZjhXcml0ZSA/IEJ1ZmZlciA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIG51bGw7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59KSgpO1xuXG4vLyBJbnRlcm5hbCBhbGlhcyBvZiBvciBwb2x5ZnVsbCBmb3IgQnVmZmVyLmZyb20uXG51dGlsLl9CdWZmZXJfZnJvbSA9IG51bGw7XG5cbi8vIEludGVybmFsIGFsaWFzIG9mIG9yIHBvbHlmaWxsIGZvciBCdWZmZXIuYWxsb2NVbnNhZmUuXG51dGlsLl9CdWZmZXJfYWxsb2NVbnNhZmUgPSBudWxsO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgYnVmZmVyIG9mIHdoYXRldmVyIHR5cGUgc3VwcG9ydGVkIGJ5IHRoZSBlbnZpcm9ubWVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfG51bWJlcltdfSBbc2l6ZU9yQXJyYXk9MF0gQnVmZmVyIHNpemUgb3IgbnVtYmVyIGFycmF5XG4gKiBAcmV0dXJucyB7VWludDhBcnJheXxCdWZmZXJ9IEJ1ZmZlclxuICovXG51dGlsLm5ld0J1ZmZlciA9IGZ1bmN0aW9uIG5ld0J1ZmZlcihzaXplT3JBcnJheSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcmV0dXJuIHR5cGVvZiBzaXplT3JBcnJheSA9PT0gXCJudW1iZXJcIlxuICAgICAgICA/IHV0aWwuQnVmZmVyXG4gICAgICAgICAgICA/IHV0aWwuX0J1ZmZlcl9hbGxvY1Vuc2FmZShzaXplT3JBcnJheSlcbiAgICAgICAgICAgIDogbmV3IHV0aWwuQXJyYXkoc2l6ZU9yQXJyYXkpXG4gICAgICAgIDogdXRpbC5CdWZmZXJcbiAgICAgICAgICAgID8gdXRpbC5fQnVmZmVyX2Zyb20oc2l6ZU9yQXJyYXkpXG4gICAgICAgICAgICA6IHR5cGVvZiBVaW50OEFycmF5ID09PSBcInVuZGVmaW5lZFwiXG4gICAgICAgICAgICAgICAgPyBzaXplT3JBcnJheVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoc2l6ZU9yQXJyYXkpO1xufTtcblxuLyoqXG4gKiBBcnJheSBpbXBsZW1lbnRhdGlvbiB1c2VkIGluIHRoZSBicm93c2VyLiBgVWludDhBcnJheWAgaWYgc3VwcG9ydGVkLCBvdGhlcndpc2UgYEFycmF5YC5cbiAqIEB0eXBlIHtDb25zdHJ1Y3RvcjxVaW50OEFycmF5Pn1cbiAqL1xudXRpbC5BcnJheSA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSBcInVuZGVmaW5lZFwiID8gVWludDhBcnJheSAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyA6IEFycmF5O1xuXG4vKipcbiAqIEFueSBjb21wYXRpYmxlIExvbmcgaW5zdGFuY2UuXG4gKiBUaGlzIGlzIGEgbWluaW1hbCBzdGFuZC1hbG9uZSBkZWZpbml0aW9uIG9mIGEgTG9uZyBpbnN0YW5jZS4gVGhlIGFjdHVhbCB0eXBlIGlzIHRoYXQgZXhwb3J0ZWQgYnkgbG9uZy5qcy5cbiAqIEBpbnRlcmZhY2UgTG9uZ1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGxvdyBMb3cgYml0c1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGhpZ2ggSGlnaCBiaXRzXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90XG4gKi9cblxuLyoqXG4gKiBMb25nLmpzJ3MgTG9uZyBjbGFzcyBpZiBhdmFpbGFibGUuXG4gKiBAdHlwZSB7Q29uc3RydWN0b3I8TG9uZz59XG4gKi9cbnV0aWwuTG9uZyA9IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHV0aWwuZ2xvYmFsLmRjb2RlSU8gJiYgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gdXRpbC5nbG9iYWwuZGNvZGVJTy5Mb25nXG4gICAgICAgICB8fCAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB1dGlsLmdsb2JhbC5Mb25nXG4gICAgICAgICB8fCB1dGlsLmlucXVpcmUoXCJsb25nXCIpO1xuXG4vKipcbiAqIFJlZ3VsYXIgZXhwcmVzc2lvbiB1c2VkIHRvIHZlcmlmeSAyIGJpdCAoYGJvb2xgKSBtYXAga2V5cy5cbiAqIEB0eXBlIHtSZWdFeHB9XG4gKiBAY29uc3RcbiAqL1xudXRpbC5rZXkyUmUgPSAvXnRydWV8ZmFsc2V8MHwxJC87XG5cbi8qKlxuICogUmVndWxhciBleHByZXNzaW9uIHVzZWQgdG8gdmVyaWZ5IDMyIGJpdCAoYGludDMyYCBldGMuKSBtYXAga2V5cy5cbiAqIEB0eXBlIHtSZWdFeHB9XG4gKiBAY29uc3RcbiAqL1xudXRpbC5rZXkzMlJlID0gL14tPyg/OjB8WzEtOV1bMC05XSopJC87XG5cbi8qKlxuICogUmVndWxhciBleHByZXNzaW9uIHVzZWQgdG8gdmVyaWZ5IDY0IGJpdCAoYGludDY0YCBldGMuKSBtYXAga2V5cy5cbiAqIEB0eXBlIHtSZWdFeHB9XG4gKiBAY29uc3RcbiAqL1xudXRpbC5rZXk2NFJlID0gL14oPzpbXFxcXHgwMC1cXFxceGZmXXs4fXwtPyg/OjB8WzEtOV1bMC05XSopKSQvO1xuXG4vKipcbiAqIENvbnZlcnRzIGEgbnVtYmVyIG9yIGxvbmcgdG8gYW4gOCBjaGFyYWN0ZXJzIGxvbmcgaGFzaCBzdHJpbmcuXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byBjb252ZXJ0XG4gKiBAcmV0dXJucyB7c3RyaW5nfSBIYXNoXG4gKi9cbnV0aWwubG9uZ1RvSGFzaCA9IGZ1bmN0aW9uIGxvbmdUb0hhc2godmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgICAgICAgPyB1dGlsLkxvbmdCaXRzLmZyb20odmFsdWUpLnRvSGFzaCgpXG4gICAgICAgIDogdXRpbC5Mb25nQml0cy56ZXJvSGFzaDtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYW4gOCBjaGFyYWN0ZXJzIGxvbmcgaGFzaCBzdHJpbmcgdG8gYSBsb25nIG9yIG51bWJlci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBoYXNoIEhhc2hcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Vuc2lnbmVkPWZhbHNlXSBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdFxuICogQHJldHVybnMge0xvbmd8bnVtYmVyfSBPcmlnaW5hbCB2YWx1ZVxuICovXG51dGlsLmxvbmdGcm9tSGFzaCA9IGZ1bmN0aW9uIGxvbmdGcm9tSGFzaChoYXNoLCB1bnNpZ25lZCkge1xuICAgIHZhciBiaXRzID0gdXRpbC5Mb25nQml0cy5mcm9tSGFzaChoYXNoKTtcbiAgICBpZiAodXRpbC5Mb25nKVxuICAgICAgICByZXR1cm4gdXRpbC5Mb25nLmZyb21CaXRzKGJpdHMubG8sIGJpdHMuaGksIHVuc2lnbmVkKTtcbiAgICByZXR1cm4gYml0cy50b051bWJlcihCb29sZWFuKHVuc2lnbmVkKSk7XG59O1xuXG4vKipcbiAqIE1lcmdlcyB0aGUgcHJvcGVydGllcyBvZiB0aGUgc291cmNlIG9iamVjdCBpbnRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAbWVtYmVyb2YgdXRpbFxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gZHN0IERlc3RpbmF0aW9uIG9iamVjdFxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gc3JjIFNvdXJjZSBvYmplY3RcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lmTm90U2V0PWZhbHNlXSBNZXJnZXMgb25seSBpZiB0aGUga2V5IGlzIG5vdCBhbHJlYWR5IHNldFxuICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBEZXN0aW5hdGlvbiBvYmplY3RcbiAqL1xuZnVuY3Rpb24gbWVyZ2UoZHN0LCBzcmMsIGlmTm90U2V0KSB7IC8vIHVzZWQgYnkgY29udmVydGVyc1xuICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhzcmMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgIGlmIChkc3Rba2V5c1tpXV0gPT09IHVuZGVmaW5lZCB8fCAhaWZOb3RTZXQpXG4gICAgICAgICAgICBkc3Rba2V5c1tpXV0gPSBzcmNba2V5c1tpXV07XG4gICAgcmV0dXJuIGRzdDtcbn1cblxudXRpbC5tZXJnZSA9IG1lcmdlO1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYSBzdHJpbmcgdG8gbG93ZXIgY2FzZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIHRvIGNvbnZlcnRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IENvbnZlcnRlZCBzdHJpbmdcbiAqL1xudXRpbC5sY0ZpcnN0ID0gZnVuY3Rpb24gbGNGaXJzdChzdHIpIHtcbiAgICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpICsgc3RyLnN1YnN0cmluZygxKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGN1c3RvbSBlcnJvciBjb25zdHJ1Y3Rvci5cbiAqIEBtZW1iZXJvZiB1dGlsXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBFcnJvciBuYW1lXG4gKiBAcmV0dXJucyB7Q29uc3RydWN0b3I8RXJyb3I+fSBDdXN0b20gZXJyb3IgY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gbmV3RXJyb3IobmFtZSkge1xuXG4gICAgZnVuY3Rpb24gQ3VzdG9tRXJyb3IobWVzc2FnZSwgcHJvcGVydGllcykge1xuXG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBDdXN0b21FcnJvcikpXG4gICAgICAgICAgICByZXR1cm4gbmV3IEN1c3RvbUVycm9yKG1lc3NhZ2UsIHByb3BlcnRpZXMpO1xuXG4gICAgICAgIC8vIEVycm9yLmNhbGwodGhpcywgbWVzc2FnZSk7XG4gICAgICAgIC8vIF4ganVzdCByZXR1cm5zIGEgbmV3IGVycm9yIGluc3RhbmNlIGJlY2F1c2UgdGhlIGN0b3IgY2FuIGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uXG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWVzc2FnZVwiLCB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtZXNzYWdlOyB9IH0pO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkgLy8gbm9kZVxuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgQ3VzdG9tRXJyb3IpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGFja1wiLCB7IHZhbHVlOiBuZXcgRXJyb3IoKS5zdGFjayB8fCBcIlwiIH0pO1xuXG4gICAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICAgICAgbWVyZ2UodGhpcywgcHJvcGVydGllcyk7XG4gICAgfVxuXG4gICAgQ3VzdG9tRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgIHZhbHVlOiBDdXN0b21FcnJvcixcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICAgIG5hbWU6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkgeyByZXR1cm4gbmFtZTsgfSxcbiAgICAgICAgICAgIHNldDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAvLyBjb25maWd1cmFibGU6IGZhbHNlIHdvdWxkIGFjY3VyYXRlbHkgcHJlc2VydmUgdGhlIGJlaGF2aW9yIG9mXG4gICAgICAgICAgICAvLyB0aGUgb3JpZ2luYWwsIGJ1dCBJJ20gZ3Vlc3NpbmcgdGhhdCB3YXMgbm90IGludGVudGlvbmFsLlxuICAgICAgICAgICAgLy8gRm9yIGFuIGFjdHVhbCBlcnJvciBzdWJjbGFzcywgdGhpcyBwcm9wZXJ0eSB3b3VsZFxuICAgICAgICAgICAgLy8gYmUgY29uZmlndXJhYmxlLlxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgICB0b1N0cmluZzoge1xuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkgeyByZXR1cm4gdGhpcy5uYW1lICsgXCI6IFwiICsgdGhpcy5tZXNzYWdlOyB9LFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICB9KTtcblxuICAgIHJldHVybiBDdXN0b21FcnJvcjtcbn1cblxudXRpbC5uZXdFcnJvciA9IG5ld0Vycm9yO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgcHJvdG9jb2wgZXJyb3IuXG4gKiBAY2xhc3NkZXNjIEVycm9yIHN1YmNsYXNzIGluZGljYXRpbmcgYSBwcm90b2NvbCBzcGVjaWZjIGVycm9yLlxuICogQG1lbWJlcm9mIHV0aWxcbiAqIEBleHRlbmRzIEVycm9yXG4gKiBAdGVtcGxhdGUgVCBleHRlbmRzIE1lc3NhZ2U8VD5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgRXJyb3IgbWVzc2FnZVxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gW3Byb3BlcnRpZXNdIEFkZGl0aW9uYWwgcHJvcGVydGllc1xuICogQGV4YW1wbGVcbiAqIHRyeSB7XG4gKiAgICAgTXlNZXNzYWdlLmRlY29kZShzb21lQnVmZmVyKTsgLy8gdGhyb3dzIGlmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICogfSBjYXRjaCAoZSkge1xuICogICAgIGlmIChlIGluc3RhbmNlb2YgUHJvdG9jb2xFcnJvciAmJiBlLmluc3RhbmNlKVxuICogICAgICAgICBjb25zb2xlLmxvZyhcImRlY29kZWQgc28gZmFyOiBcIiArIEpTT04uc3RyaW5naWZ5KGUuaW5zdGFuY2UpKTtcbiAqIH1cbiAqL1xudXRpbC5Qcm90b2NvbEVycm9yID0gbmV3RXJyb3IoXCJQcm90b2NvbEVycm9yXCIpO1xuXG4vKipcbiAqIFNvIGZhciBkZWNvZGVkIG1lc3NhZ2UgaW5zdGFuY2UuXG4gKiBAbmFtZSB1dGlsLlByb3RvY29sRXJyb3IjaW5zdGFuY2VcbiAqIEB0eXBlIHtNZXNzYWdlPFQ+fVxuICovXG5cbi8qKlxuICogQSBPbmVPZiBnZXR0ZXIgYXMgcmV0dXJuZWQgYnkge0BsaW5rIHV0aWwub25lT2ZHZXR0ZXJ9LlxuICogQHR5cGVkZWYgT25lT2ZHZXR0ZXJcbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEByZXR1cm5zIHtzdHJpbmd8dW5kZWZpbmVkfSBTZXQgZmllbGQgbmFtZSwgaWYgYW55XG4gKi9cblxuLyoqXG4gKiBCdWlsZHMgYSBnZXR0ZXIgZm9yIGEgb25lb2YncyBwcmVzZW50IGZpZWxkIG5hbWUuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBmaWVsZE5hbWVzIEZpZWxkIG5hbWVzXG4gKiBAcmV0dXJucyB7T25lT2ZHZXR0ZXJ9IFVuYm91bmQgZ2V0dGVyXG4gKi9cbnV0aWwub25lT2ZHZXR0ZXIgPSBmdW5jdGlvbiBnZXRPbmVPZihmaWVsZE5hbWVzKSB7XG4gICAgdmFyIGZpZWxkTWFwID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWVsZE5hbWVzLmxlbmd0aDsgKytpKVxuICAgICAgICBmaWVsZE1hcFtmaWVsZE5hbWVzW2ldXSA9IDE7XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH0gU2V0IGZpZWxkIG5hbWUsIGlmIGFueVxuICAgICAqIEB0aGlzIE9iamVjdFxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbiAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpLCBpID0ga2V5cy5sZW5ndGggLSAxOyBpID4gLTE7IC0taSlcbiAgICAgICAgICAgIGlmIChmaWVsZE1hcFtrZXlzW2ldXSA9PT0gMSAmJiB0aGlzW2tleXNbaV1dICE9PSB1bmRlZmluZWQgJiYgdGhpc1trZXlzW2ldXSAhPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5c1tpXTtcbiAgICB9O1xufTtcblxuLyoqXG4gKiBBIE9uZU9mIHNldHRlciBhcyByZXR1cm5lZCBieSB7QGxpbmsgdXRpbC5vbmVPZlNldHRlcn0uXG4gKiBAdHlwZWRlZiBPbmVPZlNldHRlclxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtzdHJpbmd8dW5kZWZpbmVkfSB2YWx1ZSBGaWVsZCBuYW1lXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5cbi8qKlxuICogQnVpbGRzIGEgc2V0dGVyIGZvciBhIG9uZW9mJ3MgcHJlc2VudCBmaWVsZCBuYW1lLlxuICogQHBhcmFtIHtzdHJpbmdbXX0gZmllbGROYW1lcyBGaWVsZCBuYW1lc1xuICogQHJldHVybnMge09uZU9mU2V0dGVyfSBVbmJvdW5kIHNldHRlclxuICovXG51dGlsLm9uZU9mU2V0dGVyID0gZnVuY3Rpb24gc2V0T25lT2YoZmllbGROYW1lcykge1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgRmllbGQgbmFtZVxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAgICogQHRoaXMgT2JqZWN0XG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHJldHVybiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmllbGROYW1lcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIGlmIChmaWVsZE5hbWVzW2ldICE9PSBuYW1lKVxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzW2ZpZWxkTmFtZXNbaV1dO1xuICAgIH07XG59O1xuXG4vKipcbiAqIERlZmF1bHQgY29udmVyc2lvbiBvcHRpb25zIHVzZWQgZm9yIHtAbGluayBNZXNzYWdlI3RvSlNPTn0gaW1wbGVtZW50YXRpb25zLlxuICpcbiAqIFRoZXNlIG9wdGlvbnMgYXJlIGNsb3NlIHRvIHByb3RvMydzIEpTT04gbWFwcGluZyB3aXRoIHRoZSBleGNlcHRpb24gdGhhdCBpbnRlcm5hbCB0eXBlcyBsaWtlIEFueSBhcmUgaGFuZGxlZCBqdXN0IGxpa2UgbWVzc2FnZXMuIE1vcmUgcHJlY2lzZWx5OlxuICpcbiAqIC0gTG9uZ3MgYmVjb21lIHN0cmluZ3NcbiAqIC0gRW51bXMgYmVjb21lIHN0cmluZyBrZXlzXG4gKiAtIEJ5dGVzIGJlY29tZSBiYXNlNjQgZW5jb2RlZCBzdHJpbmdzXG4gKiAtIChTdWItKU1lc3NhZ2VzIGJlY29tZSBwbGFpbiBvYmplY3RzXG4gKiAtIE1hcHMgYmVjb21lIHBsYWluIG9iamVjdHMgd2l0aCBhbGwgc3RyaW5nIGtleXNcbiAqIC0gUmVwZWF0ZWQgZmllbGRzIGJlY29tZSBhcnJheXNcbiAqIC0gTmFOIGFuZCBJbmZpbml0eSBmb3IgZmxvYXQgYW5kIGRvdWJsZSBmaWVsZHMgYmVjb21lIHN0cmluZ3NcbiAqXG4gKiBAdHlwZSB7SUNvbnZlcnNpb25PcHRpb25zfVxuICogQHNlZSBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9wcm90b2NvbC1idWZmZXJzL2RvY3MvcHJvdG8zP2hsPWVuI2pzb25cbiAqL1xudXRpbC50b0pTT05PcHRpb25zID0ge1xuICAgIGxvbmdzOiBTdHJpbmcsXG4gICAgZW51bXM6IFN0cmluZyxcbiAgICBieXRlczogU3RyaW5nLFxuICAgIGpzb246IHRydWVcbn07XG5cbi8vIFNldHMgdXAgYnVmZmVyIHV0aWxpdHkgYWNjb3JkaW5nIHRvIHRoZSBlbnZpcm9ubWVudCAoY2FsbGVkIGluIGluZGV4LW1pbmltYWwpXG51dGlsLl9jb25maWd1cmUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgQnVmZmVyID0gdXRpbC5CdWZmZXI7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFCdWZmZXIpIHtcbiAgICAgICAgdXRpbC5fQnVmZmVyX2Zyb20gPSB1dGlsLl9CdWZmZXJfYWxsb2NVbnNhZmUgPSBudWxsO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGJlY2F1c2Ugbm9kZSA0LnggYnVmZmVycyBhcmUgaW5jb21wYXRpYmxlICYgaW1tdXRhYmxlXG4gICAgLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vZGNvZGVJTy9wcm90b2J1Zi5qcy9wdWxsLzY2NVxuICAgIHV0aWwuX0J1ZmZlcl9mcm9tID0gQnVmZmVyLmZyb20gIT09IFVpbnQ4QXJyYXkuZnJvbSAmJiBCdWZmZXIuZnJvbSB8fFxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBmdW5jdGlvbiBCdWZmZXJfZnJvbSh2YWx1ZSwgZW5jb2RpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyKHZhbHVlLCBlbmNvZGluZyk7XG4gICAgICAgIH07XG4gICAgdXRpbC5fQnVmZmVyX2FsbG9jVW5zYWZlID0gQnVmZmVyLmFsbG9jVW5zYWZlIHx8XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGZ1bmN0aW9uIEJ1ZmZlcl9hbGxvY1Vuc2FmZShzaXplKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcihzaXplKTtcbiAgICAgICAgfTtcbn07XG4iXSwibmFtZXMiOlsidXRpbCIsImV4cG9ydHMiLCJhc1Byb21pc2UiLCJyZXF1aXJlIiwiYmFzZTY0IiwiRXZlbnRFbWl0dGVyIiwiZmxvYXQiLCJpbnF1aXJlIiwidXRmOCIsInBvb2wiLCJMb25nQml0cyIsImlzTm9kZSIsIkJvb2xlYW4iLCJnbG9iYWwiLCJwcm9jZXNzIiwidmVyc2lvbnMiLCJub2RlIiwid2luZG93Iiwic2VsZiIsImVtcHR5QXJyYXkiLCJPYmplY3QiLCJmcmVlemUiLCJlbXB0eU9iamVjdCIsImlzSW50ZWdlciIsIk51bWJlciIsInZhbHVlIiwiaXNGaW5pdGUiLCJNYXRoIiwiZmxvb3IiLCJpc1N0cmluZyIsIlN0cmluZyIsImlzT2JqZWN0IiwiaXNzZXQiLCJpc1NldCIsIm9iaiIsInByb3AiLCJoYXNPd25Qcm9wZXJ0eSIsIkFycmF5IiwiaXNBcnJheSIsImxlbmd0aCIsImtleXMiLCJCdWZmZXIiLCJwcm90b3R5cGUiLCJ1dGY4V3JpdGUiLCJlIiwiX0J1ZmZlcl9mcm9tIiwiX0J1ZmZlcl9hbGxvY1Vuc2FmZSIsIm5ld0J1ZmZlciIsInNpemVPckFycmF5IiwiVWludDhBcnJheSIsIkxvbmciLCJkY29kZUlPIiwia2V5MlJlIiwia2V5MzJSZSIsImtleTY0UmUiLCJsb25nVG9IYXNoIiwiZnJvbSIsInRvSGFzaCIsInplcm9IYXNoIiwibG9uZ0Zyb21IYXNoIiwiaGFzaCIsInVuc2lnbmVkIiwiYml0cyIsImZyb21IYXNoIiwiZnJvbUJpdHMiLCJsbyIsImhpIiwidG9OdW1iZXIiLCJtZXJnZSIsImRzdCIsInNyYyIsImlmTm90U2V0IiwiaSIsInVuZGVmaW5lZCIsImxjRmlyc3QiLCJzdHIiLCJjaGFyQXQiLCJ0b0xvd2VyQ2FzZSIsInN1YnN0cmluZyIsIm5ld0Vycm9yIiwibmFtZSIsIkN1c3RvbUVycm9yIiwibWVzc2FnZSIsInByb3BlcnRpZXMiLCJkZWZpbmVQcm9wZXJ0eSIsImdldCIsIkVycm9yIiwiY2FwdHVyZVN0YWNrVHJhY2UiLCJzdGFjayIsImNyZWF0ZSIsImNvbnN0cnVjdG9yIiwid3JpdGFibGUiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwic2V0IiwidG9TdHJpbmciLCJQcm90b2NvbEVycm9yIiwib25lT2ZHZXR0ZXIiLCJnZXRPbmVPZiIsImZpZWxkTmFtZXMiLCJmaWVsZE1hcCIsIm9uZU9mU2V0dGVyIiwic2V0T25lT2YiLCJ0b0pTT05PcHRpb25zIiwibG9uZ3MiLCJlbnVtcyIsImJ5dGVzIiwianNvbiIsIl9jb25maWd1cmUiLCJCdWZmZXJfZnJvbSIsImVuY29kaW5nIiwiYWxsb2NVbnNhZmUiLCJCdWZmZXJfYWxsb2NVbnNhZmUiLCJzaXplIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/protobufjs/src/util/minimal.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/src/verifier.js":
/*!**************************************************!*\
  !*** ../node_modules/protobufjs/src/verifier.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = verifier;\nvar Enum = __webpack_require__(/*! ./enum */ \"(ssr)/../node_modules/protobufjs/src/enum.js\"), util = __webpack_require__(/*! ./util */ \"(ssr)/../node_modules/protobufjs/src/util.js\");\nfunction invalid(field, expected) {\n    return field.name + \": \" + expected + (field.repeated && expected !== \"array\" ? \"[]\" : field.map && expected !== \"object\" ? \"{k:\" + field.keyType + \"}\" : \"\") + \" expected\";\n}\n/**\n * Generates a partial value verifier.\n * @param {Codegen} gen Codegen instance\n * @param {Field} field Reflected field\n * @param {number} fieldIndex Field index\n * @param {string} ref Variable reference\n * @returns {Codegen} Codegen instance\n * @ignore\n */ function genVerifyValue(gen, field, fieldIndex, ref) {\n    /* eslint-disable no-unexpected-multiline */ if (field.resolvedType) {\n        if (field.resolvedType instanceof Enum) {\n            gen(\"switch(%s){\", ref)(\"default:\")(\"return%j\", invalid(field, \"enum value\"));\n            for(var keys = Object.keys(field.resolvedType.values), j = 0; j < keys.length; ++j)gen(\"case %i:\", field.resolvedType.values[keys[j]]);\n            gen(\"break\")(\"}\");\n        } else {\n            gen(\"{\")(\"var e=types[%i].verify(%s);\", fieldIndex, ref)(\"if(e)\")(\"return%j+e\", field.name + \".\")(\"}\");\n        }\n    } else {\n        switch(field.type){\n            case \"int32\":\n            case \"uint32\":\n            case \"sint32\":\n            case \"fixed32\":\n            case \"sfixed32\":\n                gen(\"if(!util.isInteger(%s))\", ref)(\"return%j\", invalid(field, \"integer\"));\n                break;\n            case \"int64\":\n            case \"uint64\":\n            case \"sint64\":\n            case \"fixed64\":\n            case \"sfixed64\":\n                gen(\"if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))\", ref, ref, ref, ref)(\"return%j\", invalid(field, \"integer|Long\"));\n                break;\n            case \"float\":\n            case \"double\":\n                gen('if(typeof %s!==\"number\")', ref)(\"return%j\", invalid(field, \"number\"));\n                break;\n            case \"bool\":\n                gen('if(typeof %s!==\"boolean\")', ref)(\"return%j\", invalid(field, \"boolean\"));\n                break;\n            case \"string\":\n                gen(\"if(!util.isString(%s))\", ref)(\"return%j\", invalid(field, \"string\"));\n                break;\n            case \"bytes\":\n                gen('if(!(%s&&typeof %s.length===\"number\"||util.isString(%s)))', ref, ref, ref)(\"return%j\", invalid(field, \"buffer\"));\n                break;\n        }\n    }\n    return gen;\n/* eslint-enable no-unexpected-multiline */ }\n/**\n * Generates a partial key verifier.\n * @param {Codegen} gen Codegen instance\n * @param {Field} field Reflected field\n * @param {string} ref Variable reference\n * @returns {Codegen} Codegen instance\n * @ignore\n */ function genVerifyKey(gen, field, ref) {\n    /* eslint-disable no-unexpected-multiline */ switch(field.keyType){\n        case \"int32\":\n        case \"uint32\":\n        case \"sint32\":\n        case \"fixed32\":\n        case \"sfixed32\":\n            gen(\"if(!util.key32Re.test(%s))\", ref)(\"return%j\", invalid(field, \"integer key\"));\n            break;\n        case \"int64\":\n        case \"uint64\":\n        case \"sint64\":\n        case \"fixed64\":\n        case \"sfixed64\":\n            gen(\"if(!util.key64Re.test(%s))\", ref) // see comment above: x is ok, d is not\n            (\"return%j\", invalid(field, \"integer|Long key\"));\n            break;\n        case \"bool\":\n            gen(\"if(!util.key2Re.test(%s))\", ref)(\"return%j\", invalid(field, \"boolean key\"));\n            break;\n    }\n    return gen;\n/* eslint-enable no-unexpected-multiline */ }\n/**\n * Generates a verifier specific to the specified message type.\n * @param {Type} mtype Message type\n * @returns {Codegen} Codegen instance\n */ function verifier(mtype) {\n    /* eslint-disable no-unexpected-multiline */ var gen = util.codegen([\n        \"m\"\n    ], mtype.name + \"$verify\")('if(typeof m!==\"object\"||m===null)')(\"return%j\", \"object expected\");\n    var oneofs = mtype.oneofsArray, seenFirstField = {};\n    if (oneofs.length) gen(\"var p={}\");\n    for(var i = 0; i < /* initializes */ mtype.fieldsArray.length; ++i){\n        var field = mtype._fieldsArray[i].resolve(), ref = \"m\" + util.safeProp(field.name);\n        if (field.optional) gen(\"if(%s!=null&&m.hasOwnProperty(%j)){\", ref, field.name); // !== undefined && !== null\n        // map fields\n        if (field.map) {\n            gen(\"if(!util.isObject(%s))\", ref)(\"return%j\", invalid(field, \"object\"))(\"var k=Object.keys(%s)\", ref)(\"for(var i=0;i<k.length;++i){\");\n            genVerifyKey(gen, field, \"k[i]\");\n            genVerifyValue(gen, field, i, ref + \"[k[i]]\")(\"}\");\n        // repeated fields\n        } else if (field.repeated) {\n            gen(\"if(!Array.isArray(%s))\", ref)(\"return%j\", invalid(field, \"array\"))(\"for(var i=0;i<%s.length;++i){\", ref);\n            genVerifyValue(gen, field, i, ref + \"[i]\")(\"}\");\n        // required or present fields\n        } else {\n            if (field.partOf) {\n                var oneofProp = util.safeProp(field.partOf.name);\n                if (seenFirstField[field.partOf.name] === 1) gen(\"if(p%s===1)\", oneofProp)(\"return%j\", field.partOf.name + \": multiple values\");\n                seenFirstField[field.partOf.name] = 1;\n                gen(\"p%s=1\", oneofProp);\n            }\n            genVerifyValue(gen, field, i, ref);\n        }\n        if (field.optional) gen(\"}\");\n    }\n    return gen(\"return null\");\n/* eslint-enable no-unexpected-multiline */ }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3ZlcmlmaWVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLE9BQU9DLE9BQU8sR0FBR0M7QUFFakIsSUFBSUMsT0FBWUMsbUJBQU9BLENBQUMsNERBQVEsR0FDNUJDLE9BQVlELG1CQUFPQSxDQUFDLDREQUFRO0FBRWhDLFNBQVNFLFFBQVFDLEtBQUssRUFBRUMsUUFBUTtJQUM1QixPQUFPRCxNQUFNRSxJQUFJLEdBQUcsT0FBT0QsV0FBWUQsQ0FBQUEsTUFBTUcsUUFBUSxJQUFJRixhQUFhLFVBQVUsT0FBT0QsTUFBTUksR0FBRyxJQUFJSCxhQUFhLFdBQVcsUUFBTUQsTUFBTUssT0FBTyxHQUFDLE1BQU0sRUFBQyxJQUFLO0FBQ2hLO0FBRUE7Ozs7Ozs7O0NBUUMsR0FDRCxTQUFTQyxlQUFlQyxHQUFHLEVBQUVQLEtBQUssRUFBRVEsVUFBVSxFQUFFQyxHQUFHO0lBQy9DLDBDQUEwQyxHQUMxQyxJQUFJVCxNQUFNVSxZQUFZLEVBQUU7UUFDcEIsSUFBSVYsTUFBTVUsWUFBWSxZQUFZZCxNQUFNO1lBQUVXLElBQ3JDLGVBQWVFLEtBQ1gsWUFDSSxZQUFZVixRQUFRQyxPQUFPO1lBQ3BDLElBQUssSUFBSVcsT0FBT0MsT0FBT0QsSUFBSSxDQUFDWCxNQUFNVSxZQUFZLENBQUNHLE1BQU0sR0FBR0MsSUFBSSxHQUFHQSxJQUFJSCxLQUFLSSxNQUFNLEVBQUUsRUFBRUQsRUFBR1AsSUFDaEYsWUFBWVAsTUFBTVUsWUFBWSxDQUFDRyxNQUFNLENBQUNGLElBQUksQ0FBQ0csRUFBRSxDQUFDO1lBQ25EUCxJQUNTLFNBQ1I7UUFDTCxPQUFPO1lBQ0hBLElBQ0MsS0FDSSwrQkFBK0JDLFlBQVlDLEtBQzNDLFNBQ0ksY0FBY1QsTUFBTUUsSUFBSSxHQUFHLEtBQ25DO1FBQ0w7SUFDSixPQUFPO1FBQ0gsT0FBUUYsTUFBTWdCLElBQUk7WUFDZCxLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFL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dEIsTUFBTTZCLE1BQU0sQ0FBQzNCLElBQUksQ0FBQyxLQUFLLEdBQUdLLElBQ2hELGVBQWV1QixXQUNYLFlBQVk5QixNQUFNNkIsTUFBTSxDQUFDM0IsSUFBSSxHQUFHO2dCQUNqQ29CLGNBQWMsQ0FBQ3RCLE1BQU02QixNQUFNLENBQUMzQixJQUFJLENBQUMsR0FBRztnQkFDcENLLElBQ0gsU0FBU3VCO1lBQ1Y7WUFDQXhCLGVBQWVDLEtBQUtQLE9BQU91QixHQUFHZDtRQUNsQztRQUNBLElBQUlULE1BQU00QixRQUFRLEVBQUVyQixJQUNuQjtJQUNMO0lBQ0EsT0FBT0EsSUFDTjtBQUNELHlDQUF5QyxHQUM3QyIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvdmVyaWZpZXIuanM/NDJiYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gdmVyaWZpZXI7XG5cbnZhciBFbnVtICAgICAgPSByZXF1aXJlKFwiLi9lbnVtXCIpLFxuICAgIHV0aWwgICAgICA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbmZ1bmN0aW9uIGludmFsaWQoZmllbGQsIGV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIGZpZWxkLm5hbWUgKyBcIjogXCIgKyBleHBlY3RlZCArIChmaWVsZC5yZXBlYXRlZCAmJiBleHBlY3RlZCAhPT0gXCJhcnJheVwiID8gXCJbXVwiIDogZmllbGQubWFwICYmIGV4cGVjdGVkICE9PSBcIm9iamVjdFwiID8gXCJ7azpcIitmaWVsZC5rZXlUeXBlK1wifVwiIDogXCJcIikgKyBcIiBleHBlY3RlZFwiO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHBhcnRpYWwgdmFsdWUgdmVyaWZpZXIuXG4gKiBAcGFyYW0ge0NvZGVnZW59IGdlbiBDb2RlZ2VuIGluc3RhbmNlXG4gKiBAcGFyYW0ge0ZpZWxkfSBmaWVsZCBSZWZsZWN0ZWQgZmllbGRcbiAqIEBwYXJhbSB7bnVtYmVyfSBmaWVsZEluZGV4IEZpZWxkIGluZGV4XG4gKiBAcGFyYW0ge3N0cmluZ30gcmVmIFZhcmlhYmxlIHJlZmVyZW5jZVxuICogQHJldHVybnMge0NvZGVnZW59IENvZGVnZW4gaW5zdGFuY2VcbiAqIEBpZ25vcmVcbiAqL1xuZnVuY3Rpb24gZ2VuVmVyaWZ5VmFsdWUoZ2VuLCBmaWVsZCwgZmllbGRJbmRleCwgcmVmKSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmUgKi9cbiAgICBpZiAoZmllbGQucmVzb2x2ZWRUeXBlKSB7XG4gICAgICAgIGlmIChmaWVsZC5yZXNvbHZlZFR5cGUgaW5zdGFuY2VvZiBFbnVtKSB7IGdlblxuICAgICAgICAgICAgKFwic3dpdGNoKCVzKXtcIiwgcmVmKVxuICAgICAgICAgICAgICAgIChcImRlZmF1bHQ6XCIpXG4gICAgICAgICAgICAgICAgICAgIChcInJldHVybiVqXCIsIGludmFsaWQoZmllbGQsIFwiZW51bSB2YWx1ZVwiKSk7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMoZmllbGQucmVzb2x2ZWRUeXBlLnZhbHVlcyksIGogPSAwOyBqIDwga2V5cy5sZW5ndGg7ICsraikgZ2VuXG4gICAgICAgICAgICAgICAgKFwiY2FzZSAlaTpcIiwgZmllbGQucmVzb2x2ZWRUeXBlLnZhbHVlc1trZXlzW2pdXSk7XG4gICAgICAgICAgICBnZW5cbiAgICAgICAgICAgICAgICAgICAgKFwiYnJlYWtcIilcbiAgICAgICAgICAgIChcIn1cIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnZW5cbiAgICAgICAgICAgIChcIntcIilcbiAgICAgICAgICAgICAgICAoXCJ2YXIgZT10eXBlc1slaV0udmVyaWZ5KCVzKTtcIiwgZmllbGRJbmRleCwgcmVmKVxuICAgICAgICAgICAgICAgIChcImlmKGUpXCIpXG4gICAgICAgICAgICAgICAgICAgIChcInJldHVybiVqK2VcIiwgZmllbGQubmFtZSArIFwiLlwiKVxuICAgICAgICAgICAgKFwifVwiKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXRjaCAoZmllbGQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcImludDMyXCI6XG4gICAgICAgICAgICBjYXNlIFwidWludDMyXCI6XG4gICAgICAgICAgICBjYXNlIFwic2ludDMyXCI6XG4gICAgICAgICAgICBjYXNlIFwiZml4ZWQzMlwiOlxuICAgICAgICAgICAgY2FzZSBcInNmaXhlZDMyXCI6IGdlblxuICAgICAgICAgICAgICAgIChcImlmKCF1dGlsLmlzSW50ZWdlciglcykpXCIsIHJlZilcbiAgICAgICAgICAgICAgICAgICAgKFwicmV0dXJuJWpcIiwgaW52YWxpZChmaWVsZCwgXCJpbnRlZ2VyXCIpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJpbnQ2NFwiOlxuICAgICAgICAgICAgY2FzZSBcInVpbnQ2NFwiOlxuICAgICAgICAgICAgY2FzZSBcInNpbnQ2NFwiOlxuICAgICAgICAgICAgY2FzZSBcImZpeGVkNjRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJzZml4ZWQ2NFwiOiBnZW5cbiAgICAgICAgICAgICAgICAoXCJpZighdXRpbC5pc0ludGVnZXIoJXMpJiYhKCVzJiZ1dGlsLmlzSW50ZWdlciglcy5sb3cpJiZ1dGlsLmlzSW50ZWdlciglcy5oaWdoKSkpXCIsIHJlZiwgcmVmLCByZWYsIHJlZilcbiAgICAgICAgICAgICAgICAgICAgKFwicmV0dXJuJWpcIiwgaW52YWxpZChmaWVsZCwgXCJpbnRlZ2VyfExvbmdcIikpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImZsb2F0XCI6XG4gICAgICAgICAgICBjYXNlIFwiZG91YmxlXCI6IGdlblxuICAgICAgICAgICAgICAgIChcImlmKHR5cGVvZiAlcyE9PVxcXCJudW1iZXJcXFwiKVwiLCByZWYpXG4gICAgICAgICAgICAgICAgICAgIChcInJldHVybiVqXCIsIGludmFsaWQoZmllbGQsIFwibnVtYmVyXCIpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJib29sXCI6IGdlblxuICAgICAgICAgICAgICAgIChcImlmKHR5cGVvZiAlcyE9PVxcXCJib29sZWFuXFxcIilcIiwgcmVmKVxuICAgICAgICAgICAgICAgICAgICAoXCJyZXR1cm4lalwiLCBpbnZhbGlkKGZpZWxkLCBcImJvb2xlYW5cIikpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOiBnZW5cbiAgICAgICAgICAgICAgICAoXCJpZighdXRpbC5pc1N0cmluZyglcykpXCIsIHJlZilcbiAgICAgICAgICAgICAgICAgICAgKFwicmV0dXJuJWpcIiwgaW52YWxpZChmaWVsZCwgXCJzdHJpbmdcIikpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImJ5dGVzXCI6IGdlblxuICAgICAgICAgICAgICAgIChcImlmKCEoJXMmJnR5cGVvZiAlcy5sZW5ndGg9PT1cXFwibnVtYmVyXFxcInx8dXRpbC5pc1N0cmluZyglcykpKVwiLCByZWYsIHJlZiwgcmVmKVxuICAgICAgICAgICAgICAgICAgICAoXCJyZXR1cm4lalwiLCBpbnZhbGlkKGZpZWxkLCBcImJ1ZmZlclwiKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGdlbjtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVuZXhwZWN0ZWQtbXVsdGlsaW5lICovXG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcGFydGlhbCBrZXkgdmVyaWZpZXIuXG4gKiBAcGFyYW0ge0NvZGVnZW59IGdlbiBDb2RlZ2VuIGluc3RhbmNlXG4gKiBAcGFyYW0ge0ZpZWxkfSBmaWVsZCBSZWZsZWN0ZWQgZmllbGRcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWYgVmFyaWFibGUgcmVmZXJlbmNlXG4gKiBAcmV0dXJucyB7Q29kZWdlbn0gQ29kZWdlbiBpbnN0YW5jZVxuICogQGlnbm9yZVxuICovXG5mdW5jdGlvbiBnZW5WZXJpZnlLZXkoZ2VuLCBmaWVsZCwgcmVmKSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmUgKi9cbiAgICBzd2l0Y2ggKGZpZWxkLmtleVR5cGUpIHtcbiAgICAgICAgY2FzZSBcImludDMyXCI6XG4gICAgICAgIGNhc2UgXCJ1aW50MzJcIjpcbiAgICAgICAgY2FzZSBcInNpbnQzMlwiOlxuICAgICAgICBjYXNlIFwiZml4ZWQzMlwiOlxuICAgICAgICBjYXNlIFwic2ZpeGVkMzJcIjogZ2VuXG4gICAgICAgICAgICAoXCJpZighdXRpbC5rZXkzMlJlLnRlc3QoJXMpKVwiLCByZWYpXG4gICAgICAgICAgICAgICAgKFwicmV0dXJuJWpcIiwgaW52YWxpZChmaWVsZCwgXCJpbnRlZ2VyIGtleVwiKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImludDY0XCI6XG4gICAgICAgIGNhc2UgXCJ1aW50NjRcIjpcbiAgICAgICAgY2FzZSBcInNpbnQ2NFwiOlxuICAgICAgICBjYXNlIFwiZml4ZWQ2NFwiOlxuICAgICAgICBjYXNlIFwic2ZpeGVkNjRcIjogZ2VuXG4gICAgICAgICAgICAoXCJpZighdXRpbC5rZXk2NFJlLnRlc3QoJXMpKVwiLCByZWYpIC8vIHNlZSBjb21tZW50IGFib3ZlOiB4IGlzIG9rLCBkIGlzIG5vdFxuICAgICAgICAgICAgICAgIChcInJldHVybiVqXCIsIGludmFsaWQoZmllbGQsIFwiaW50ZWdlcnxMb25nIGtleVwiKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImJvb2xcIjogZ2VuXG4gICAgICAgICAgICAoXCJpZighdXRpbC5rZXkyUmUudGVzdCglcykpXCIsIHJlZilcbiAgICAgICAgICAgICAgICAoXCJyZXR1cm4lalwiLCBpbnZhbGlkKGZpZWxkLCBcImJvb2xlYW4ga2V5XCIpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gZ2VuO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmUgKi9cbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSB2ZXJpZmllciBzcGVjaWZpYyB0byB0aGUgc3BlY2lmaWVkIG1lc3NhZ2UgdHlwZS5cbiAqIEBwYXJhbSB7VHlwZX0gbXR5cGUgTWVzc2FnZSB0eXBlXG4gKiBAcmV0dXJucyB7Q29kZWdlbn0gQ29kZWdlbiBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiB2ZXJpZmllcihtdHlwZSkge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVuZXhwZWN0ZWQtbXVsdGlsaW5lICovXG5cbiAgICB2YXIgZ2VuID0gdXRpbC5jb2RlZ2VuKFtcIm1cIl0sIG10eXBlLm5hbWUgKyBcIiR2ZXJpZnlcIilcbiAgICAoXCJpZih0eXBlb2YgbSE9PVxcXCJvYmplY3RcXFwifHxtPT09bnVsbClcIilcbiAgICAgICAgKFwicmV0dXJuJWpcIiwgXCJvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgdmFyIG9uZW9mcyA9IG10eXBlLm9uZW9mc0FycmF5LFxuICAgICAgICBzZWVuRmlyc3RGaWVsZCA9IHt9O1xuICAgIGlmIChvbmVvZnMubGVuZ3RoKSBnZW5cbiAgICAoXCJ2YXIgcD17fVwiKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgLyogaW5pdGlhbGl6ZXMgKi8gbXR5cGUuZmllbGRzQXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGZpZWxkID0gbXR5cGUuX2ZpZWxkc0FycmF5W2ldLnJlc29sdmUoKSxcbiAgICAgICAgICAgIHJlZiAgID0gXCJtXCIgKyB1dGlsLnNhZmVQcm9wKGZpZWxkLm5hbWUpO1xuXG4gICAgICAgIGlmIChmaWVsZC5vcHRpb25hbCkgZ2VuXG4gICAgICAgIChcImlmKCVzIT1udWxsJiZtLmhhc093blByb3BlcnR5KCVqKSl7XCIsIHJlZiwgZmllbGQubmFtZSk7IC8vICE9PSB1bmRlZmluZWQgJiYgIT09IG51bGxcblxuICAgICAgICAvLyBtYXAgZmllbGRzXG4gICAgICAgIGlmIChmaWVsZC5tYXApIHsgZ2VuXG4gICAgICAgICAgICAoXCJpZighdXRpbC5pc09iamVjdCglcykpXCIsIHJlZilcbiAgICAgICAgICAgICAgICAoXCJyZXR1cm4lalwiLCBpbnZhbGlkKGZpZWxkLCBcIm9iamVjdFwiKSlcbiAgICAgICAgICAgIChcInZhciBrPU9iamVjdC5rZXlzKCVzKVwiLCByZWYpXG4gICAgICAgICAgICAoXCJmb3IodmFyIGk9MDtpPGsubGVuZ3RoOysraSl7XCIpO1xuICAgICAgICAgICAgICAgIGdlblZlcmlmeUtleShnZW4sIGZpZWxkLCBcImtbaV1cIik7XG4gICAgICAgICAgICAgICAgZ2VuVmVyaWZ5VmFsdWUoZ2VuLCBmaWVsZCwgaSwgcmVmICsgXCJba1tpXV1cIilcbiAgICAgICAgICAgIChcIn1cIik7XG5cbiAgICAgICAgLy8gcmVwZWF0ZWQgZmllbGRzXG4gICAgICAgIH0gZWxzZSBpZiAoZmllbGQucmVwZWF0ZWQpIHsgZ2VuXG4gICAgICAgICAgICAoXCJpZighQXJyYXkuaXNBcnJheSglcykpXCIsIHJlZilcbiAgICAgICAgICAgICAgICAoXCJyZXR1cm4lalwiLCBpbnZhbGlkKGZpZWxkLCBcImFycmF5XCIpKVxuICAgICAgICAgICAgKFwiZm9yKHZhciBpPTA7aTwlcy5sZW5ndGg7KytpKXtcIiwgcmVmKTtcbiAgICAgICAgICAgICAgICBnZW5WZXJpZnlWYWx1ZShnZW4sIGZpZWxkLCBpLCByZWYgKyBcIltpXVwiKVxuICAgICAgICAgICAgKFwifVwiKTtcblxuICAgICAgICAvLyByZXF1aXJlZCBvciBwcmVzZW50IGZpZWxkc1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGZpZWxkLnBhcnRPZikge1xuICAgICAgICAgICAgICAgIHZhciBvbmVvZlByb3AgPSB1dGlsLnNhZmVQcm9wKGZpZWxkLnBhcnRPZi5uYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoc2VlbkZpcnN0RmllbGRbZmllbGQucGFydE9mLm5hbWVdID09PSAxKSBnZW5cbiAgICAgICAgICAgIChcImlmKHAlcz09PTEpXCIsIG9uZW9mUHJvcClcbiAgICAgICAgICAgICAgICAoXCJyZXR1cm4lalwiLCBmaWVsZC5wYXJ0T2YubmFtZSArIFwiOiBtdWx0aXBsZSB2YWx1ZXNcIik7XG4gICAgICAgICAgICAgICAgc2VlbkZpcnN0RmllbGRbZmllbGQucGFydE9mLm5hbWVdID0gMTtcbiAgICAgICAgICAgICAgICBnZW5cbiAgICAgICAgICAgIChcInAlcz0xXCIsIG9uZW9mUHJvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnZW5WZXJpZnlWYWx1ZShnZW4sIGZpZWxkLCBpLCByZWYpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaWVsZC5vcHRpb25hbCkgZ2VuXG4gICAgICAgIChcIn1cIik7XG4gICAgfVxuICAgIHJldHVybiBnZW5cbiAgICAoXCJyZXR1cm4gbnVsbFwiKTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVuZXhwZWN0ZWQtbXVsdGlsaW5lICovXG59Il0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJ2ZXJpZmllciIsIkVudW0iLCJyZXF1aXJlIiwidXRpbCIsImludmFsaWQiLCJmaWVsZCIsImV4cGVjdGVkIiwibmFtZSIsInJlcGVhdGVkIiwibWFwIiwia2V5VHlwZSIsImdlblZlcmlmeVZhbHVlIiwiZ2VuIiwiZmllbGRJbmRleCIsInJlZiIsInJlc29sdmVkVHlwZSIsImtleXMiLCJPYmplY3QiLCJ2YWx1ZXMiLCJqIiwibGVuZ3RoIiwidHlwZSIsImdlblZlcmlmeUtleSIsIm10eXBlIiwiY29kZWdlbiIsIm9uZW9mcyIsIm9uZW9mc0FycmF5Iiwic2VlbkZpcnN0RmllbGQiLCJpIiwiZmllbGRzQXJyYXkiLCJfZmllbGRzQXJyYXkiLCJyZXNvbHZlIiwic2FmZVByb3AiLCJvcHRpb25hbCIsInBhcnRPZiIsIm9uZW9mUHJvcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/protobufjs/src/verifier.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/src/wrappers.js":
/*!**************************************************!*\
  !*** ../node_modules/protobufjs/src/wrappers.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Wrappers for common types.\n * @type {Object.<string,IWrapper>}\n * @const\n */ var wrappers = exports;\nvar Message = __webpack_require__(/*! ./message */ \"(ssr)/../node_modules/protobufjs/src/message.js\");\n/**\n * From object converter part of an {@link IWrapper}.\n * @typedef WrapperFromObjectConverter\n * @type {function}\n * @param {Object.<string,*>} object Plain object\n * @returns {Message<{}>} Message instance\n * @this Type\n */ /**\n * To object converter part of an {@link IWrapper}.\n * @typedef WrapperToObjectConverter\n * @type {function}\n * @param {Message<{}>} message Message instance\n * @param {IConversionOptions} [options] Conversion options\n * @returns {Object.<string,*>} Plain object\n * @this Type\n */ /**\n * Common type wrapper part of {@link wrappers}.\n * @interface IWrapper\n * @property {WrapperFromObjectConverter} [fromObject] From object converter\n * @property {WrapperToObjectConverter} [toObject] To object converter\n */ // Custom wrapper for Any\nwrappers[\".google.protobuf.Any\"] = {\n    fromObject: function(object) {\n        // unwrap value type if mapped\n        if (object && object[\"@type\"]) {\n            // Only use fully qualified type name after the last '/'\n            var name = object[\"@type\"].substring(object[\"@type\"].lastIndexOf(\"/\") + 1);\n            var type = this.lookup(name);\n            /* istanbul ignore else */ if (type) {\n                // type_url does not accept leading \".\"\n                var type_url = object[\"@type\"].charAt(0) === \".\" ? object[\"@type\"].slice(1) : object[\"@type\"];\n                // type_url prefix is optional, but path seperator is required\n                if (type_url.indexOf(\"/\") === -1) {\n                    type_url = \"/\" + type_url;\n                }\n                return this.create({\n                    type_url: type_url,\n                    value: type.encode(type.fromObject(object)).finish()\n                });\n            }\n        }\n        return this.fromObject(object);\n    },\n    toObject: function(message, options) {\n        // Default prefix\n        var googleApi = \"type.googleapis.com/\";\n        var prefix = \"\";\n        var name = \"\";\n        // decode value if requested and unmapped\n        if (options && options.json && message.type_url && message.value) {\n            // Only use fully qualified type name after the last '/'\n            name = message.type_url.substring(message.type_url.lastIndexOf(\"/\") + 1);\n            // Separate the prefix used\n            prefix = message.type_url.substring(0, message.type_url.lastIndexOf(\"/\") + 1);\n            var type = this.lookup(name);\n            /* istanbul ignore else */ if (type) message = type.decode(message.value);\n        }\n        // wrap value if unmapped\n        if (!(message instanceof this.ctor) && message instanceof Message) {\n            var object = message.$type.toObject(message, options);\n            var messageName = message.$type.fullName[0] === \".\" ? message.$type.fullName.slice(1) : message.$type.fullName;\n            // Default to type.googleapis.com prefix if no prefix is used\n            if (prefix === \"\") {\n                prefix = googleApi;\n            }\n            name = prefix + messageName;\n            object[\"@type\"] = name;\n            return object;\n        }\n        return this.toObject(message, options);\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3dyYXBwZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWI7Ozs7Q0FJQyxHQUNELElBQUlBLFdBQVdDO0FBRWYsSUFBSUMsVUFBVUMsbUJBQU9BLENBQUMsa0VBQVc7QUFFakM7Ozs7Ozs7Q0FPQyxHQUVEOzs7Ozs7OztDQVFDLEdBRUQ7Ozs7O0NBS0MsR0FFRCx5QkFBeUI7QUFDekJILFFBQVEsQ0FBQyx1QkFBdUIsR0FBRztJQUUvQkksWUFBWSxTQUFTQyxNQUFNO1FBRXZCLDhCQUE4QjtRQUM5QixJQUFJQSxVQUFVQSxNQUFNLENBQUMsUUFBUSxFQUFFO1lBQzFCLHdEQUF3RDtZQUN6RCxJQUFJQyxPQUFPRCxNQUFNLENBQUMsUUFBUSxDQUFDRSxTQUFTLENBQUNGLE1BQU0sQ0FBQyxRQUFRLENBQUNHLFdBQVcsQ0FBQyxPQUFPO1lBQ3hFLElBQUlDLE9BQU8sSUFBSSxDQUFDQyxNQUFNLENBQUNKO1lBQ3ZCLHdCQUF3QixHQUN4QixJQUFJRyxNQUFNO2dCQUNOLHVDQUF1QztnQkFDdkMsSUFBSUUsV0FBV04sTUFBTSxDQUFDLFFBQVEsQ0FBQ08sTUFBTSxDQUFDLE9BQU8sTUFDekNQLE1BQU0sQ0FBQyxRQUFRLENBQUNRLEtBQUssQ0FBQyxLQUFLUixNQUFNLENBQUMsUUFBUTtnQkFDOUMsOERBQThEO2dCQUM5RCxJQUFJTSxTQUFTRyxPQUFPLENBQUMsU0FBUyxDQUFDLEdBQUc7b0JBQzlCSCxXQUFXLE1BQU1BO2dCQUNyQjtnQkFDQSxPQUFPLElBQUksQ0FBQ0ksTUFBTSxDQUFDO29CQUNmSixVQUFVQTtvQkFDVkssT0FBT1AsS0FBS1EsTUFBTSxDQUFDUixLQUFLTCxVQUFVLENBQUNDLFNBQVNhLE1BQU07Z0JBQ3REO1lBQ0o7UUFDSjtRQUVBLE9BQU8sSUFBSSxDQUFDZCxVQUFVLENBQUNDO0lBQzNCO0lBRUFjLFVBQVUsU0FBU0MsT0FBTyxFQUFFQyxPQUFPO1FBRS9CLGlCQUFpQjtRQUNqQixJQUFJQyxZQUFZO1FBQ2hCLElBQUlDLFNBQVM7UUFDYixJQUFJakIsT0FBTztRQUVYLHlDQUF5QztRQUN6QyxJQUFJZSxXQUFXQSxRQUFRRyxJQUFJLElBQUlKLFFBQVFULFFBQVEsSUFBSVMsUUFBUUosS0FBSyxFQUFFO1lBQzlELHdEQUF3RDtZQUN4RFYsT0FBT2MsUUFBUVQsUUFBUSxDQUFDSixTQUFTLENBQUNhLFFBQVFULFFBQVEsQ0FBQ0gsV0FBVyxDQUFDLE9BQU87WUFDdEUsMkJBQTJCO1lBQzNCZSxTQUFTSCxRQUFRVCxRQUFRLENBQUNKLFNBQVMsQ0FBQyxHQUFHYSxRQUFRVCxRQUFRLENBQUNILFdBQVcsQ0FBQyxPQUFPO1lBQzNFLElBQUlDLE9BQU8sSUFBSSxDQUFDQyxNQUFNLENBQUNKO1lBQ3ZCLHdCQUF3QixHQUN4QixJQUFJRyxNQUNBVyxVQUFVWCxLQUFLZ0IsTUFBTSxDQUFDTCxRQUFRSixLQUFLO1FBQzNDO1FBRUEseUJBQXlCO1FBQ3pCLElBQUksQ0FBRUksQ0FBQUEsbUJBQW1CLElBQUksQ0FBQ00sSUFBSSxLQUFLTixtQkFBbUJsQixTQUFTO1lBQy9ELElBQUlHLFNBQVNlLFFBQVFPLEtBQUssQ0FBQ1IsUUFBUSxDQUFDQyxTQUFTQztZQUM3QyxJQUFJTyxjQUFjUixRQUFRTyxLQUFLLENBQUNFLFFBQVEsQ0FBQyxFQUFFLEtBQUssTUFDNUNULFFBQVFPLEtBQUssQ0FBQ0UsUUFBUSxDQUFDaEIsS0FBSyxDQUFDLEtBQUtPLFFBQVFPLEtBQUssQ0FBQ0UsUUFBUTtZQUM1RCw2REFBNkQ7WUFDN0QsSUFBSU4sV0FBVyxJQUFJO2dCQUNmQSxTQUFTRDtZQUNiO1lBQ0FoQixPQUFPaUIsU0FBU0s7WUFDaEJ2QixNQUFNLENBQUMsUUFBUSxHQUFHQztZQUNsQixPQUFPRDtRQUNYO1FBRUEsT0FBTyxJQUFJLENBQUNjLFFBQVEsQ0FBQ0MsU0FBU0M7SUFDbEM7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvd3JhcHBlcnMuanM/YTNjNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBXcmFwcGVycyBmb3IgY29tbW9uIHR5cGVzLlxuICogQHR5cGUge09iamVjdC48c3RyaW5nLElXcmFwcGVyPn1cbiAqIEBjb25zdFxuICovXG52YXIgd3JhcHBlcnMgPSBleHBvcnRzO1xuXG52YXIgTWVzc2FnZSA9IHJlcXVpcmUoXCIuL21lc3NhZ2VcIik7XG5cbi8qKlxuICogRnJvbSBvYmplY3QgY29udmVydGVyIHBhcnQgb2YgYW4ge0BsaW5rIElXcmFwcGVyfS5cbiAqIEB0eXBlZGVmIFdyYXBwZXJGcm9tT2JqZWN0Q29udmVydGVyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvYmplY3QgUGxhaW4gb2JqZWN0XG4gKiBAcmV0dXJucyB7TWVzc2FnZTx7fT59IE1lc3NhZ2UgaW5zdGFuY2VcbiAqIEB0aGlzIFR5cGVcbiAqL1xuXG4vKipcbiAqIFRvIG9iamVjdCBjb252ZXJ0ZXIgcGFydCBvZiBhbiB7QGxpbmsgSVdyYXBwZXJ9LlxuICogQHR5cGVkZWYgV3JhcHBlclRvT2JqZWN0Q29udmVydGVyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcGFyYW0ge01lc3NhZ2U8e30+fSBtZXNzYWdlIE1lc3NhZ2UgaW5zdGFuY2VcbiAqIEBwYXJhbSB7SUNvbnZlcnNpb25PcHRpb25zfSBbb3B0aW9uc10gQ29udmVyc2lvbiBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IFBsYWluIG9iamVjdFxuICogQHRoaXMgVHlwZVxuICovXG5cbi8qKlxuICogQ29tbW9uIHR5cGUgd3JhcHBlciBwYXJ0IG9mIHtAbGluayB3cmFwcGVyc30uXG4gKiBAaW50ZXJmYWNlIElXcmFwcGVyXG4gKiBAcHJvcGVydHkge1dyYXBwZXJGcm9tT2JqZWN0Q29udmVydGVyfSBbZnJvbU9iamVjdF0gRnJvbSBvYmplY3QgY29udmVydGVyXG4gKiBAcHJvcGVydHkge1dyYXBwZXJUb09iamVjdENvbnZlcnRlcn0gW3RvT2JqZWN0XSBUbyBvYmplY3QgY29udmVydGVyXG4gKi9cblxuLy8gQ3VzdG9tIHdyYXBwZXIgZm9yIEFueVxud3JhcHBlcnNbXCIuZ29vZ2xlLnByb3RvYnVmLkFueVwiXSA9IHtcblxuICAgIGZyb21PYmplY3Q6IGZ1bmN0aW9uKG9iamVjdCkge1xuXG4gICAgICAgIC8vIHVud3JhcCB2YWx1ZSB0eXBlIGlmIG1hcHBlZFxuICAgICAgICBpZiAob2JqZWN0ICYmIG9iamVjdFtcIkB0eXBlXCJdKSB7XG4gICAgICAgICAgICAgLy8gT25seSB1c2UgZnVsbHkgcXVhbGlmaWVkIHR5cGUgbmFtZSBhZnRlciB0aGUgbGFzdCAnLydcbiAgICAgICAgICAgIHZhciBuYW1lID0gb2JqZWN0W1wiQHR5cGVcIl0uc3Vic3RyaW5nKG9iamVjdFtcIkB0eXBlXCJdLmxhc3RJbmRleE9mKFwiL1wiKSArIDEpO1xuICAgICAgICAgICAgdmFyIHR5cGUgPSB0aGlzLmxvb2t1cChuYW1lKTtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICBpZiAodHlwZSkge1xuICAgICAgICAgICAgICAgIC8vIHR5cGVfdXJsIGRvZXMgbm90IGFjY2VwdCBsZWFkaW5nIFwiLlwiXG4gICAgICAgICAgICAgICAgdmFyIHR5cGVfdXJsID0gb2JqZWN0W1wiQHR5cGVcIl0uY2hhckF0KDApID09PSBcIi5cIiA/XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdFtcIkB0eXBlXCJdLnNsaWNlKDEpIDogb2JqZWN0W1wiQHR5cGVcIl07XG4gICAgICAgICAgICAgICAgLy8gdHlwZV91cmwgcHJlZml4IGlzIG9wdGlvbmFsLCBidXQgcGF0aCBzZXBlcmF0b3IgaXMgcmVxdWlyZWRcbiAgICAgICAgICAgICAgICBpZiAodHlwZV91cmwuaW5kZXhPZihcIi9cIikgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGVfdXJsID0gXCIvXCIgKyB0eXBlX3VybDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZV91cmw6IHR5cGVfdXJsLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdHlwZS5lbmNvZGUodHlwZS5mcm9tT2JqZWN0KG9iamVjdCkpLmZpbmlzaCgpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5mcm9tT2JqZWN0KG9iamVjdCk7XG4gICAgfSxcblxuICAgIHRvT2JqZWN0OiBmdW5jdGlvbihtZXNzYWdlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgLy8gRGVmYXVsdCBwcmVmaXhcbiAgICAgICAgdmFyIGdvb2dsZUFwaSA9IFwidHlwZS5nb29nbGVhcGlzLmNvbS9cIjtcbiAgICAgICAgdmFyIHByZWZpeCA9IFwiXCI7XG4gICAgICAgIHZhciBuYW1lID0gXCJcIjtcblxuICAgICAgICAvLyBkZWNvZGUgdmFsdWUgaWYgcmVxdWVzdGVkIGFuZCB1bm1hcHBlZFxuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmpzb24gJiYgbWVzc2FnZS50eXBlX3VybCAmJiBtZXNzYWdlLnZhbHVlKSB7XG4gICAgICAgICAgICAvLyBPbmx5IHVzZSBmdWxseSBxdWFsaWZpZWQgdHlwZSBuYW1lIGFmdGVyIHRoZSBsYXN0ICcvJ1xuICAgICAgICAgICAgbmFtZSA9IG1lc3NhZ2UudHlwZV91cmwuc3Vic3RyaW5nKG1lc3NhZ2UudHlwZV91cmwubGFzdEluZGV4T2YoXCIvXCIpICsgMSk7XG4gICAgICAgICAgICAvLyBTZXBhcmF0ZSB0aGUgcHJlZml4IHVzZWRcbiAgICAgICAgICAgIHByZWZpeCA9IG1lc3NhZ2UudHlwZV91cmwuc3Vic3RyaW5nKDAsIG1lc3NhZ2UudHlwZV91cmwubGFzdEluZGV4T2YoXCIvXCIpICsgMSk7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IHRoaXMubG9va3VwKG5hbWUpO1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmICh0eXBlKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSB0eXBlLmRlY29kZShtZXNzYWdlLnZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdyYXAgdmFsdWUgaWYgdW5tYXBwZWRcbiAgICAgICAgaWYgKCEobWVzc2FnZSBpbnN0YW5jZW9mIHRoaXMuY3RvcikgJiYgbWVzc2FnZSBpbnN0YW5jZW9mIE1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHZhciBvYmplY3QgPSBtZXNzYWdlLiR0eXBlLnRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpO1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2VOYW1lID0gbWVzc2FnZS4kdHlwZS5mdWxsTmFtZVswXSA9PT0gXCIuXCIgP1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuJHR5cGUuZnVsbE5hbWUuc2xpY2UoMSkgOiBtZXNzYWdlLiR0eXBlLmZ1bGxOYW1lO1xuICAgICAgICAgICAgLy8gRGVmYXVsdCB0byB0eXBlLmdvb2dsZWFwaXMuY29tIHByZWZpeCBpZiBubyBwcmVmaXggaXMgdXNlZFxuICAgICAgICAgICAgaWYgKHByZWZpeCA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgIHByZWZpeCA9IGdvb2dsZUFwaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5hbWUgPSBwcmVmaXggKyBtZXNzYWdlTmFtZTtcbiAgICAgICAgICAgIG9iamVjdFtcIkB0eXBlXCJdID0gbmFtZTtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy50b09iamVjdChtZXNzYWdlLCBvcHRpb25zKTtcbiAgICB9XG59O1xuIl0sIm5hbWVzIjpbIndyYXBwZXJzIiwiZXhwb3J0cyIsIk1lc3NhZ2UiLCJyZXF1aXJlIiwiZnJvbU9iamVjdCIsIm9iamVjdCIsIm5hbWUiLCJzdWJzdHJpbmciLCJsYXN0SW5kZXhPZiIsInR5cGUiLCJsb29rdXAiLCJ0eXBlX3VybCIsImNoYXJBdCIsInNsaWNlIiwiaW5kZXhPZiIsImNyZWF0ZSIsInZhbHVlIiwiZW5jb2RlIiwiZmluaXNoIiwidG9PYmplY3QiLCJtZXNzYWdlIiwib3B0aW9ucyIsImdvb2dsZUFwaSIsInByZWZpeCIsImpzb24iLCJkZWNvZGUiLCJjdG9yIiwiJHR5cGUiLCJtZXNzYWdlTmFtZSIsImZ1bGxOYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/protobufjs/src/wrappers.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/src/writer.js":
/*!************************************************!*\
  !*** ../node_modules/protobufjs/src/writer.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = Writer;\nvar util = __webpack_require__(/*! ./util/minimal */ \"(ssr)/../node_modules/protobufjs/src/util/minimal.js\");\nvar BufferWriter; // cyclic\nvar LongBits = util.LongBits, base64 = util.base64, utf8 = util.utf8;\n/**\n * Constructs a new writer operation instance.\n * @classdesc Scheduled writer operation.\n * @constructor\n * @param {function(*, Uint8Array, number)} fn Function to call\n * @param {number} len Value byte length\n * @param {*} val Value to write\n * @ignore\n */ function Op(fn, len, val) {\n    /**\n     * Function to call.\n     * @type {function(Uint8Array, number, *)}\n     */ this.fn = fn;\n    /**\n     * Value byte length.\n     * @type {number}\n     */ this.len = len;\n    /**\n     * Next operation.\n     * @type {Writer.Op|undefined}\n     */ this.next = undefined;\n    /**\n     * Value to write.\n     * @type {*}\n     */ this.val = val; // type varies\n}\n/* istanbul ignore next */ function noop() {} // eslint-disable-line no-empty-function\n/**\n * Constructs a new writer state instance.\n * @classdesc Copied writer state.\n * @memberof Writer\n * @constructor\n * @param {Writer} writer Writer to copy state from\n * @ignore\n */ function State(writer) {\n    /**\n     * Current head.\n     * @type {Writer.Op}\n     */ this.head = writer.head;\n    /**\n     * Current tail.\n     * @type {Writer.Op}\n     */ this.tail = writer.tail;\n    /**\n     * Current buffer length.\n     * @type {number}\n     */ this.len = writer.len;\n    /**\n     * Next state.\n     * @type {State|null}\n     */ this.next = writer.states;\n}\n/**\n * Constructs a new writer instance.\n * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n */ function Writer() {\n    /**\n     * Current length.\n     * @type {number}\n     */ this.len = 0;\n    /**\n     * Operations head.\n     * @type {Object}\n     */ this.head = new Op(noop, 0, 0);\n    /**\n     * Operations tail\n     * @type {Object}\n     */ this.tail = this.head;\n    /**\n     * Linked forked states.\n     * @type {Object|null}\n     */ this.states = null;\n// When a value is written, the writer calculates its byte length and puts it into a linked\n// list of operations to perform when finish() is called. This both allows us to allocate\n// buffers of the exact required size and reduces the amount of work we have to do compared\n// to first calculating over objects and then encoding over objects. In our case, the encoding\n// part is just a linked list walk calling operations with already prepared values.\n}\nvar create = function create() {\n    return util.Buffer ? function create_buffer_setup() {\n        return (Writer.create = function create_buffer() {\n            return new BufferWriter();\n        })();\n    } : function create_array() {\n        return new Writer();\n    };\n};\n/**\n * Creates a new writer.\n * @function\n * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}\n */ Writer.create = create();\n/**\n * Allocates a buffer of the specified size.\n * @param {number} size Buffer size\n * @returns {Uint8Array} Buffer\n */ Writer.alloc = function alloc(size) {\n    return new util.Array(size);\n};\n// Use Uint8Array buffer pool in the browser, just like node does with buffers\n/* istanbul ignore else */ if (util.Array !== Array) Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);\n/**\n * Pushes a new operation to the queue.\n * @param {function(Uint8Array, number, *)} fn Function to call\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @returns {Writer} `this`\n * @private\n */ Writer.prototype._push = function push(fn, len, val) {\n    this.tail = this.tail.next = new Op(fn, len, val);\n    this.len += len;\n    return this;\n};\nfunction writeByte(val, buf, pos) {\n    buf[pos] = val & 255;\n}\nfunction writeVarint32(val, buf, pos) {\n    while(val > 127){\n        buf[pos++] = val & 127 | 128;\n        val >>>= 7;\n    }\n    buf[pos] = val;\n}\n/**\n * Constructs a new varint writer operation instance.\n * @classdesc Scheduled varint writer operation.\n * @extends Op\n * @constructor\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @ignore\n */ function VarintOp(len, val) {\n    this.len = len;\n    this.next = undefined;\n    this.val = val;\n}\nVarintOp.prototype = Object.create(Op.prototype);\nVarintOp.prototype.fn = writeVarint32;\n/**\n * Writes an unsigned 32 bit value as a varint.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */ Writer.prototype.uint32 = function write_uint32(value) {\n    // here, the call to this.push has been inlined and a varint specific Op subclass is used.\n    // uint32 is by far the most frequently used operation and benefits significantly from this.\n    this.len += (this.tail = this.tail.next = new VarintOp((value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5, value)).len;\n    return this;\n};\n/**\n * Writes a signed 32 bit value as a varint.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */ Writer.prototype.int32 = function write_int32(value) {\n    return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec\n     : this.uint32(value);\n};\n/**\n * Writes a 32 bit value as a varint, zig-zag encoded.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */ Writer.prototype.sint32 = function write_sint32(value) {\n    return this.uint32((value << 1 ^ value >> 31) >>> 0);\n};\nfunction writeVarint64(val, buf, pos) {\n    while(val.hi){\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;\n        val.hi >>>= 7;\n    }\n    while(val.lo > 127){\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = val.lo >>> 7;\n    }\n    buf[pos++] = val.lo;\n}\n/**\n * Writes an unsigned 64 bit value as a varint.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */ Writer.prototype.uint64 = function write_uint64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeVarint64, bits.length(), bits);\n};\n/**\n * Writes a signed 64 bit value as a varint.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */ Writer.prototype.int64 = Writer.prototype.uint64;\n/**\n * Writes a signed 64 bit value as a varint, zig-zag encoded.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */ Writer.prototype.sint64 = function write_sint64(value) {\n    var bits = LongBits.from(value).zzEncode();\n    return this._push(writeVarint64, bits.length(), bits);\n};\n/**\n * Writes a boolish value as a varint.\n * @param {boolean} value Value to write\n * @returns {Writer} `this`\n */ Writer.prototype.bool = function write_bool(value) {\n    return this._push(writeByte, 1, value ? 1 : 0);\n};\nfunction writeFixed32(val, buf, pos) {\n    buf[pos] = val & 255;\n    buf[pos + 1] = val >>> 8 & 255;\n    buf[pos + 2] = val >>> 16 & 255;\n    buf[pos + 3] = val >>> 24;\n}\n/**\n * Writes an unsigned 32 bit value as fixed 32 bits.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */ Writer.prototype.fixed32 = function write_fixed32(value) {\n    return this._push(writeFixed32, 4, value >>> 0);\n};\n/**\n * Writes a signed 32 bit value as fixed 32 bits.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */ Writer.prototype.sfixed32 = Writer.prototype.fixed32;\n/**\n * Writes an unsigned 64 bit value as fixed 64 bits.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */ Writer.prototype.fixed64 = function write_fixed64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);\n};\n/**\n * Writes a signed 64 bit value as fixed 64 bits.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */ Writer.prototype.sfixed64 = Writer.prototype.fixed64;\n/**\n * Writes a float (32 bit).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */ Writer.prototype.float = function write_float(value) {\n    return this._push(util.float.writeFloatLE, 4, value);\n};\n/**\n * Writes a double (64 bit float).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */ Writer.prototype.double = function write_double(value) {\n    return this._push(util.float.writeDoubleLE, 8, value);\n};\nvar writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {\n    buf.set(val, pos); // also works for plain array values\n} : function writeBytes_for(val, buf, pos) {\n    for(var i = 0; i < val.length; ++i)buf[pos + i] = val[i];\n};\n/**\n * Writes a sequence of bytes.\n * @param {Uint8Array|string} value Buffer or base64 encoded string to write\n * @returns {Writer} `this`\n */ Writer.prototype.bytes = function write_bytes(value) {\n    var len = value.length >>> 0;\n    if (!len) return this._push(writeByte, 1, 0);\n    if (util.isString(value)) {\n        var buf = Writer.alloc(len = base64.length(value));\n        base64.decode(value, buf, 0);\n        value = buf;\n    }\n    return this.uint32(len)._push(writeBytes, len, value);\n};\n/**\n * Writes a string.\n * @param {string} value Value to write\n * @returns {Writer} `this`\n */ Writer.prototype.string = function write_string(value) {\n    var len = utf8.length(value);\n    return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);\n};\n/**\n * Forks this writer's state by pushing it to a stack.\n * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.\n * @returns {Writer} `this`\n */ Writer.prototype.fork = function fork() {\n    this.states = new State(this);\n    this.head = this.tail = new Op(noop, 0, 0);\n    this.len = 0;\n    return this;\n};\n/**\n * Resets this instance to the last state.\n * @returns {Writer} `this`\n */ Writer.prototype.reset = function reset() {\n    if (this.states) {\n        this.head = this.states.head;\n        this.tail = this.states.tail;\n        this.len = this.states.len;\n        this.states = this.states.next;\n    } else {\n        this.head = this.tail = new Op(noop, 0, 0);\n        this.len = 0;\n    }\n    return this;\n};\n/**\n * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.\n * @returns {Writer} `this`\n */ Writer.prototype.ldelim = function ldelim() {\n    var head = this.head, tail = this.tail, len = this.len;\n    this.reset().uint32(len);\n    if (len) {\n        this.tail.next = head.next; // skip noop\n        this.tail = tail;\n        this.len += len;\n    }\n    return this;\n};\n/**\n * Finishes the write operation.\n * @returns {Uint8Array} Finished buffer\n */ Writer.prototype.finish = function finish() {\n    var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;\n    while(head){\n        head.fn(head.val, buf, pos);\n        pos += head.len;\n        head = head.next;\n    }\n    // this.head = this.tail = null;\n    return buf;\n};\nWriter._configure = function(BufferWriter_) {\n    BufferWriter = BufferWriter_;\n    Writer.create = create();\n    BufferWriter._configure();\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3dyaXRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSxPQUFPQyxPQUFPLEdBQUdDO0FBRWpCLElBQUlDLE9BQVlDLG1CQUFPQSxDQUFDLDRFQUFnQjtBQUV4QyxJQUFJQyxjQUFjLFNBQVM7QUFFM0IsSUFBSUMsV0FBWUgsS0FBS0csUUFBUSxFQUN6QkMsU0FBWUosS0FBS0ksTUFBTSxFQUN2QkMsT0FBWUwsS0FBS0ssSUFBSTtBQUV6Qjs7Ozs7Ozs7Q0FRQyxHQUNELFNBQVNDLEdBQUdDLEVBQUUsRUFBRUMsR0FBRyxFQUFFQyxHQUFHO0lBRXBCOzs7S0FHQyxHQUNELElBQUksQ0FBQ0YsRUFBRSxHQUFHQTtJQUVWOzs7S0FHQyxHQUNELElBQUksQ0FBQ0MsR0FBRyxHQUFHQTtJQUVYOzs7S0FHQyxHQUNELElBQUksQ0FBQ0UsSUFBSSxHQUFHQztJQUVaOzs7S0FHQyxHQUNELElBQUksQ0FBQ0YsR0FBRyxHQUFHQSxLQUFLLGNBQWM7QUFDbEM7QUFFQSx3QkFBd0IsR0FDeEIsU0FBU0csUUFBUSxFQUFFLHdDQUF3QztBQUUzRDs7Ozs7OztDQU9DLEdBQ0QsU0FBU0MsTUFBTUMsTUFBTTtJQUVqQjs7O0tBR0MsR0FDRCxJQUFJLENBQUNDLElBQUksR0FBR0QsT0FBT0MsSUFBSTtJQUV2Qjs7O0tBR0MsR0FDRCxJQUFJLENBQUNDLElBQUksR0FBR0YsT0FBT0UsSUFBSTtJQUV2Qjs7O0tBR0MsR0FDRCxJQUFJLENBQUNSLEdBQUcsR0FBR00sT0FBT04sR0FBRztJQUVyQjs7O0tBR0MsR0FDRCxJQUFJLENBQUNFLElBQUksR0FBR0ksT0FBT0csTUFBTTtBQUM3QjtBQUVBOzs7O0NBSUMsR0FDRCxTQUFTbEI7SUFFTDs7O0tBR0MsR0FDRCxJQUFJLENBQUNTLEdBQUcsR0FBRztJQUVYOzs7S0FHQyxHQUNELElBQUksQ0FBQ08sSUFBSSxHQUFHLElBQUlULEdBQUdNLE1BQU0sR0FBRztJQUU1Qjs7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Oi8vbXktYXBwLy4uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy93cml0ZXIuanM/OGM4ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gV3JpdGVyO1xuXG52YXIgdXRpbCAgICAgID0gcmVxdWlyZShcIi4vdXRpbC9taW5pbWFsXCIpO1xuXG52YXIgQnVmZmVyV3JpdGVyOyAvLyBjeWNsaWNcblxudmFyIExvbmdCaXRzICA9IHV0aWwuTG9uZ0JpdHMsXG4gICAgYmFzZTY0ICAgID0gdXRpbC5iYXNlNjQsXG4gICAgdXRmOCAgICAgID0gdXRpbC51dGY4O1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgd3JpdGVyIG9wZXJhdGlvbiBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgU2NoZWR1bGVkIHdyaXRlciBvcGVyYXRpb24uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgVWludDhBcnJheSwgbnVtYmVyKX0gZm4gRnVuY3Rpb24gdG8gY2FsbFxuICogQHBhcmFtIHtudW1iZXJ9IGxlbiBWYWx1ZSBieXRlIGxlbmd0aFxuICogQHBhcmFtIHsqfSB2YWwgVmFsdWUgdG8gd3JpdGVcbiAqIEBpZ25vcmVcbiAqL1xuZnVuY3Rpb24gT3AoZm4sIGxlbiwgdmFsKSB7XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB0byBjYWxsLlxuICAgICAqIEB0eXBlIHtmdW5jdGlvbihVaW50OEFycmF5LCBudW1iZXIsICopfVxuICAgICAqL1xuICAgIHRoaXMuZm4gPSBmbjtcblxuICAgIC8qKlxuICAgICAqIFZhbHVlIGJ5dGUgbGVuZ3RoLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5sZW4gPSBsZW47XG5cbiAgICAvKipcbiAgICAgKiBOZXh0IG9wZXJhdGlvbi5cbiAgICAgKiBAdHlwZSB7V3JpdGVyLk9wfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLm5leHQgPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBWYWx1ZSB0byB3cml0ZS5cbiAgICAgKiBAdHlwZSB7Kn1cbiAgICAgKi9cbiAgICB0aGlzLnZhbCA9IHZhbDsgLy8gdHlwZSB2YXJpZXNcbn1cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIG5vb3AoKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWVtcHR5LWZ1bmN0aW9uXG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyB3cml0ZXIgc3RhdGUgaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIENvcGllZCB3cml0ZXIgc3RhdGUuXG4gKiBAbWVtYmVyb2YgV3JpdGVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7V3JpdGVyfSB3cml0ZXIgV3JpdGVyIHRvIGNvcHkgc3RhdGUgZnJvbVxuICogQGlnbm9yZVxuICovXG5mdW5jdGlvbiBTdGF0ZSh3cml0ZXIpIHtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgaGVhZC5cbiAgICAgKiBAdHlwZSB7V3JpdGVyLk9wfVxuICAgICAqL1xuICAgIHRoaXMuaGVhZCA9IHdyaXRlci5oZWFkO1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCB0YWlsLlxuICAgICAqIEB0eXBlIHtXcml0ZXIuT3B9XG4gICAgICovXG4gICAgdGhpcy50YWlsID0gd3JpdGVyLnRhaWw7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IGJ1ZmZlciBsZW5ndGguXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxlbiA9IHdyaXRlci5sZW47XG5cbiAgICAvKipcbiAgICAgKiBOZXh0IHN0YXRlLlxuICAgICAqIEB0eXBlIHtTdGF0ZXxudWxsfVxuICAgICAqL1xuICAgIHRoaXMubmV4dCA9IHdyaXRlci5zdGF0ZXM7XG59XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyB3cml0ZXIgaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIFdpcmUgZm9ybWF0IHdyaXRlciB1c2luZyBgVWludDhBcnJheWAgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgYEFycmF5YC5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBXcml0ZXIoKSB7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IGxlbmd0aC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubGVuID0gMDtcblxuICAgIC8qKlxuICAgICAqIE9wZXJhdGlvbnMgaGVhZC5cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMuaGVhZCA9IG5ldyBPcChub29wLCAwLCAwKTtcblxuICAgIC8qKlxuICAgICAqIE9wZXJhdGlvbnMgdGFpbFxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy50YWlsID0gdGhpcy5oZWFkO1xuXG4gICAgLyoqXG4gICAgICogTGlua2VkIGZvcmtlZCBzdGF0ZXMuXG4gICAgICogQHR5cGUge09iamVjdHxudWxsfVxuICAgICAqL1xuICAgIHRoaXMuc3RhdGVzID0gbnVsbDtcblxuICAgIC8vIFdoZW4gYSB2YWx1ZSBpcyB3cml0dGVuLCB0aGUgd3JpdGVyIGNhbGN1bGF0ZXMgaXRzIGJ5dGUgbGVuZ3RoIGFuZCBwdXRzIGl0IGludG8gYSBsaW5rZWRcbiAgICAvLyBsaXN0IG9mIG9wZXJhdGlvbnMgdG8gcGVyZm9ybSB3aGVuIGZpbmlzaCgpIGlzIGNhbGxlZC4gVGhpcyBib3RoIGFsbG93cyB1cyB0byBhbGxvY2F0ZVxuICAgIC8vIGJ1ZmZlcnMgb2YgdGhlIGV4YWN0IHJlcXVpcmVkIHNpemUgYW5kIHJlZHVjZXMgdGhlIGFtb3VudCBvZiB3b3JrIHdlIGhhdmUgdG8gZG8gY29tcGFyZWRcbiAgICAvLyB0byBmaXJzdCBjYWxjdWxhdGluZyBvdmVyIG9iamVjdHMgYW5kIHRoZW4gZW5jb2Rpbmcgb3ZlciBvYmplY3RzLiBJbiBvdXIgY2FzZSwgdGhlIGVuY29kaW5nXG4gICAgLy8gcGFydCBpcyBqdXN0IGEgbGlua2VkIGxpc3Qgd2FsayBjYWxsaW5nIG9wZXJhdGlvbnMgd2l0aCBhbHJlYWR5IHByZXBhcmVkIHZhbHVlcy5cbn1cblxudmFyIGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgICByZXR1cm4gdXRpbC5CdWZmZXJcbiAgICAgICAgPyBmdW5jdGlvbiBjcmVhdGVfYnVmZmVyX3NldHVwKCkge1xuICAgICAgICAgICAgcmV0dXJuIChXcml0ZXIuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlX2J1ZmZlcigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcldyaXRlcigpO1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICA6IGZ1bmN0aW9uIGNyZWF0ZV9hcnJheSgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgV3JpdGVyKCk7XG4gICAgICAgIH07XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgd3JpdGVyLlxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7QnVmZmVyV3JpdGVyfFdyaXRlcn0gQSB7QGxpbmsgQnVmZmVyV3JpdGVyfSB3aGVuIEJ1ZmZlcnMgYXJlIHN1cHBvcnRlZCwgb3RoZXJ3aXNlIGEge0BsaW5rIFdyaXRlcn1cbiAqL1xuV3JpdGVyLmNyZWF0ZSA9IGNyZWF0ZSgpO1xuXG4vKipcbiAqIEFsbG9jYXRlcyBhIGJ1ZmZlciBvZiB0aGUgc3BlY2lmaWVkIHNpemUuXG4gKiBAcGFyYW0ge251bWJlcn0gc2l6ZSBCdWZmZXIgc2l6ZVxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9IEJ1ZmZlclxuICovXG5Xcml0ZXIuYWxsb2MgPSBmdW5jdGlvbiBhbGxvYyhzaXplKSB7XG4gICAgcmV0dXJuIG5ldyB1dGlsLkFycmF5KHNpemUpO1xufTtcblxuLy8gVXNlIFVpbnQ4QXJyYXkgYnVmZmVyIHBvb2wgaW4gdGhlIGJyb3dzZXIsIGp1c3QgbGlrZSBub2RlIGRvZXMgd2l0aCBidWZmZXJzXG4vKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuaWYgKHV0aWwuQXJyYXkgIT09IEFycmF5KVxuICAgIFdyaXRlci5hbGxvYyA9IHV0aWwucG9vbChXcml0ZXIuYWxsb2MsIHV0aWwuQXJyYXkucHJvdG90eXBlLnN1YmFycmF5KTtcblxuLyoqXG4gKiBQdXNoZXMgYSBuZXcgb3BlcmF0aW9uIHRvIHRoZSBxdWV1ZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oVWludDhBcnJheSwgbnVtYmVyLCAqKX0gZm4gRnVuY3Rpb24gdG8gY2FsbFxuICogQHBhcmFtIHtudW1iZXJ9IGxlbiBWYWx1ZSBieXRlIGxlbmd0aFxuICogQHBhcmFtIHtudW1iZXJ9IHZhbCBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKiBAcHJpdmF0ZVxuICovXG5Xcml0ZXIucHJvdG90eXBlLl9wdXNoID0gZnVuY3Rpb24gcHVzaChmbiwgbGVuLCB2YWwpIHtcbiAgICB0aGlzLnRhaWwgPSB0aGlzLnRhaWwubmV4dCA9IG5ldyBPcChmbiwgbGVuLCB2YWwpO1xuICAgIHRoaXMubGVuICs9IGxlbjtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIHdyaXRlQnl0ZSh2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgYnVmW3Bvc10gPSB2YWwgJiAyNTU7XG59XG5cbmZ1bmN0aW9uIHdyaXRlVmFyaW50MzIodmFsLCBidWYsIHBvcykge1xuICAgIHdoaWxlICh2YWwgPiAxMjcpIHtcbiAgICAgICAgYnVmW3BvcysrXSA9IHZhbCAmIDEyNyB8IDEyODtcbiAgICAgICAgdmFsID4+Pj0gNztcbiAgICB9XG4gICAgYnVmW3Bvc10gPSB2YWw7XG59XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyB2YXJpbnQgd3JpdGVyIG9wZXJhdGlvbiBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgU2NoZWR1bGVkIHZhcmludCB3cml0ZXIgb3BlcmF0aW9uLlxuICogQGV4dGVuZHMgT3BcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtudW1iZXJ9IGxlbiBWYWx1ZSBieXRlIGxlbmd0aFxuICogQHBhcmFtIHtudW1iZXJ9IHZhbCBWYWx1ZSB0byB3cml0ZVxuICogQGlnbm9yZVxuICovXG5mdW5jdGlvbiBWYXJpbnRPcChsZW4sIHZhbCkge1xuICAgIHRoaXMubGVuID0gbGVuO1xuICAgIHRoaXMubmV4dCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnZhbCA9IHZhbDtcbn1cblxuVmFyaW50T3AucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShPcC5wcm90b3R5cGUpO1xuVmFyaW50T3AucHJvdG90eXBlLmZuID0gd3JpdGVWYXJpbnQzMjtcblxuLyoqXG4gKiBXcml0ZXMgYW4gdW5zaWduZWQgMzIgYml0IHZhbHVlIGFzIGEgdmFyaW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS51aW50MzIgPSBmdW5jdGlvbiB3cml0ZV91aW50MzIodmFsdWUpIHtcbiAgICAvLyBoZXJlLCB0aGUgY2FsbCB0byB0aGlzLnB1c2ggaGFzIGJlZW4gaW5saW5lZCBhbmQgYSB2YXJpbnQgc3BlY2lmaWMgT3Agc3ViY2xhc3MgaXMgdXNlZC5cbiAgICAvLyB1aW50MzIgaXMgYnkgZmFyIHRoZSBtb3N0IGZyZXF1ZW50bHkgdXNlZCBvcGVyYXRpb24gYW5kIGJlbmVmaXRzIHNpZ25pZmljYW50bHkgZnJvbSB0aGlzLlxuICAgIHRoaXMubGVuICs9ICh0aGlzLnRhaWwgPSB0aGlzLnRhaWwubmV4dCA9IG5ldyBWYXJpbnRPcChcbiAgICAgICAgKHZhbHVlID0gdmFsdWUgPj4+IDApXG4gICAgICAgICAgICAgICAgPCAxMjggICAgICAgPyAxXG4gICAgICAgIDogdmFsdWUgPCAxNjM4NCAgICAgPyAyXG4gICAgICAgIDogdmFsdWUgPCAyMDk3MTUyICAgPyAzXG4gICAgICAgIDogdmFsdWUgPCAyNjg0MzU0NTYgPyA0XG4gICAgICAgIDogICAgICAgICAgICAgICAgICAgICA1LFxuICAgIHZhbHVlKSkubGVuO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBzaWduZWQgMzIgYml0IHZhbHVlIGFzIGEgdmFyaW50LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLmludDMyID0gZnVuY3Rpb24gd3JpdGVfaW50MzIodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPCAwXG4gICAgICAgID8gdGhpcy5fcHVzaCh3cml0ZVZhcmludDY0LCAxMCwgTG9uZ0JpdHMuZnJvbU51bWJlcih2YWx1ZSkpIC8vIDEwIGJ5dGVzIHBlciBzcGVjXG4gICAgICAgIDogdGhpcy51aW50MzIodmFsdWUpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSAzMiBiaXQgdmFsdWUgYXMgYSB2YXJpbnQsIHppZy16YWcgZW5jb2RlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuc2ludDMyID0gZnVuY3Rpb24gd3JpdGVfc2ludDMyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMudWludDMyKCh2YWx1ZSA8PCAxIF4gdmFsdWUgPj4gMzEpID4+PiAwKTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlVmFyaW50NjQodmFsLCBidWYsIHBvcykge1xuICAgIHdoaWxlICh2YWwuaGkpIHtcbiAgICAgICAgYnVmW3BvcysrXSA9IHZhbC5sbyAmIDEyNyB8IDEyODtcbiAgICAgICAgdmFsLmxvID0gKHZhbC5sbyA+Pj4gNyB8IHZhbC5oaSA8PCAyNSkgPj4+IDA7XG4gICAgICAgIHZhbC5oaSA+Pj49IDc7XG4gICAgfVxuICAgIHdoaWxlICh2YWwubG8gPiAxMjcpIHtcbiAgICAgICAgYnVmW3BvcysrXSA9IHZhbC5sbyAmIDEyNyB8IDEyODtcbiAgICAgICAgdmFsLmxvID0gdmFsLmxvID4+PiA3O1xuICAgIH1cbiAgICBidWZbcG9zKytdID0gdmFsLmxvO1xufVxuXG4vKipcbiAqIFdyaXRlcyBhbiB1bnNpZ25lZCA2NCBiaXQgdmFsdWUgYXMgYSB2YXJpbnQuXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfHN0cmluZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgdmFsdWVgIGlzIGEgc3RyaW5nIGFuZCBubyBsb25nIGxpYnJhcnkgaXMgcHJlc2VudC5cbiAqL1xuV3JpdGVyLnByb3RvdHlwZS51aW50NjQgPSBmdW5jdGlvbiB3cml0ZV91aW50NjQodmFsdWUpIHtcbiAgICB2YXIgYml0cyA9IExvbmdCaXRzLmZyb20odmFsdWUpO1xuICAgIHJldHVybiB0aGlzLl9wdXNoKHdyaXRlVmFyaW50NjQsIGJpdHMubGVuZ3RoKCksIGJpdHMpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBzaWduZWQgNjQgYml0IHZhbHVlIGFzIGEgdmFyaW50LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfHN0cmluZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgdmFsdWVgIGlzIGEgc3RyaW5nIGFuZCBubyBsb25nIGxpYnJhcnkgaXMgcHJlc2VudC5cbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5pbnQ2NCA9IFdyaXRlci5wcm90b3R5cGUudWludDY0O1xuXG4vKipcbiAqIFdyaXRlcyBhIHNpZ25lZCA2NCBiaXQgdmFsdWUgYXMgYSB2YXJpbnQsIHppZy16YWcgZW5jb2RlZC5cbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ8c3RyaW5nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGB2YWx1ZWAgaXMgYSBzdHJpbmcgYW5kIG5vIGxvbmcgbGlicmFyeSBpcyBwcmVzZW50LlxuICovXG5Xcml0ZXIucHJvdG90eXBlLnNpbnQ2NCA9IGZ1bmN0aW9uIHdyaXRlX3NpbnQ2NCh2YWx1ZSkge1xuICAgIHZhciBiaXRzID0gTG9uZ0JpdHMuZnJvbSh2YWx1ZSkuenpFbmNvZGUoKTtcbiAgICByZXR1cm4gdGhpcy5fcHVzaCh3cml0ZVZhcmludDY0LCBiaXRzLmxlbmd0aCgpLCBiaXRzKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgYm9vbGlzaCB2YWx1ZSBhcyBhIHZhcmludC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLmJvb2wgPSBmdW5jdGlvbiB3cml0ZV9ib29sKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVCeXRlLCAxLCB2YWx1ZSA/IDEgOiAwKTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlRml4ZWQzMih2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgYnVmW3BvcyAgICBdID0gIHZhbCAgICAgICAgICYgMjU1O1xuICAgIGJ1Zltwb3MgKyAxXSA9ICB2YWwgPj4+IDggICAmIDI1NTtcbiAgICBidWZbcG9zICsgMl0gPSAgdmFsID4+PiAxNiAgJiAyNTU7XG4gICAgYnVmW3BvcyArIDNdID0gIHZhbCA+Pj4gMjQ7XG59XG5cbi8qKlxuICogV3JpdGVzIGFuIHVuc2lnbmVkIDMyIGJpdCB2YWx1ZSBhcyBmaXhlZCAzMiBiaXRzLlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5maXhlZDMyID0gZnVuY3Rpb24gd3JpdGVfZml4ZWQzMih2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLl9wdXNoKHdyaXRlRml4ZWQzMiwgNCwgdmFsdWUgPj4+IDApO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBzaWduZWQgMzIgYml0IHZhbHVlIGFzIGZpeGVkIDMyIGJpdHMuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuc2ZpeGVkMzIgPSBXcml0ZXIucHJvdG90eXBlLmZpeGVkMzI7XG5cbi8qKlxuICogV3JpdGVzIGFuIHVuc2lnbmVkIDY0IGJpdCB2YWx1ZSBhcyBmaXhlZCA2NCBiaXRzLlxuICogQHBhcmFtIHtMb25nfG51bWJlcnxzdHJpbmd9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYHZhbHVlYCBpcyBhIHN0cmluZyBhbmQgbm8gbG9uZyBsaWJyYXJ5IGlzIHByZXNlbnQuXG4gKi9cbldyaXRlci5wcm90b3R5cGUuZml4ZWQ2NCA9IGZ1bmN0aW9uIHdyaXRlX2ZpeGVkNjQodmFsdWUpIHtcbiAgICB2YXIgYml0cyA9IExvbmdCaXRzLmZyb20odmFsdWUpO1xuICAgIHJldHVybiB0aGlzLl9wdXNoKHdyaXRlRml4ZWQzMiwgNCwgYml0cy5sbykuX3B1c2god3JpdGVGaXhlZDMyLCA0LCBiaXRzLmhpKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgc2lnbmVkIDY0IGJpdCB2YWx1ZSBhcyBmaXhlZCA2NCBiaXRzLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfHN0cmluZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgdmFsdWVgIGlzIGEgc3RyaW5nIGFuZCBubyBsb25nIGxpYnJhcnkgaXMgcHJlc2VudC5cbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5zZml4ZWQ2NCA9IFdyaXRlci5wcm90b3R5cGUuZml4ZWQ2NDtcblxuLyoqXG4gKiBXcml0ZXMgYSBmbG9hdCAoMzIgYml0KS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5mbG9hdCA9IGZ1bmN0aW9uIHdyaXRlX2Zsb2F0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2godXRpbC5mbG9hdC53cml0ZUZsb2F0TEUsIDQsIHZhbHVlKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgZG91YmxlICg2NCBiaXQgZmxvYXQpLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLmRvdWJsZSA9IGZ1bmN0aW9uIHdyaXRlX2RvdWJsZSh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLl9wdXNoKHV0aWwuZmxvYXQud3JpdGVEb3VibGVMRSwgOCwgdmFsdWUpO1xufTtcblxudmFyIHdyaXRlQnl0ZXMgPSB1dGlsLkFycmF5LnByb3RvdHlwZS5zZXRcbiAgICA/IGZ1bmN0aW9uIHdyaXRlQnl0ZXNfc2V0KHZhbCwgYnVmLCBwb3MpIHtcbiAgICAgICAgYnVmLnNldCh2YWwsIHBvcyk7IC8vIGFsc28gd29ya3MgZm9yIHBsYWluIGFycmF5IHZhbHVlc1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIDogZnVuY3Rpb24gd3JpdGVCeXRlc19mb3IodmFsLCBidWYsIHBvcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbC5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIGJ1Zltwb3MgKyBpXSA9IHZhbFtpXTtcbiAgICB9O1xuXG4vKipcbiAqIFdyaXRlcyBhIHNlcXVlbmNlIG9mIGJ5dGVzLlxuICogQHBhcmFtIHtVaW50OEFycmF5fHN0cmluZ30gdmFsdWUgQnVmZmVyIG9yIGJhc2U2NCBlbmNvZGVkIHN0cmluZyB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuYnl0ZXMgPSBmdW5jdGlvbiB3cml0ZV9ieXRlcyh2YWx1ZSkge1xuICAgIHZhciBsZW4gPSB2YWx1ZS5sZW5ndGggPj4+IDA7XG4gICAgaWYgKCFsZW4pXG4gICAgICAgIHJldHVybiB0aGlzLl9wdXNoKHdyaXRlQnl0ZSwgMSwgMCk7XG4gICAgaWYgKHV0aWwuaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIHZhciBidWYgPSBXcml0ZXIuYWxsb2MobGVuID0gYmFzZTY0Lmxlbmd0aCh2YWx1ZSkpO1xuICAgICAgICBiYXNlNjQuZGVjb2RlKHZhbHVlLCBidWYsIDApO1xuICAgICAgICB2YWx1ZSA9IGJ1ZjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudWludDMyKGxlbikuX3B1c2god3JpdGVCeXRlcywgbGVuLCB2YWx1ZSk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIHN0cmluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuc3RyaW5nID0gZnVuY3Rpb24gd3JpdGVfc3RyaW5nKHZhbHVlKSB7XG4gICAgdmFyIGxlbiA9IHV0ZjgubGVuZ3RoKHZhbHVlKTtcbiAgICByZXR1cm4gbGVuXG4gICAgICAgID8gdGhpcy51aW50MzIobGVuKS5fcHVzaCh1dGY4LndyaXRlLCBsZW4sIHZhbHVlKVxuICAgICAgICA6IHRoaXMuX3B1c2god3JpdGVCeXRlLCAxLCAwKTtcbn07XG5cbi8qKlxuICogRm9ya3MgdGhpcyB3cml0ZXIncyBzdGF0ZSBieSBwdXNoaW5nIGl0IHRvIGEgc3RhY2suXG4gKiBDYWxsaW5nIHtAbGluayBXcml0ZXIjcmVzZXR8cmVzZXR9IG9yIHtAbGluayBXcml0ZXIjbGRlbGltfGxkZWxpbX0gcmVzZXRzIHRoZSB3cml0ZXIgdG8gdGhlIHByZXZpb3VzIHN0YXRlLlxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuZm9yayA9IGZ1bmN0aW9uIGZvcmsoKSB7XG4gICAgdGhpcy5zdGF0ZXMgPSBuZXcgU3RhdGUodGhpcyk7XG4gICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbmV3IE9wKG5vb3AsIDAsIDApO1xuICAgIHRoaXMubGVuID0gMDtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVzZXRzIHRoaXMgaW5zdGFuY2UgdG8gdGhlIGxhc3Qgc3RhdGUuXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIGlmICh0aGlzLnN0YXRlcykge1xuICAgICAgICB0aGlzLmhlYWQgICA9IHRoaXMuc3RhdGVzLmhlYWQ7XG4gICAgICAgIHRoaXMudGFpbCAgID0gdGhpcy5zdGF0ZXMudGFpbDtcbiAgICAgICAgdGhpcy5sZW4gICAgPSB0aGlzLnN0YXRlcy5sZW47XG4gICAgICAgIHRoaXMuc3RhdGVzID0gdGhpcy5zdGF0ZXMubmV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBuZXcgT3Aobm9vcCwgMCwgMCk7XG4gICAgICAgIHRoaXMubGVuICA9IDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXNldHMgdG8gdGhlIGxhc3Qgc3RhdGUgYW5kIGFwcGVuZHMgdGhlIGZvcmsgc3RhdGUncyBjdXJyZW50IHdyaXRlIGxlbmd0aCBhcyBhIHZhcmludCBmb2xsb3dlZCBieSBpdHMgb3BlcmF0aW9ucy5cbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLmxkZWxpbSA9IGZ1bmN0aW9uIGxkZWxpbSgpIHtcbiAgICB2YXIgaGVhZCA9IHRoaXMuaGVhZCxcbiAgICAgICAgdGFpbCA9IHRoaXMudGFpbCxcbiAgICAgICAgbGVuICA9IHRoaXMubGVuO1xuICAgIHRoaXMucmVzZXQoKS51aW50MzIobGVuKTtcbiAgICBpZiAobGVuKSB7XG4gICAgICAgIHRoaXMudGFpbC5uZXh0ID0gaGVhZC5uZXh0OyAvLyBza2lwIG5vb3BcbiAgICAgICAgdGhpcy50YWlsID0gdGFpbDtcbiAgICAgICAgdGhpcy5sZW4gKz0gbGVuO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRmluaXNoZXMgdGhlIHdyaXRlIG9wZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBGaW5pc2hlZCBidWZmZXJcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbiBmaW5pc2goKSB7XG4gICAgdmFyIGhlYWQgPSB0aGlzLmhlYWQubmV4dCwgLy8gc2tpcCBub29wXG4gICAgICAgIGJ1ZiAgPSB0aGlzLmNvbnN0cnVjdG9yLmFsbG9jKHRoaXMubGVuKSxcbiAgICAgICAgcG9zICA9IDA7XG4gICAgd2hpbGUgKGhlYWQpIHtcbiAgICAgICAgaGVhZC5mbihoZWFkLnZhbCwgYnVmLCBwb3MpO1xuICAgICAgICBwb3MgKz0gaGVhZC5sZW47XG4gICAgICAgIGhlYWQgPSBoZWFkLm5leHQ7XG4gICAgfVxuICAgIC8vIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gICAgcmV0dXJuIGJ1Zjtcbn07XG5cbldyaXRlci5fY29uZmlndXJlID0gZnVuY3Rpb24oQnVmZmVyV3JpdGVyXykge1xuICAgIEJ1ZmZlcldyaXRlciA9IEJ1ZmZlcldyaXRlcl87XG4gICAgV3JpdGVyLmNyZWF0ZSA9IGNyZWF0ZSgpO1xuICAgIEJ1ZmZlcldyaXRlci5fY29uZmlndXJlKCk7XG59O1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJXcml0ZXIiLCJ1dGlsIiwicmVxdWlyZSIsIkJ1ZmZlcldyaXRlciIsIkxvbmdCaXRzIiwiYmFzZTY0IiwidXRmOCIsIk9wIiwiZm4iLCJsZW4iLCJ2YWwiLCJuZXh0IiwidW5kZWZpbmVkIiwibm9vcCIsIlN0YXRlIiwid3JpdGVyIiwiaGVhZCIsInRhaWwiLCJzdGF0ZXMiLCJjcmVhdGUiLCJCdWZmZXIiLCJjcmVhdGVfYnVmZmVyX3NldHVwIiwiY3JlYXRlX2J1ZmZlciIsImNyZWF0ZV9hcnJheSIsImFsbG9jIiwic2l6ZSIsIkFycmF5IiwicG9vbCIsInByb3RvdHlwZSIsInN1YmFycmF5IiwiX3B1c2giLCJwdXNoIiwid3JpdGVCeXRlIiwiYnVmIiwicG9zIiwid3JpdGVWYXJpbnQzMiIsIlZhcmludE9wIiwiT2JqZWN0IiwidWludDMyIiwid3JpdGVfdWludDMyIiwidmFsdWUiLCJpbnQzMiIsIndyaXRlX2ludDMyIiwid3JpdGVWYXJpbnQ2NCIsImZyb21OdW1iZXIiLCJzaW50MzIiLCJ3cml0ZV9zaW50MzIiLCJoaSIsImxvIiwidWludDY0Iiwid3JpdGVfdWludDY0IiwiYml0cyIsImZyb20iLCJsZW5ndGgiLCJpbnQ2NCIsInNpbnQ2NCIsIndyaXRlX3NpbnQ2NCIsInp6RW5jb2RlIiwiYm9vbCIsIndyaXRlX2Jvb2wiLCJ3cml0ZUZpeGVkMzIiLCJmaXhlZDMyIiwid3JpdGVfZml4ZWQzMiIsInNmaXhlZDMyIiwiZml4ZWQ2NCIsIndyaXRlX2ZpeGVkNjQiLCJzZml4ZWQ2NCIsImZsb2F0Iiwid3JpdGVfZmxvYXQiLCJ3cml0ZUZsb2F0TEUiLCJkb3VibGUiLCJ3cml0ZV9kb3VibGUiLCJ3cml0ZURvdWJsZUxFIiwid3JpdGVCeXRlcyIsInNldCIsIndyaXRlQnl0ZXNfc2V0Iiwid3JpdGVCeXRlc19mb3IiLCJpIiwiYnl0ZXMiLCJ3cml0ZV9ieXRlcyIsImlzU3RyaW5nIiwiZGVjb2RlIiwic3RyaW5nIiwid3JpdGVfc3RyaW5nIiwid3JpdGUiLCJmb3JrIiwicmVzZXQiLCJsZGVsaW0iLCJmaW5pc2giLCJjb25zdHJ1Y3RvciIsIl9jb25maWd1cmUiLCJCdWZmZXJXcml0ZXJfIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/protobufjs/src/writer.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/src/writer_buffer.js":
/*!*******************************************************!*\
  !*** ../node_modules/protobufjs/src/writer_buffer.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = BufferWriter;\n// extends Writer\nvar Writer = __webpack_require__(/*! ./writer */ \"(ssr)/../node_modules/protobufjs/src/writer.js\");\n(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;\nvar util = __webpack_require__(/*! ./util/minimal */ \"(ssr)/../node_modules/protobufjs/src/util/minimal.js\");\n/**\n * Constructs a new buffer writer instance.\n * @classdesc Wire format writer using node buffers.\n * @extends Writer\n * @constructor\n */ function BufferWriter() {\n    Writer.call(this);\n}\nBufferWriter._configure = function() {\n    /**\n     * Allocates a buffer of the specified size.\n     * @function\n     * @param {number} size Buffer size\n     * @returns {Buffer} Buffer\n     */ BufferWriter.alloc = util._Buffer_allocUnsafe;\n    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === \"set\" ? function writeBytesBuffer_set(val, buf, pos) {\n        buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)\n    // also works for plain array values\n    } : function writeBytesBuffer_copy(val, buf, pos) {\n        if (val.copy) val.copy(buf, pos, 0, val.length);\n        else for(var i = 0; i < val.length;)buf[pos++] = val[i++];\n    };\n};\n/**\n * @override\n */ BufferWriter.prototype.bytes = function write_bytes_buffer(value) {\n    if (util.isString(value)) value = util._Buffer_from(value, \"base64\");\n    var len = value.length >>> 0;\n    this.uint32(len);\n    if (len) this._push(BufferWriter.writeBytesBuffer, len, value);\n    return this;\n};\nfunction writeStringBuffer(val, buf, pos) {\n    if (val.length < 40) util.utf8.write(val, buf, pos);\n    else if (buf.utf8Write) buf.utf8Write(val, pos);\n    else buf.write(val, pos);\n}\n/**\n * @override\n */ BufferWriter.prototype.string = function write_string_buffer(value) {\n    var len = util.Buffer.byteLength(value);\n    this.uint32(len);\n    if (len) this._push(writeStringBuffer, len, value);\n    return this;\n};\n/**\n * Finishes the write operation.\n * @name BufferWriter#finish\n * @function\n * @returns {Buffer} Finished buffer\n */ BufferWriter._configure();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3dyaXRlcl9idWZmZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsT0FBT0MsT0FBTyxHQUFHQztBQUVqQixpQkFBaUI7QUFDakIsSUFBSUMsU0FBU0MsbUJBQU9BLENBQUMsZ0VBQVU7QUFDOUJGLENBQUFBLGFBQWFHLFNBQVMsR0FBR0MsT0FBT0MsTUFBTSxDQUFDSixPQUFPRSxTQUFTLEdBQUdHLFdBQVcsR0FBR047QUFFekUsSUFBSU8sT0FBT0wsbUJBQU9BLENBQUMsNEVBQWdCO0FBRW5DOzs7OztDQUtDLEdBQ0QsU0FBU0Y7SUFDTEMsT0FBT08sSUFBSSxDQUFDLElBQUk7QUFDcEI7QUFFQVIsYUFBYVMsVUFBVSxHQUFHO0lBQ3RCOzs7OztLQUtDLEdBQ0RULGFBQWFVLEtBQUssR0FBR0gsS0FBS0ksbUJBQW1CO0lBRTdDWCxhQUFhWSxnQkFBZ0IsR0FBR0wsS0FBS00sTUFBTSxJQUFJTixLQUFLTSxNQUFNLENBQUNWLFNBQVMsWUFBWVcsY0FBY1AsS0FBS00sTUFBTSxDQUFDVixTQUFTLENBQUNZLEdBQUcsQ0FBQ0MsSUFBSSxLQUFLLFFBQzNILFNBQVNDLHFCQUFxQkMsR0FBRyxFQUFFQyxHQUFHLEVBQUVDLEdBQUc7UUFDM0NELElBQUlKLEdBQUcsQ0FBQ0csS0FBS0UsTUFBTSxzR0FBc0c7SUFDekgsb0NBQW9DO0lBQ3RDLElBRUUsU0FBU0Msc0JBQXNCSCxHQUFHLEVBQUVDLEdBQUcsRUFBRUMsR0FBRztRQUM1QyxJQUFJRixJQUFJSSxJQUFJLEVBQ1ZKLElBQUlJLElBQUksQ0FBQ0gsS0FBS0MsS0FBSyxHQUFHRixJQUFJSyxNQUFNO2FBQzdCLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJTixJQUFJSyxNQUFNLEVBQ2pDSixHQUFHLENBQUNDLE1BQU0sR0FBR0YsR0FBRyxDQUFDTSxJQUFJO0lBQ3pCO0FBQ1I7QUFHQTs7Q0FFQyxHQUNEeEIsYUFBYUcsU0FBUyxDQUFDc0IsS0FBSyxHQUFHLFNBQVNDLG1CQUFtQkMsS0FBSztJQUM1RCxJQUFJcEIsS0FBS3FCLFFBQVEsQ0FBQ0QsUUFDZEEsUUFBUXBCLEtBQUtzQixZQUFZLENBQUNGLE9BQU87SUFDckMsSUFBSUcsTUFBTUgsTUFBTUosTUFBTSxLQUFLO0lBQzNCLElBQUksQ0FBQ1EsTUFBTSxDQUFDRDtJQUNaLElBQUlBLEtBQ0EsSUFBSSxDQUFDRSxLQUFLLENBQUNoQyxhQUFhWSxnQkFBZ0IsRUFBRWtCLEtBQUtIO0lBQ25ELE9BQU8sSUFBSTtBQUNmO0FBRUEsU0FBU00sa0JBQWtCZixHQUFHLEVBQUVDLEdBQUcsRUFBRUMsR0FBRztJQUNwQyxJQUFJRixJQUFJSyxNQUFNLEdBQUcsSUFDYmhCLEtBQUsyQixJQUFJLENBQUNDLEtBQUssQ0FBQ2pCLEtBQUtDLEtBQUtDO1NBQ3pCLElBQUlELElBQUlpQixTQUFTLEVBQ2xCakIsSUFBSWlCLFNBQVMsQ0FBQ2xCLEtBQUtFO1NBRW5CRCxJQUFJZ0IsS0FBSyxDQUFDakIsS0FBS0U7QUFDdkI7QUFFQTs7Q0FFQyxHQUNEcEIsYUFBYUcsU0FBUyxDQUFDa0MsTUFBTSxHQUFHLFNBQVNDLG9CQUFvQlgsS0FBSztJQUM5RCxJQUFJRyxNQUFNdkIsS0FBS00sTUFBTSxDQUFDMEIsVUFBVSxDQUFDWjtJQUNqQyxJQUFJLENBQUNJLE1BQU0sQ0FBQ0Q7SUFDWixJQUFJQSxLQUNBLElBQUksQ0FBQ0UsS0FBSyxDQUFDQyxtQkFBbUJILEtBQUtIO0lBQ3ZDLE9BQU8sSUFBSTtBQUNmO0FBR0E7Ozs7O0NBS0MsR0FFRDNCLGFBQWFTLFVBQVUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3dyaXRlcl9idWZmZXIuanM/YWE0MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gQnVmZmVyV3JpdGVyO1xuXG4vLyBleHRlbmRzIFdyaXRlclxudmFyIFdyaXRlciA9IHJlcXVpcmUoXCIuL3dyaXRlclwiKTtcbihCdWZmZXJXcml0ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShXcml0ZXIucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBCdWZmZXJXcml0ZXI7XG5cbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbC9taW5pbWFsXCIpO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgYnVmZmVyIHdyaXRlciBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgV2lyZSBmb3JtYXQgd3JpdGVyIHVzaW5nIG5vZGUgYnVmZmVycy5cbiAqIEBleHRlbmRzIFdyaXRlclxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEJ1ZmZlcldyaXRlcigpIHtcbiAgICBXcml0ZXIuY2FsbCh0aGlzKTtcbn1cblxuQnVmZmVyV3JpdGVyLl9jb25maWd1cmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQWxsb2NhdGVzIGEgYnVmZmVyIG9mIHRoZSBzcGVjaWZpZWQgc2l6ZS5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZSBCdWZmZXIgc2l6ZVxuICAgICAqIEByZXR1cm5zIHtCdWZmZXJ9IEJ1ZmZlclxuICAgICAqL1xuICAgIEJ1ZmZlcldyaXRlci5hbGxvYyA9IHV0aWwuX0J1ZmZlcl9hbGxvY1Vuc2FmZTtcblxuICAgIEJ1ZmZlcldyaXRlci53cml0ZUJ5dGVzQnVmZmVyID0gdXRpbC5CdWZmZXIgJiYgdXRpbC5CdWZmZXIucHJvdG90eXBlIGluc3RhbmNlb2YgVWludDhBcnJheSAmJiB1dGlsLkJ1ZmZlci5wcm90b3R5cGUuc2V0Lm5hbWUgPT09IFwic2V0XCJcbiAgICAgICAgPyBmdW5jdGlvbiB3cml0ZUJ5dGVzQnVmZmVyX3NldCh2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgICAgICAgYnVmLnNldCh2YWwsIHBvcyk7IC8vIGZhc3RlciB0aGFuIGNvcHkgKHJlcXVpcmVzIG5vZGUgPj0gNCB3aGVyZSBCdWZmZXJzIGV4dGVuZCBVaW50OEFycmF5IGFuZCBzZXQgaXMgcHJvcGVybHkgaW5oZXJpdGVkKVxuICAgICAgICAgIC8vIGFsc28gd29ya3MgZm9yIHBsYWluIGFycmF5IHZhbHVlc1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIDogZnVuY3Rpb24gd3JpdGVCeXRlc0J1ZmZlcl9jb3B5KHZhbCwgYnVmLCBwb3MpIHtcbiAgICAgICAgICBpZiAodmFsLmNvcHkpIC8vIEJ1ZmZlciB2YWx1ZXNcbiAgICAgICAgICAgIHZhbC5jb3B5KGJ1ZiwgcG9zLCAwLCB2YWwubGVuZ3RoKTtcbiAgICAgICAgICBlbHNlIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsLmxlbmd0aDspIC8vIHBsYWluIGFycmF5IHZhbHVlc1xuICAgICAgICAgICAgYnVmW3BvcysrXSA9IHZhbFtpKytdO1xuICAgICAgICB9O1xufTtcblxuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5CdWZmZXJXcml0ZXIucHJvdG90eXBlLmJ5dGVzID0gZnVuY3Rpb24gd3JpdGVfYnl0ZXNfYnVmZmVyKHZhbHVlKSB7XG4gICAgaWYgKHV0aWwuaXNTdHJpbmcodmFsdWUpKVxuICAgICAgICB2YWx1ZSA9IHV0aWwuX0J1ZmZlcl9mcm9tKHZhbHVlLCBcImJhc2U2NFwiKTtcbiAgICB2YXIgbGVuID0gdmFsdWUubGVuZ3RoID4+PiAwO1xuICAgIHRoaXMudWludDMyKGxlbik7XG4gICAgaWYgKGxlbilcbiAgICAgICAgdGhpcy5fcHVzaChCdWZmZXJXcml0ZXIud3JpdGVCeXRlc0J1ZmZlciwgbGVuLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiB3cml0ZVN0cmluZ0J1ZmZlcih2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgaWYgKHZhbC5sZW5ndGggPCA0MCkgLy8gcGxhaW4ganMgaXMgZmFzdGVyIGZvciBzaG9ydCBzdHJpbmdzIChwcm9iYWJseSBkdWUgdG8gcmVkdW5kYW50IGFzc2VydGlvbnMpXG4gICAgICAgIHV0aWwudXRmOC53cml0ZSh2YWwsIGJ1ZiwgcG9zKTtcbiAgICBlbHNlIGlmIChidWYudXRmOFdyaXRlKVxuICAgICAgICBidWYudXRmOFdyaXRlKHZhbCwgcG9zKTtcbiAgICBlbHNlXG4gICAgICAgIGJ1Zi53cml0ZSh2YWwsIHBvcyk7XG59XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cbkJ1ZmZlcldyaXRlci5wcm90b3R5cGUuc3RyaW5nID0gZnVuY3Rpb24gd3JpdGVfc3RyaW5nX2J1ZmZlcih2YWx1ZSkge1xuICAgIHZhciBsZW4gPSB1dGlsLkJ1ZmZlci5ieXRlTGVuZ3RoKHZhbHVlKTtcbiAgICB0aGlzLnVpbnQzMihsZW4pO1xuICAgIGlmIChsZW4pXG4gICAgICAgIHRoaXMuX3B1c2god3JpdGVTdHJpbmdCdWZmZXIsIGxlbiwgdmFsdWUpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuXG4vKipcbiAqIEZpbmlzaGVzIHRoZSB3cml0ZSBvcGVyYXRpb24uXG4gKiBAbmFtZSBCdWZmZXJXcml0ZXIjZmluaXNoXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtCdWZmZXJ9IEZpbmlzaGVkIGJ1ZmZlclxuICovXG5cbkJ1ZmZlcldyaXRlci5fY29uZmlndXJlKCk7XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsIkJ1ZmZlcldyaXRlciIsIldyaXRlciIsInJlcXVpcmUiLCJwcm90b3R5cGUiLCJPYmplY3QiLCJjcmVhdGUiLCJjb25zdHJ1Y3RvciIsInV0aWwiLCJjYWxsIiwiX2NvbmZpZ3VyZSIsImFsbG9jIiwiX0J1ZmZlcl9hbGxvY1Vuc2FmZSIsIndyaXRlQnl0ZXNCdWZmZXIiLCJCdWZmZXIiLCJVaW50OEFycmF5Iiwic2V0IiwibmFtZSIsIndyaXRlQnl0ZXNCdWZmZXJfc2V0IiwidmFsIiwiYnVmIiwicG9zIiwid3JpdGVCeXRlc0J1ZmZlcl9jb3B5IiwiY29weSIsImxlbmd0aCIsImkiLCJieXRlcyIsIndyaXRlX2J5dGVzX2J1ZmZlciIsInZhbHVlIiwiaXNTdHJpbmciLCJfQnVmZmVyX2Zyb20iLCJsZW4iLCJ1aW50MzIiLCJfcHVzaCIsIndyaXRlU3RyaW5nQnVmZmVyIiwidXRmOCIsIndyaXRlIiwidXRmOFdyaXRlIiwic3RyaW5nIiwid3JpdGVfc3RyaW5nX2J1ZmZlciIsImJ5dGVMZW5ndGgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/protobufjs/src/writer_buffer.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/google/protobuf/api.json":
/*!***********************************************************!*\
  !*** ../node_modules/protobufjs/google/protobuf/api.json ***!
  \***********************************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"nested":{"google":{"nested":{"protobuf":{"nested":{"Api":{"fields":{"name":{"type":"string","id":1},"methods":{"rule":"repeated","type":"Method","id":2},"options":{"rule":"repeated","type":"Option","id":3},"version":{"type":"string","id":4},"sourceContext":{"type":"SourceContext","id":5},"mixins":{"rule":"repeated","type":"Mixin","id":6},"syntax":{"type":"Syntax","id":7}}},"Method":{"fields":{"name":{"type":"string","id":1},"requestTypeUrl":{"type":"string","id":2},"requestStreaming":{"type":"bool","id":3},"responseTypeUrl":{"type":"string","id":4},"responseStreaming":{"type":"bool","id":5},"options":{"rule":"repeated","type":"Option","id":6},"syntax":{"type":"Syntax","id":7}}},"Mixin":{"fields":{"name":{"type":"string","id":1},"root":{"type":"string","id":2}}},"SourceContext":{"fields":{"fileName":{"type":"string","id":1}}},"Option":{"fields":{"name":{"type":"string","id":1},"value":{"type":"Any","id":2}}},"Syntax":{"values":{"SYNTAX_PROTO2":0,"SYNTAX_PROTO3":1}}}}}}}}');

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/google/protobuf/descriptor.json":
/*!******************************************************************!*\
  !*** ../node_modules/protobufjs/google/protobuf/descriptor.json ***!
  \******************************************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"nested":{"google":{"nested":{"protobuf":{"nested":{"FileDescriptorSet":{"fields":{"file":{"rule":"repeated","type":"FileDescriptorProto","id":1}}},"FileDescriptorProto":{"fields":{"name":{"type":"string","id":1},"package":{"type":"string","id":2},"dependency":{"rule":"repeated","type":"string","id":3},"publicDependency":{"rule":"repeated","type":"int32","id":10,"options":{"packed":false}},"weakDependency":{"rule":"repeated","type":"int32","id":11,"options":{"packed":false}},"messageType":{"rule":"repeated","type":"DescriptorProto","id":4},"enumType":{"rule":"repeated","type":"EnumDescriptorProto","id":5},"service":{"rule":"repeated","type":"ServiceDescriptorProto","id":6},"extension":{"rule":"repeated","type":"FieldDescriptorProto","id":7},"options":{"type":"FileOptions","id":8},"sourceCodeInfo":{"type":"SourceCodeInfo","id":9},"syntax":{"type":"string","id":12}}},"DescriptorProto":{"fields":{"name":{"type":"string","id":1},"field":{"rule":"repeated","type":"FieldDescriptorProto","id":2},"extension":{"rule":"repeated","type":"FieldDescriptorProto","id":6},"nestedType":{"rule":"repeated","type":"DescriptorProto","id":3},"enumType":{"rule":"repeated","type":"EnumDescriptorProto","id":4},"extensionRange":{"rule":"repeated","type":"ExtensionRange","id":5},"oneofDecl":{"rule":"repeated","type":"OneofDescriptorProto","id":8},"options":{"type":"MessageOptions","id":7},"reservedRange":{"rule":"repeated","type":"ReservedRange","id":9},"reservedName":{"rule":"repeated","type":"string","id":10}},"nested":{"ExtensionRange":{"fields":{"start":{"type":"int32","id":1},"end":{"type":"int32","id":2}}},"ReservedRange":{"fields":{"start":{"type":"int32","id":1},"end":{"type":"int32","id":2}}}}},"FieldDescriptorProto":{"fields":{"name":{"type":"string","id":1},"number":{"type":"int32","id":3},"label":{"type":"Label","id":4},"type":{"type":"Type","id":5},"typeName":{"type":"string","id":6},"extendee":{"type":"string","id":2},"defaultValue":{"type":"string","id":7},"oneofIndex":{"type":"int32","id":9},"jsonName":{"type":"string","id":10},"options":{"type":"FieldOptions","id":8}},"nested":{"Type":{"values":{"TYPE_DOUBLE":1,"TYPE_FLOAT":2,"TYPE_INT64":3,"TYPE_UINT64":4,"TYPE_INT32":5,"TYPE_FIXED64":6,"TYPE_FIXED32":7,"TYPE_BOOL":8,"TYPE_STRING":9,"TYPE_GROUP":10,"TYPE_MESSAGE":11,"TYPE_BYTES":12,"TYPE_UINT32":13,"TYPE_ENUM":14,"TYPE_SFIXED32":15,"TYPE_SFIXED64":16,"TYPE_SINT32":17,"TYPE_SINT64":18}},"Label":{"values":{"LABEL_OPTIONAL":1,"LABEL_REQUIRED":2,"LABEL_REPEATED":3}}}},"OneofDescriptorProto":{"fields":{"name":{"type":"string","id":1},"options":{"type":"OneofOptions","id":2}}},"EnumDescriptorProto":{"fields":{"name":{"type":"string","id":1},"value":{"rule":"repeated","type":"EnumValueDescriptorProto","id":2},"options":{"type":"EnumOptions","id":3}}},"EnumValueDescriptorProto":{"fields":{"name":{"type":"string","id":1},"number":{"type":"int32","id":2},"options":{"type":"EnumValueOptions","id":3}}},"ServiceDescriptorProto":{"fields":{"name":{"type":"string","id":1},"method":{"rule":"repeated","type":"MethodDescriptorProto","id":2},"options":{"type":"ServiceOptions","id":3}}},"MethodDescriptorProto":{"fields":{"name":{"type":"string","id":1},"inputType":{"type":"string","id":2},"outputType":{"type":"string","id":3},"options":{"type":"MethodOptions","id":4},"clientStreaming":{"type":"bool","id":5},"serverStreaming":{"type":"bool","id":6}}},"FileOptions":{"fields":{"javaPackage":{"type":"string","id":1},"javaOuterClassname":{"type":"string","id":8},"javaMultipleFiles":{"type":"bool","id":10},"javaGenerateEqualsAndHash":{"type":"bool","id":20,"options":{"deprecated":true}},"javaStringCheckUtf8":{"type":"bool","id":27},"optimizeFor":{"type":"OptimizeMode","id":9,"options":{"default":"SPEED"}},"goPackage":{"type":"string","id":11},"ccGenericServices":{"type":"bool","id":16},"javaGenericServices":{"type":"bool","id":17},"pyGenericServices":{"type":"bool","id":18},"deprecated":{"type":"bool","id":23},"ccEnableArenas":{"type":"bool","id":31},"objcClassPrefix":{"type":"string","id":36},"csharpNamespace":{"type":"string","id":37},"uninterpretedOption":{"rule":"repeated","type":"UninterpretedOption","id":999}},"extensions":[[1000,536870911]],"reserved":[[38,38]],"nested":{"OptimizeMode":{"values":{"SPEED":1,"CODE_SIZE":2,"LITE_RUNTIME":3}}}},"MessageOptions":{"fields":{"messageSetWireFormat":{"type":"bool","id":1},"noStandardDescriptorAccessor":{"type":"bool","id":2},"deprecated":{"type":"bool","id":3},"mapEntry":{"type":"bool","id":7},"uninterpretedOption":{"rule":"repeated","type":"UninterpretedOption","id":999}},"extensions":[[1000,536870911]],"reserved":[[8,8]]},"FieldOptions":{"fields":{"ctype":{"type":"CType","id":1,"options":{"default":"STRING"}},"packed":{"type":"bool","id":2},"jstype":{"type":"JSType","id":6,"options":{"default":"JS_NORMAL"}},"lazy":{"type":"bool","id":5},"deprecated":{"type":"bool","id":3},"weak":{"type":"bool","id":10},"uninterpretedOption":{"rule":"repeated","type":"UninterpretedOption","id":999}},"extensions":[[1000,536870911]],"reserved":[[4,4]],"nested":{"CType":{"values":{"STRING":0,"CORD":1,"STRING_PIECE":2}},"JSType":{"values":{"JS_NORMAL":0,"JS_STRING":1,"JS_NUMBER":2}}}},"OneofOptions":{"fields":{"uninterpretedOption":{"rule":"repeated","type":"UninterpretedOption","id":999}},"extensions":[[1000,536870911]]},"EnumOptions":{"fields":{"allowAlias":{"type":"bool","id":2},"deprecated":{"type":"bool","id":3},"uninterpretedOption":{"rule":"repeated","type":"UninterpretedOption","id":999}},"extensions":[[1000,536870911]]},"EnumValueOptions":{"fields":{"deprecated":{"type":"bool","id":1},"uninterpretedOption":{"rule":"repeated","type":"UninterpretedOption","id":999}},"extensions":[[1000,536870911]]},"ServiceOptions":{"fields":{"deprecated":{"type":"bool","id":33},"uninterpretedOption":{"rule":"repeated","type":"UninterpretedOption","id":999}},"extensions":[[1000,536870911]]},"MethodOptions":{"fields":{"deprecated":{"type":"bool","id":33},"uninterpretedOption":{"rule":"repeated","type":"UninterpretedOption","id":999}},"extensions":[[1000,536870911]]},"UninterpretedOption":{"fields":{"name":{"rule":"repeated","type":"NamePart","id":2},"identifierValue":{"type":"string","id":3},"positiveIntValue":{"type":"uint64","id":4},"negativeIntValue":{"type":"int64","id":5},"doubleValue":{"type":"double","id":6},"stringValue":{"type":"bytes","id":7},"aggregateValue":{"type":"string","id":8}},"nested":{"NamePart":{"fields":{"namePart":{"rule":"required","type":"string","id":1},"isExtension":{"rule":"required","type":"bool","id":2}}}}},"SourceCodeInfo":{"fields":{"location":{"rule":"repeated","type":"Location","id":1}},"nested":{"Location":{"fields":{"path":{"rule":"repeated","type":"int32","id":1},"span":{"rule":"repeated","type":"int32","id":2},"leadingComments":{"type":"string","id":3},"trailingComments":{"type":"string","id":4},"leadingDetachedComments":{"rule":"repeated","type":"string","id":6}}}}},"GeneratedCodeInfo":{"fields":{"annotation":{"rule":"repeated","type":"Annotation","id":1}},"nested":{"Annotation":{"fields":{"path":{"rule":"repeated","type":"int32","id":1},"sourceFile":{"type":"string","id":2},"begin":{"type":"int32","id":3},"end":{"type":"int32","id":4}}}}}}}}}}}');

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/google/protobuf/source_context.json":
/*!**********************************************************************!*\
  !*** ../node_modules/protobufjs/google/protobuf/source_context.json ***!
  \**********************************************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"nested":{"google":{"nested":{"protobuf":{"nested":{"SourceContext":{"fields":{"fileName":{"type":"string","id":1}}}}}}}}}');

/***/ }),

/***/ "(ssr)/../node_modules/protobufjs/google/protobuf/type.json":
/*!************************************************************!*\
  !*** ../node_modules/protobufjs/google/protobuf/type.json ***!
  \************************************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"nested":{"google":{"nested":{"protobuf":{"nested":{"Type":{"fields":{"name":{"type":"string","id":1},"fields":{"rule":"repeated","type":"Field","id":2},"oneofs":{"rule":"repeated","type":"string","id":3},"options":{"rule":"repeated","type":"Option","id":4},"sourceContext":{"type":"SourceContext","id":5},"syntax":{"type":"Syntax","id":6}}},"Field":{"fields":{"kind":{"type":"Kind","id":1},"cardinality":{"type":"Cardinality","id":2},"number":{"type":"int32","id":3},"name":{"type":"string","id":4},"typeUrl":{"type":"string","id":6},"oneofIndex":{"type":"int32","id":7},"packed":{"type":"bool","id":8},"options":{"rule":"repeated","type":"Option","id":9},"jsonName":{"type":"string","id":10},"defaultValue":{"type":"string","id":11}},"nested":{"Kind":{"values":{"TYPE_UNKNOWN":0,"TYPE_DOUBLE":1,"TYPE_FLOAT":2,"TYPE_INT64":3,"TYPE_UINT64":4,"TYPE_INT32":5,"TYPE_FIXED64":6,"TYPE_FIXED32":7,"TYPE_BOOL":8,"TYPE_STRING":9,"TYPE_GROUP":10,"TYPE_MESSAGE":11,"TYPE_BYTES":12,"TYPE_UINT32":13,"TYPE_ENUM":14,"TYPE_SFIXED32":15,"TYPE_SFIXED64":16,"TYPE_SINT32":17,"TYPE_SINT64":18}},"Cardinality":{"values":{"CARDINALITY_UNKNOWN":0,"CARDINALITY_OPTIONAL":1,"CARDINALITY_REQUIRED":2,"CARDINALITY_REPEATED":3}}}},"Enum":{"fields":{"name":{"type":"string","id":1},"enumvalue":{"rule":"repeated","type":"EnumValue","id":2},"options":{"rule":"repeated","type":"Option","id":3},"sourceContext":{"type":"SourceContext","id":4},"syntax":{"type":"Syntax","id":5}}},"EnumValue":{"fields":{"name":{"type":"string","id":1},"number":{"type":"int32","id":2},"options":{"rule":"repeated","type":"Option","id":3}}},"Option":{"fields":{"name":{"type":"string","id":1},"value":{"type":"Any","id":2}}},"Syntax":{"values":{"SYNTAX_PROTO2":0,"SYNTAX_PROTO3":1}},"Any":{"fields":{"type_url":{"type":"string","id":1},"value":{"type":"bytes","id":2}}},"SourceContext":{"fields":{"fileName":{"type":"string","id":1}}}}}}}}}');

/***/ })

};
;